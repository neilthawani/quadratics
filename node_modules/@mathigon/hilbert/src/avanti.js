var Calculus = {};

(function(context) {
  context.dfunction = function(e, x) {
    var result = null;

    if (lasterror || !Types.isFunction(e))
      return Types.UNDEFINED;

    var u = Expression.operand(e, 1);
    var du = context.derivative(u, x);
    if (Types.isFunctionOfType(e, Types.fnI)) {
      result = e;
    } else if (Types.isFunctionOfType(e, Types.fnEXP)) {
      result = e;
    } else if (Types.isFunctionOfType(e, Types.fnLOG)) {
      result = Expression.construct(Types.PowOp, null, [u, Types.MINUSONE]);
    } else if (Types.isFunctionOfType(e, Types.fnSIN)) {
      result = Expression.construct(Types.fn, Types.fnCOS, [u]);
    } else if (Types.isFunctionOfType(e, Types.fnCOS)) {
      result = Expression.construct(Types.ProdOp, null,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnSIN, [u])]);
    } else if (Types.isFunctionOfType(e, Types.fnTAN)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnSEC, [u]), Types.TWO]);
    } else if (Types.isFunctionOfType(e, Types.fnCOT)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCSC, [u]), Types.TWO]);
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    } else if (Types.isFunctionOfType(e, Types.fnSEC)) {
      result = Expression.construct(Types.ProdOp, null,
          [Expression.construct(Types.fn, Types.fnSEC, [u]), Expression.construct(Types.fn, Types.fnTAN, [u])]);
    } else if (Types.isFunctionOfType(e, Types.fnCSC)) {
      result = Expression.construct(Types.ProdOp, null,
          [Expression.construct(Types.fn, Types.fnCSC, [u]), Expression.construct(Types.fn, Types.fnCOT, [u])]);
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    } else if (Types.isFunctionOfType(e, Types.fnSINH)) {
      result = Expression.construct(Types.fn, Types.fnCOSH, [u]);
    } else if (Types.isFunctionOfType(e, Types.fnCOSH)) {
      result = Expression.construct(Types.fn, Types.fnSINH, [u]);
    } else if (Types.isFunctionOfType(e, Types.fnTANH)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnSECH, [u]), Types.TWO]);
    } else if (Types.isFunctionOfType(e, Types.fnCOTH)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCSCH, [u]), Types.TWO]);
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    } else if (Types.isFunctionOfType(e, Types.fnSECH)) {
      result = Expression.construct(Types.ProdOp, null,
          [Expression.construct(Types.fn, Types.fnSECH, [u]), Expression.construct(Types.fn, Types.fnTANH, [u])]);
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    } else if (Types.isFunctionOfType(e, Types.fnCSCH)) {
      result = Expression.construct(Types.ProdOp, null, [Expression.construct(Types.fn, Types.fnCSCH, [u]),
        Expression.construct(Types.fn, Types.fnCOTH, [u])]);
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    } else if (Types.isFunctionOfType(e, Types.fnASIN)) {
      u = Expression.construct(Types.PowOp, null, [u, Types.TWO]);		// x^2
      u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, u]);	// -x^2
      u = Expression.construct(Types.SumOp, null, [Types.ONE, u]);		// 1 - x^2
      result = Expression.construct(Types.PowOp, null,
          [u, Expression.construct(Types.ProdOp, null, [Types.MINUSONE, Types.HALF])]);		// (1 - x^2)^(-1/2)
    } else if (Types.isFunctionOfType(e, Types.fnACOS)) {
      u = Expression.construct(Types.PowOp, null, [u, Types.TWO]);		// x^2
      u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, u]);	// -x^2
      u = Expression.construct(Types.SumOp, null, [Types.ONE, u]);		// 1 - x^2
      u = Expression.construct(Types.PowOp, null,
          [u, Expression.construct(Types.ProdOp, null, [Types.MINUSONE, Types.HALF])]);		// (1 - x^2)^(-1/2)
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, u]);
    } else if (Types.isFunctionOfType(e, Types.fnATAN)) {
      u = Expression.construct(Types.PowOp, null, [u, Types.TWO]);		// x^2
      u = Expression.construct(Types.SumOp, null, [Types.ONE, u]);		// 1 + x^2
      result = Expression.construct(Types.PowOp, null, [u, Types.MINUSONE]);		// (1 + x^2)^-1
    } else if (Types.isFunctionOfType(e, Types.fnASINH)) {
      u = Expression.construct(Types.PowOp, null, [u, Types.TWO]);		// x^2
      u = Expression.construct(Types.SumOp, null, [Types.ONE, u]);		// 1 + x^2
      result = Expression.construct(Types.PowOp, null, [u, Types.HALF]);
    } else if (Types.isFunctionOfType(e, Types.fnACOSH)) {
      u = Expression.construct(Types.PowOp, null, [u, Types.TWO]);		// x^2
      u = Expression.construct(Types.SumOp, null, [Types.MINUSONE, u]);		// -1 + x^2
      result = Expression.construct(Types.PowOp, null, [u, Types.HALF]);
    } else if (Types.isFunctionOfType(e, Types.fnATANH)) {
      u = Expression.construct(Types.PowOp, null, [u, Types.TWO]);		// x^2
      u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, u]);	// -x^2
      u = Expression.construct(Types.SumOp, null, [Types.ONE, u]);		// 1 - x^2
      result = Expression.construct(Types.PowOp, null, [u, Types.MINUSONE]);		// (1 + x^2)^-1
    }
    if (result) {
      result = Expression.construct(Types.ProdOp, null, [du, result]);
      result = Transform.trigtransform(result);
    }

    return result;
  }

  context.derivative = function(e, x) {
    var u, v, w, t, result = null;

    if (lasterror)
      return Types.UNDEFINED;

    if (Expression.equal_expressions(e, x))	// Deriv[x_, x_ ] := 1;
      result = Types.ONE;
    else if (Types.isOpOfType(e, Types.PowOp)) {
      // Deriv[ v_^w_, x_] := w*v^(w-1)*Deriv[v,x] + Deriv[w,x]*v^w*Log[v];
      v = Expression.base(e);
      w = Expression.exponent(e);
      u = Expression.construct(Types.SumOp, null, [w, Types.MINUSONE]);
      u = Expression.construct(Types.ProdOp, null, [w, Expression.construct(Types.PowOp, null, [v, u])]);
      u = Expression.construct(Types.ProdOp, null, [u, context.derivative(v, x)]);
      t = Expression.construct(Types.ProdOp, null, [Expression.construct(Types.PowOp, null, [v, w]),
        Expression.construct(Types.fn, Types.fnLOG, [v])]);
      t = Expression.construct(Types.ProdOp, null, [context.derivative(w, x), t]);
      result = Expression.construct(Types.SumOp, null, [u, t]);
    } else if (Types.isOpOfType(e, Types.SumOp)) {
      // Deriv[ u_ + v_, x_ ] := Deriv[u,x] + Deriv[v,x];
      u = Expression.operand(e, 1);
      v = Expression.dropfirstterm(e);
      result = Expression.construct(Types.SumOp, null, [context.derivative(u, x), context.derivative(v, x)]);
    } else if (Types.isOpOfType(e, Types.ProdOp)) {
      // Deriv[u,x]*v + Deriv[v,x]*u
      u = Expression.operand(e, 1);
      v = Expression.dropfirstterm(e);
      w = Expression.construct(Types.ProdOp, null, [context.derivative(u, x), v]);
      t = Expression.construct(Types.ProdOp, null, [context.derivative(v, x), u]);
      result = Expression.construct(Types.SumOp, null, [w, t]);
    } else if (Expression.free_of(e, x)) {
      // Deriv[u_,x_] := 0 /; FreeQ[u,x] === True;
      result = Types.ZERO;
    } else if (Types.isFunction(e)) {
      if (Expression.num_operands(e) == 1) {
        // derivative f(g(x)) = f'(g(x)).g'(x)
        var result = context.dfunction(e, x);
        if (result == null) {
          var df = Expression.construct(Types.fn, Types.fnD, [e, x]);
          var dg = context.derivative(Expression.operand(e, 1), x);
          result = Expression.construct(Types.ProdOp, null, [df, dg]);
        }
      } else if (Types.isFunctionOfType(e, Types.fnI)) {
        if (Expression.equal_expressions(Expression.operand(e, 2), x))
          result = Expression.operand(e, 1);
      }
    }

    if (!result)
      result = Expression.construct(Types.fn, Types.fnD, [e, x]);

    return Simplify.automatic_simplify(result);
  }

  context.integral_table = function(f, x) {
    var result = null;

    if (Expression.free_of(f, x)) {
      result = Expression.makenode(Types.ProdOp, null, [f, x]);
      return Simplify.automatic_simplify(result);
    }

    if (Types.isFunction(f) && (Expression.num_operands(f) == 2) && Types.isFunctionOfType(f, Types.fnD)) {
      var arg1 = Expression.operand(f, 1);
      var arg2 = Expression.operand(f, 1);
      if (Expression.equal_expressions(arg2, x))
        return arg1;
    }

    var x = Expression.copy(x);

    if (Expression.equal_expressions(f, x)) {
      return Expression.makenode(Types.QuotOp, null,
          [Expression.makenode(Types.PowOp, null, [x, Types.TWO]), Types.TWO]);
    }
    if (Types.isOpOfType(f, Types.PowOp)) {
      var base = Expression.operand(f, 1);
      var exponent = Expression.operand(f, 2);
      if (Expression.equal_expressions(base, x) && Expression.free_of(exponent, x)) {
        if (Expression.equal_expressions(exponent, Types.MINUSONE))
          return Expression.makenode(Types.fn, Types.fnLOG, [x]);
        var expplus = Expression.makenode(Types.SumOp, null, [exponent, Types.ONE]);
        return Expression.makenode(Types.QuotOp, null,
            [Expression.makenode(Types.PowOp, null, [x, expplus]), expplus]);
      } else if (Expression.equal_expressions(exponent, x) && Expression.free_of(base, x)) {
        var basecopy = Expression.copy(base);
        var fcopy = Expression.copy(f);
        return Expression.makenode(Types.QuotOp, null, [f,
          Expression.makenode(Types.fn, Types.fnLOG, [basecopy])]);
      } else if (Expression.equal_expressions(exponent, Types.TWO)) {
        var arg = Expression.operand(base, 1);
        if (Expression.equal_expressions(arg, x)) {
          if (Types.isFunctionOfType(base, Types.fnSEC))
            return Expression.makenode(Types.fn, Types.fnTAN, [x]);
          else if (Types.isFunctionOfType(base, Types.fnCSC))
            return Expression.makenode(Types.ProdOp, null, [Types.MINUSONE,
              Expression.makenode(Types.fn, Types.fnCOT, [x])]);
        }
      }
    } else if (Types.isOpOfType(f, Types.ProdOp) && Expression.num_operands(f) == 2) {
      var p = Expression.operand(f, 1);
      var q = Expression.operand(f, 2);
      if ((Types.isFunctionOfType(p, Types.fnSEC) && Types.isFunctionOfType(q, Types.fnTAN)) ||
          (Types.isFunctionOfType(p, Types.fnTAN) && Types.isFunctionOfType(q, Types.fnSEC))) {
        if (Expression.num_operands(p) == 1 && Expression.num_operands(q) == 1) {
          var pargok = Expression.equal_expressions(Expression.operand(p, 1), x);
          var qargok = Expression.equal_expressions(Expression.operand(q, 1), x);
          if (pargok && qargok)
            return Expression.makenode(Types.fn, Types.fnSEC, [x]);
        }
      }
      if ((Types.isFunctionOfType(p, Types.fnSECH) && Types.isFunctionOfType(q, Types.fnTANH)) ||
          (Types.isFunctionOfType(p, Types.fnTANH) && Types.isFunctionOfType(q, Types.fnSECH))) {
        if (Expression.num_operands(p) == 1 && Expression.num_operands(q) == 1) {
          var pargok = Expression.equal_expressions(Expression.operand(p, 1), x);
          var qargok = Expression.equal_expressions(Expression.operand(q, 1), x);
          if (pargok && qargok)
            return Expression.makenode(Types.ProdOp, null, [Types.MINUSONE,
              Expression.makenode(Types.fn, Types.fnSECH, [x])]);
        }
      }
      //		x^x (1 + Log[x]) form
      if (Types.isOpOfType(p, Types.PowOp) && Types.isOpOfType(q, Types.SumOp)) {
        var p1 = Expression.operand(p, 1);
        var p2 = Expression.operand(p, 2);
        var q1 = Expression.operand(q, 1);
        var q2 = Expression.operand(q, 2);
        if (Expression.equal_expressions(p1, p2) && Types.isOne(q1) &&
            Types.isFunctionOfType(q2, Types.fnLOG) &&
            Expression.num_operands(q2) == 1 &&
            Expression.equal_expressions(p1, Expression.operand(q2, 1))) {
          return p;
        }
      }
    }
    //		x^x + x^x*Log[x] form
    else if (Types.isOpOfType(f, Types.SumOp) && Expression.num_operands(f) == 2) {
      var p = Expression.operand(f, 1);
      var q = Expression.operand(f, 2);
      if (Types.isOpOfType(p, Types.PowOp)) {
        var p1 = Expression.operand(p, 1);
        var p2 = Expression.operand(p, 2);
        var q1 = Expression.operand(q, 1);
        var q2 = Expression.operand(q, 2);
        if (Expression.equal_expressions(p1, p2) &&
            Expression.equal_expressions(p, q1) &&
            Types.isFunctionOfType(q2, Types.fnLOG) &&
            Expression.num_operands(q2) == 1 &&
            Expression.equal_expressions(p1, Expression.operand(q2, 1))) {
          return p;
        }
      }
    }
    if (Types.isFunction(f) && Expression.num_operands(f) == 1) {
      var arg = Expression.operand(f, 1);
      if (Expression.equal_expressions(arg, x)) {
        switch (f.value) {
          case Types.fnSIN:
            result = Expression.makenode(Types.ProdOp, null, [Types.MINUSONE,
              Expression.makenode(Types.fn, Types.fnCOS, [x])]);
            break;
          case Types.fnCOS:
            result = Expression.makenode(Types.fn, Types.fnSIN, [x]);
            break;
          case Types.fnTAN:
            result = Expression.makenode(Types.ProdOp, null, [Types.MINUSONE,
              Expression.makenode(Types.fn, Types.fnLOG, [
                Expression.makenode(Types.fn, Types.fnCOS, [x])])]);
            break;
          case Types.fnSEC:
            result = Expression.makenode(Types.fn, Types.fnLOG, [
              Expression.makenode(Types.SumOp, null,
                  [Expression.makenode(Types.fn, Types.fnSEC, [x]),
                    Expression.makenode(Types.fn, Types.fnTAN, [x])])]);
            break;
          case Types.fnCSC:
            result = Expression.makenode(Types.fn, Types.fnLOG, [
              Expression.diff(
                  Expression.makenode(Types.fn, Types.fnCSC, [x]),
                  Expression.makenode(Types.fn, Types.fnCOT, [x]))]);
            break;
          case Types.fnCOT:
            result = Expression.makenode(Types.fn, Types.fnLOG, [
              Expression.makenode(Types.fn, Types.fnSIN, [x])]);
            break;
          case Types.fnSINH:
            result = Expression.makenode(Types.fn, Types.fnCOSH, [x]);
            break;
          case Types.fnCOSH:
            result = Expression.makenode(Types.fn, Types.fnSINH, [x]);
            break;
          case Types.fnTANH:
            result = Expression.makenode(Types.fn, Types.fnLOG, [
              Expression.makenode(Types.fn, Types.fnCOSH, [x])]);
            break;
          case Types.fnSECH:
            result = Expression.makenode(Types.fn, Types.fnATAN, [
              Expression.makenode(Types.fn, Types.fnSINH, [x])]);
            break;
          case Types.fnCSCH:
            result = Expression.makenode(Types.fn, Types.fnLOG, [
              Expression.makenode(Types.fn, Types.fnTANH,
                  [Expression.makenode(Types.ProdOp, null, [Types.HALF, x])])]);
            break;
          case Types.fnCOTH:
            result = Expression.makenode(Types.fn, Types.fnLOG, [
              Expression.makenode(Types.fn, Types.fnSINH, [x])]);
            break;
          case Types.fnEXP:
            result = Expression.makenode(Types.fn, Types.fnEXP, [x]);
            break;
          case Types.fnLOG:
            result = Expression.makenode(Types.DiffOp, null, [
              Expression.makenode(Types.ProdOp, null, [x,
                Expression.makenode(Types.fn, Types.fnLOG, [x])]), x]);
            break;
        }
        if (result)
          return Simplify.automatic_simplify(result);
      }
    }
    return null;
  }

  context.linear_properties = function(f, x) {
    var result = null;
    if (Types.isOpOfType(f, Types.ProdOp)) {
      var sep = Expression.separate_factors(f, x);
      if (!Types.isOne(sep.free) && !Types.isOne(sep.free)) {
        result = Expression.makenode(Types.ProdOp, null,
            [sep.free, context.integral(sep.dep, x)]);
      }
    } else if (Types.isOpOfType(f, Types.SumOp)) {
      result = Expression.makenode(Types.SumOp, null, []);
      for (var i = 1; i <= Expression.num_operands(f); ++i) {
        var u = Expression.operand(f, i);
        result.children.push(context.integral(u, x));
      }
    }
    return result ? Simplify.automatic_simplify(result) : null;
  }

  // find all functions, arguments of functions, and bases and exponents of powers that occur in f
  context.trial_substitutions = function(f, a) {
    if (Types.isFunction(f)) {
      a.push(f);
      a.push(Expression.operand(f, 1));
    } else if (Types.isOpOfType(f, Types.PowOp)) {
      a.push(Expression.operand(f, 1));
      a.push(Expression.operand(f, 2));
    }
    if (f.children)
      f.children.map(function(c) {
        context.trial_substitutions(c, a);
      });

    return a;
  }

  context.v = Expression.construct(Types.symbol, 'v', null);

  context.substitution_method = function(f, x, subs) {
    var p = subs ? subs : context.trial_substitutions(f, []);
    var result = null;
    for (var i = 0; !result && i < p.length; ++i) {
      var g = p[i];
      if (Expression.equal_expressions(g, x) || Expression.free_of(g, x))
        continue;
      var dg = context.derivative(g, x);
      var r = Rational.rational_div(f, dg);
      var u = Expression.substitute(r, g, context.v);
      if (Expression.free_of(u, x)) {
        var integral = context.integral(u, context.v);
        if (integral) {
          result = Expression.substitute(integral, context.v, g);
        }
      }
    }

    return result;
  }

  context.rational_form = function(f, x) {
    f = Rational.rationalise_expression(f);
    var n = Rational.numerator(f);
    var lin = Polynomial.linear_form(n, x);
    if (!lin)
      return null;
    var d = Rational.denominator(f);
    var quad = Polynomial.quadratic_form(d, x);
    if (!quad)
      return null;

    var result, sqrtd, t;
    var r = lin[0];
    var s = lin[1];
    var a = quad[0];
    var b = quad[1];
    var c = quad[2];

    if (Types.isZero(a) && Types.isZero(r))
      return null;

    if (Types.isZero(r) && Types.isOne(s)) {
      // d = 4 * a * c - b * b;
      d = Expression.construct(Types.ProdOp, null, [Types.asInteger(4), a])
      d = Expression.construct(Types.ProdOp, null, [d, c])
      d = Expression.construct(Types.DiffOp, null,
          [d, Expression.construct(Types.ProdOp, null, [b, b])]);
      d = Simplify.automatic_simplify(d);
      var dval = Expression.numerical_evaluate(d);

      // 2ax+b
      t = Expression.construct(Types.ProdOp, null, [Types.TWO, a])
      t = Expression.construct(Types.ProdOp, null, [t, x])
      t = Expression.construct(Types.SumOp, null, [t, b]);
      t = Simplify.automatic_simplify(t);

      if (Types.isZero(dval)) {
        return Expression.construct(Types.ProdOp, null,
            [Types.MINUSONE, Rational.rational_div(Types.TWO, t)]);
      } else if (!Types.isNumber(dval) || (Types.toRealValue(dval) > 0)) {
        sqrtd = Expression.construct(Types.PowOp, null, [d, Types.HALF]);
        result = Rational.rational_div(t, sqrtd);
        result = Expression.construct(Types.fn, Types.fnATAN, result);
      } else {
        d = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, d]);
        sqrtd = Expression.construct(Types.PowOp, null, [d, Types.HALF]);
        d = Simplify.automatic_simplify(d);
        result = Rational.rational_div(t, sqrtd);
        result = Expression.construct(Types.ProdOp, null,
            [Types.MINUSONE, Expression.construct(Types.fn, Types.fnATANH, result)]);
      }
      result = Expression.construct(Types.ProdOp, null, [Types.TWO, result]);
      result = Rational.rational_div(result, sqrtd);
      return result;
    } else if (Types.isZero(a) && !Types.isZero(r) && !Types.isOne(b)) {
      var bsminuscr = Expression.construct(Types.ProdOp, null, [b, s]);
      bsminuscr = Expression.construct(Types.DiffOp, null,
          [bsminuscr, Expression.construct(Types.ProdOp, null, [c, r])]);
      bsminuscr = Simplify.automatic_simplify(bsminuscr);
      result = Expression.construct(Types.ProdOp, null,
          [bsminuscr, Expression.construct(Types.fn, Types.fnLOG, d)]);
      result = Rational.rational_div(result, Expression.construct(Types.ProdOp, null, [b, b]));
      result = Expression.construct(Types.SumOp, null,
          [result, Rational.rational_div(Expression.construct(Types.ProdOp, null, [r, x]), b)]);
      return result;
    } else {
      var twoa = Expression.construct(Types.ProdOp, null, [Types.TWO, a]);
      var alpha = Rational.rational_div(r, twoa);
      var beta = Expression.construct(Types.DiffOp, null,
          [s, Expression.construct(Types.ProdOp, null, [b, alpha])]);
      beta = Simplify.automatic_simplify(beta);
      result = Expression.construct(Types.ProdOp, null,
          [alpha, Expression.construct(Types.fn, Types.fnLOG, d)]);
      var subint = context.integral(Rational.rational_div(Types.ONE, d), x);
      result = Expression.construct(Types.SumOp, null,
          [result, Expression.construct(Types.ProdOp, null, [beta, subint])]);
      return result;
    }

    return null;
  }

  context.root_asqxsq_form = function(u, x) {
    if (!Types.isOpOfType(u, Types.PowOp))
      return null;

    var base = Expression.operand(u, 1);
    var exponent = Expression.operand(u, 2);

    if (!Expression.equal_expressions(exponent, Types.HALF))
      return null;
    if (!Types.isOpOfType(base, Types.SumOp))
      return null;

    var quad = Polynomial.quadratic_form(base, x);
    if (!quad)
      return null;
    var c2 = quad[0];
    var c1 = quad[1];
    var c0 = quad[2];

    if (Types.isZero(c2) || !Types.isZero(c1))
      return null;

    var bsqval = 1;
    var b;
    var negc0 = false;
    var negc2 = false;

    if (Types.isOpOfType(c2, Types.ProdOp) &&
        (Expression.equal_expressions(Expression.operand(c2, 1), Types.MINUSONE))) {
      negc2 = true;
      c2 = Expression.dropfirstterm(c2);
    } else if (Expression.equal_expressions(c2, Types.MINUSONE)) {
      negc2 = true;
      c2 = Types.ONE;
    }

    if (Types.isOpOfType(c0, Types.ProdOp) &&
        (Expression.equal_expressions(Expression.operand(c0, 1), Types.MINUSONE))) {
      negc0 = true;
    }

    if (Types.isOpOfType(c2, Types.PowOp)) {
      var c2base = Expression.operand(c2, 1);
      var c2exp = Expression.operand(c2, 2);
      if (Types.isRationalValue(c2exp)) {
        var r = Types.toFrac(c2exp);
        b = Expression.construct(Types.PowOp, null, [c2base, Types.asFrac(r.n, 2 * r.d)]);
      }
    }

    if (!b)
      b = Expression.construct(Types.PowOp, null, [c2, Types.HALF]);

    b = Simplify.automatic_simplify(b);

    return {asq: c0, b: b, bsq: c2, bsqval: bsqval, negc2: negc2};
  }

  context.radical_form = function(f, x) {
    f = Rational.rationalise_expression(f);
    var n = Rational.numerator(f);
    var d = Rational.denominator(f);
    var inv;

    var rf;
    if (Types.isOne(d)) {
      rf = context.root_asqxsq_form(n, x);
      d = n;
      inv = false;
    } else if (Types.isOne(n)) {
      rf = context.root_asqxsq_form(d, x);
      inv = true;
    }
    if (!rf)
      return null;

    var result = null;
    var t1, t2;

    if (inv) {
      if (rf.negc2) {
        t1 = Rational.rational_div(Expression.construct(Types.ProdOp, null, [rf.b, x]), d);
        t2 = Expression.construct(Types.PowOp, null, [rf.b, Types.MINUSONE]);
        result = Expression.construct(Types.ProdOp, null,
            [t2, Expression.construct(Types.fn, Types.fnATAN, [t1])]);
      } else {
        t1 = Expression.construct(Types.ProdOp, null, [rf.bsq, x]);
        t2 = Expression.construct(Types.ProdOp, null, [rf.b, d]);
        result = Expression.construct(Types.fn, Types.fnLOG,
            [Expression.construct(Types.SumOp, null, [t1, t2])]);
        result = Rational.rational_div(result, rf.b);
      }
    } else {
      t1 = Expression.construct(Types.ProdOp, null, [x, n]);
      t2 = context.radical_form(Rational.rational_div(Types.ONE, n), x);
      if (t2) {
        if (rf.negc0)
          t2 = Expression.diff(t1, Expression.construct(Types.ProdOp, null, [rf.asq, t2]));
        else
          t2 = Expression.sum(t1, Expression.construct(Types.ProdOp, null, [rf.asq, t2]));
        result = Expression.construct(Types.ProdOp, null, [Types.HALF, t2]);
      }
    }

    return Simplify.automatic_simplify(result);
  }

  context.radical_product = function(f, x) {
    f = Rational.rationalise_expression(f);
    var n = Rational.numerator(f);
    if (!Types.isOne(n))
      return null;

    var d = Rational.denominator(f);
    if (!Types.isOpOfType(d, Types.ProdOp) || (Expression.num_operands(d) != 2))
      return null;

    if (Types.isOpOfType(f, Types.PowOp)) {
      u = f;
    }
    var u = Expression.operand(d, 1);
    var v = Expression.operand(d, 2);

    var lin = Polynomial.linear_form(v, x);
    if (!lin) {
      u = Expression.operand(d, 2);
      v = Expression.operand(d, 1);
    }
    lin = Polynomial.linear_form(v, x);
    if (!lin)
      return null;
    var a = lin[0];
    var b = lin[1];

    if (!Types.isOpOfType(u, Types.PowOp))
      return null;

    var base = Expression.operand(u, 1);
    var exponent = Expression.operand(u, 2);

    if (!Expression.equal_expressions(Types.HALF, exponent))
      return null;

    lin = Polynomial.linear_form(base, x);
    if (!lin)
      return null;
    var r = lin[0];
    var s = lin[1];

    if (Types.isZero(a) || Types.isZero(r))
      return null;

    // substitute u
    var t1 = Expression.construct(Types.ProdOp, null,
        [a, Expression.construct(Types.PowOp, null, [context.v, Types.TWO])]);
    var t2 = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, a, s]);
    var t3 = Expression.construct(Types.ProdOp, null, [b, r]);
    var t = Expression.construct(Types.SumOp, null, [t1, t2, t3]);
    t = Rational.rational_div(Types.ONE, t);
    t = Expression.construct(Types.ProdOp, null, [Types.TWO, t]);
    var result = context.integral(Simplify.automatic_simplify(t), context.v);
    if (result) {
      result = Expression.substitute(result, context.v, u);
    }
    return result;
  }

  context.trig_exp_form = function(f, x) {
    var u, v;
    var s, c, e, sh, ch;

    if (Expression.num_operands(f) != 2)
      return null;

    if (!Types.isOpOfType(f, Types.ProdOp))
      return null;

    u = Expression.operand(f, 1);
    v = Expression.operand(f, 2);
    u = Transform.replaceewithexp(u);
    v = Transform.replaceewithexp(v);

    var exparg;
    var trigarg;

    if (Types.isFunctionOfType(u, Types.fnEXP)) {
      e = u;
      exparg = Expression.operand(u, 1);
      trigarg = Expression.operand(v, 1);
    } else if (Types.isFunctionOfType(u, Types.fnSIN))
      s = u;
    else if (Types.isFunctionOfType(u, Types.fnCOS))
      c = u;
    else if (Types.isFunctionOfType(u, Types.fnSINH))
      sh = u;
    else if (Types.isFunctionOfType(u, Types.fnCOSH))
      ch = u;
    else
      return null;

    if (Types.isFunctionOfType(v, Types.fnEXP)) {
      e = v;
      exparg = Expression.operand(v, 1);
      trigarg = Expression.operand(u, 1);
    } else if (Types.isFunctionOfType(v, Types.fnSIN))
      s = v;
    else if (Types.isFunctionOfType(v, Types.fnCOS))
      c = v;
    else if (Types.isFunctionOfType(v, Types.fnSINH))
      sh = v;
    else if (Types.isFunctionOfType(v, Types.fnCOSH))
      ch = v;
    else
      return null;

    if (!e)
      return null;
    if (!s && !c && !sh && !ch)
      return null;

    var lin = Polynomial.linear_form(exparg, x);
    if (!lin)
      return null;
    var a = lin[0];
    if (Types.isZero(a))
      return null;

    lin = Polynomial.linear_form(trigarg, x);
    if (!lin)
      return null;
    var b = lin[0];
    if (Types.isZero(b))
      return null;

    var t1 = Expression.construct(Types.PowOp, null, [a, Types.TWO]);
    var t2 = Expression.construct(Types.PowOp, null, [b, Types.TWO]);
    var asqbsq = sh || ch ? Expression.diff(t1, t2) : Expression.sum(t1, t2);
    var result = Rational.rational_div(Transform.replaceexpwithe(e), asqbsq);

    var alt;
    if (c) {
      alt = Expression.construct(Types.fn, Types.fnSIN, [trigarg]);
      t1 = Expression.sum(Expression.construct(Types.ProdOp, null, [a, c]),
          Expression.construct(Types.ProdOp, null, [b, alt]));
    } else if (s) {
      alt = Expression.construct(Types.fn, Types.fnCOS, [trigarg]);
      t1 = Expression.diff(Expression.construct(Types.ProdOp, null, [a, s]),
          Expression.construct(Types.ProdOp, null, [b, alt]));
    } else if (ch) {
      alt = Expression.construct(Types.fn, Types.fnSINH, [trigarg]);
      t1 = Expression.diff(Expression.construct(Types.ProdOp, null, [a, ch]),
          Expression.construct(Types.ProdOp, null, [b, alt]));
    } else if (sh) {
      alt = Expression.construct(Types.fn, Types.fnCOSH, [trigarg]);
      t1 = Expression.diff(Expression.construct(Types.ProdOp, null, [a, sh]),
          Expression.construct(Types.ProdOp, null, [b, alt]));
    }

    result = Expression.construct(Types.ProdOp, null, [result, t1]);
    return result;
  }

  context.by_parts = function(f, x) {
    var u, v;
    var s, c, e, l, sh, ch;
    var base, n;

    if (Expression.num_operands(f) != 2)
      return null;

    if (!Types.isOpOfType(f, Types.ProdOp))
      return null;

    u = Expression.operand(f, 1);
    v = Expression.operand(f, 2);
    u = Transform.handleexp(u, false);
    v = Transform.handleexp(v, false);

    var base, n;
    if (Types.isOpOfType(u, Types.PowOp)) {
      base = Expression.operand(u, 1);
      n = Expression.operand(u, 2);
      if (!Expression.equal_expressions(base, x))
        return null;
      if (!Types.isPositiveIntegerValue(n))
        return null;
    } else if (Expression.equal_expressions(u, x)) {
      base = u;
      n = Types.ONE;
    }

    var arg = Expression.operand(v, 1);
    var term, alt;

    if (Types.isFunctionOfType(v, Types.fnEXP)) {
      e = v;
      alt = v;
    } else if (Types.isFunctionOfType(v, Types.fnLOG)) {
      l = v;
    } else if (Types.isFunctionOfType(v, Types.fnSIN)) {
      s = v;
      alt = Expression.construct(Types.fn, Types.fnCOS, [arg]);
    } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
      c = v;
      alt = Expression.construct(Types.fn, Types.fnSIN, [arg]);
    } else if (Types.isFunctionOfType(v, Types.fnSINH)) {
      sh = v;
      alt = Expression.construct(Types.fn, Types.fnCOSH, [arg]);
    } else if (Types.isFunctionOfType(v, Types.fnCOSH)) {
      ch = v;
      alt = Expression.construct(Types.fn, Types.fnSINH, [arg]);
    } else
      return null;

    if (!s && !c && !sh && !ch && !e && !l)
      return null;
    if (alt && !s)
      alt = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, alt]);

    var lin = Polynomial.linear_form(arg, x);
    if (!lin)
      return null;
    var a = lin[0];
    if (Types.isZero(a) || (l && !Types.isZero(lin[1])))
      return null;

    var t1, t2, result;
    // LOG is a special case
    if (l) {
      var np1 = Types.asInteger(Types.toInteger(n) + 1);
      t1 = Expression.construct(Types.PowOp, null, [x, np1]);
      t2 = Expression.diff(Expression.construct(Types.ProdOp, null, [np1, l]), Types.ONE);
      t2 = Rational.rational_div(t2, Expression.construct(Types.PowOp, null, [np1, Types.TWO]));
      // return x^(n+1)*((n+1)log(ax)-1)/(n+1)^2
      result = Expression.construct(Types.ProdOp, null, [t1, t2]);
    } else {
      t1 = Expression.construct(Types.ProdOp, null, [Rational.rational_div(u, a), alt]);
      t2 = Expression.construct(Types.PowOp, null, [x, Types.asInteger(Types.toInteger(n) - 1)]);
      t2 = context.integral(Simplify.automatic_simplify(
          Expression.construct(Types.ProdOp, null, [t2, alt])), x);
      if (!t2)
        return null;
      t2 = Expression.construct(Types.ProdOp, null, [Rational.rational_div(n, a), t2]);
      result = Expression.diff(t2, t1);
      result = Transform.handleexp(result, true);
    }

    return Simplify.automatic_simplify(result);
  }

  context.trig_form = function(f, x) {
    var m = 0;
    var n = 0;
    var u, v;

    if (Expression.num_operands(f) != 2)
      return null;

    if (Types.isOpOfType(f, Types.ProdOp)) {
      u = Expression.operand(f, 1);
      v = Expression.operand(f, 2);
      if (!Types.isOpOfType(u, Types.PowOp))
        return null;
      if (!Types.isOpOfType(v, Types.PowOp))
        return null;
    } else if (Types.isOpOfType(f, Types.PowOp)) {
      u = f;
    } else
      return null;

    var ubase = Expression.base(u);
    var uexponent = Expression.exponent(u);
    var vbase = v && Expression.base(v);
    var vexponent = v && Expression.exponent(v);

    if (!Types.isPositiveIntegerValue(uexponent))
      return null;
    if (v && !Types.isPositiveIntegerValue(vexponent))
      return null;

    if (Types.isFunctionOfType(ubase, Types.fnSIN)) {
      if (!Expression.equal_expressions(Expression.operand(ubase, 1), x))
        return null;
      m = Types.toInteger(uexponent);
    } else if (v && Types.isFunctionOfType(vbase, Types.fnSIN)) {
      if (!Expression.equal_expressions(Expression.operand(vbase, 1), x))
        return null;
      m = Types.toInteger(vexponent);
    }

    if (Types.isFunctionOfType(ubase, Types.fnCOS)) {
      if (!Expression.equal_expressions(Expression.operand(ubase, 1), x))
        return null;
      n = Types.toInteger(uexponent);
    } else if (v && Types.isFunctionOfType(vbase, Types.fnCOS)) {
      if (!Expression.equal_expressions(Expression.operand(vbase, 1), x))
        return null;
      n = Types.toInteger(vexponent);
    }

    var result;
    if (m == 0 && n >= 2) {
      var t1 = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCOS, x), Types.asInteger(n - 1)]);
      t1 = Expression.construct(Types.ProdOp, null,
          [t1, Expression.construct(Types.fn, Types.fnSIN, x)]);
      t1 = Expression.construct(Types.ProdOp, null, [Types.asFrac(1, n), t1]);

      var t2 = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCOS, x), Types.asInteger(n - 2)]);
      t2 = context.integral(Simplify.automatic_simplify(t2), x);
      if (!t2)
        return null;
      t2 = Expression.construct(Types.ProdOp, null, [Types.asFrac(n - 1, n), t2]);
      return Simplify.automatic_simplify(Expression.construct(Types.SumOp, null, [t1, t2]));
    } else if (m >= 2) {
      var t1 = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnSIN, x), Types.asInteger(m - 1)]);
      var t2 = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCOS, x), Types.asInteger(n + 1)]);
      t1 = Expression.construct(Types.ProdOp, null, [t1, t2]);
      result = Rational.rational_div(Expression.construct(Types.ProdOp, null,
          [Types.MINUSONE, t1]), Types.asInteger(m + n));

      t1 = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnSIN, x), Types.asInteger(m - 2)]);
      t2 = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCOS, x), Types.asInteger(n)]);
      t2 = Expression.construct(Types.ProdOp, null, [t1, t2]);
      t2 = context.integral(Simplify.automatic_simplify(t2), x);
      if (!t2)
        return null;
      t2 = Expression.construct(Types.ProdOp, null, [Types.asFrac(m - 1, m + n), t2]);

      return Simplify.automatic_simplify(Expression.construct(Types.SumOp, null, [result, t2]));
    }

    return null;
  }

  context.stripconstants = function(f, x) {
    var save = Expression.copy(f);
    f = Expand.algebraic_expand(f);
    if (Types.isOpOfType(f, Types.SumOp)) {
      f.children = f.children.filter(function(e) {
        return !Expression.free_of(e, x);
      });
      if (Expression.countoperators(f) > Expression.countoperators(save))
        f = save;
    } else if (Types.isOpOfType(f, Types.ProdOp) && Expression.num_operands(f) == 2) {
      var p = Expression.operand(f, 1);
      var q = Expression.operand(f, 2);
      if (Expression.free_of(p, x))
        context.stripconstants(q, x);
      else if (Expression.free_of(q, x))
        context.stripconstants(p, x);
      else
        f = save;
    }
    return f;
  }

  context.integral = function(e, x) {
    var f, g;

    e = Transform.contractexp(e);

    f = context.integral_table(e, x);
    if (!f)
      f = context.linear_properties(e, x);
    if (!f)
      f = context.substitution_method(e, x);
    if (!f)
      f = context.rational_form(e, x);
    if (!f)
      f = context.radical_form(e, x);
    if (!f)
      f = context.radical_product(e, x);
    if (!f)
      f = context.trig_form(e, x);
    if (!f)
      f = context.trig_exp_form(e, x);
    if (!f)
      f = context.by_parts(e, x);
    if (!f) {
      g = Expand.algebraic_expand(e);
      if (!Expression.equal_expressions(e, g))
        return context.integral(g, x);
    }
    if (f)
      return context.stripconstants(f, x);
    else if (Rational.is_rational(e)) {
      var pf = Rational.partial_fraction(e, x);
      if (!Expression.equal_expressions(e, Simplify.automatic_simplify(pf)))
        return context.integral(pf, x);
    }
    return Expression.construct(Types.fn, Types.fnI, [e, x]);
  }

  var A = Expression.construct(Types.symbol, 'A', null);
  var B = Expression.construct(Types.symbol, 'B', null);
  var C = Expression.construct(Types.symbol, 'C', null);
  var dydx = Expression.construct(Types.fn, Types.fnD, null);

  context.isODE = function(u) {
    if (Types.isOpOfType(u, Types.Deriv))
      return true;
    else if (Types.isFunctionOfType(u, Types.fnD))
      return true;
    else if (Types.isOperator(u))
      return u.children.some(context.isODE);
    else
      return false;
  }

  context.solve_ode = function(w, x, y) {
    if (!context.isODE(w))
      return w;

    dydx.children = [y, x];
    // w: a differential equation that can be transformed by
    //    rational simplification to the form M + N dy/dx = 0,
    //    where the derivative dy/dx is represented by dydx
    // x,y: symbols
    var v = Rational.rational_expand(Expression.diff(Expression.operand(w, 1), Expression.operand(w, 2)));
    var n = Rational.numerator(v);
    var lin = Polynomial.linear_form(n, dydx);
    if (lin) {
      var M = lin[1];
      var N = lin[0];
      var F = separable_ode(M, N, x, y);
      if (Types.isUndefined(F))
        F = homogeneous(M, N, x, y);
      if (Types.isUndefined(F))
        F = solve_exact(M, N, x, y);
      return F;
    }
    // TODO handle inhomogeneous
    var quad = Polynomial.quadratic_form(n, dydx);
    if (quad) {
      var a = quad[0];
      var b = quad[1];
      var l = Polynomial.linear_form(quad[2], y);
      if (!l)
        return Types.UNDEFINED;
      var c = l[0];
      var f = Expression.prod(Types.MINUSONE, l[1]);	// on RHS
      if (Types.reducesToNumber(a) && Types.reducesToNumber(b) && Types.reducesToNumber(c)) {
        var d = Expression.diff(Expression.prod(b, b),
            Expression.prod(Types.asInteger(4), Expression.prod(a, c)));
        var mb2ax = Expression.prod(Expression.div(Expression.prod(Types.MINUSONE, b),
            Expression.prod(Types.TWO, a)), x);
        var y1, y2;
        if (Types.isZero(d)) {
          y1 = Expression.construct(Types.fn, Types.fnEXP, [mb2ax]);
          y2 = Expression.prod(x, y1);
        } else {
          var val = Expression.numerical_evaluate(d);
          var t1, t2, sqrtd;
          if (Types.isPositiveRealValue(val)) {
            sqrtd = Expression.pow(d, Types.HALF);
            t1 = Expression.prod(Expression.div(
                Expression.diff(Expression.prod(Types.MINUSONE, b), sqrtd),
                Expression.prod(Types.TWO, a)), x);
            t2 = Expression.prod(Expression.div(
                Expression.sum(Expression.prod(Types.MINUSONE, b), sqrtd),
                Expression.prod(Types.TWO, a)), x);
            y1 = Expression.construct(Types.fn, Types.fnEXP, [t2]);
            y2 = Expression.construct(Types.fn, Types.fnEXP, [t1]);
          } else {
            var emb2ax = Expression.construct(Types.fn, Types.fnEXP, [mb2ax]);
            sqrtd = Expression.pow(Expression.prod(Types.MINUSONE, d), Types.HALF);
            t1 = Expression.prod(Expression.div(sqrtd, Expression.prod(Types.TWO, a)), x);
            y1 = Expression.prod(emb2ax, Expression.construct(Types.fn, Types.fnCOS, [t1]));
            y2 = Expression.prod(emb2ax, Expression.construct(Types.fn, Types.fnSIN, [t1]));
          }
        }
        var hs = Expression.sum(Expression.prod(A, y1), Expression.prod(B, y2));
        if (Types.isZero(f))
          return equate(y, hs);
        // variation of parameters
        // f is a function of x
        var y1p = context.derivative(y1, x);
        var y2p = context.derivative(y2, x);
        var faW = Expression.div(f, Expression.prod(a, Expression.diff(Expression.prod(y1, y2p),
            Expression.prod(y2, y1p))));
        var v1 = context.integral(simplifyspecial(Expression.prod(y2, Expression.prod(Types.MINUSONE, faW))), x);
        var v2 = context.integral(simplifyspecial(Expression.prod(y1, faW)), x);
        var yp = rationalsimplify(Expression.sum(Expression.prod(y1, v1), Expression.prod(y2, v2)));
        return equate(y, Expression.sum(hs, yp));
      }
    }

    return Types.UNDEFINED;
  }

  var rationalsimplify = function(u) {
    if (Types.reducesToNumber(u)) {
      return Simplify.automatic_simplify(Transform.simplifyall(u));
    } else {
      return Rational.rational_simplify(u);
    }
  }

  var expandspecial = function(u) {
    return Simplify.automatic_simplify(Transform.expandspecial(Simplify.automatic_simplify(u)));
  }

  var simplifyspecial = function(u) {
    return Simplify.automatic_simplify(Transform.simplifyspecial(Simplify.automatic_simplify(u)));
  }

  var equate = function(a, b) {
    return Expression.construct(Types.Equate, null,
        [Simplify.automatic_simplify(a), Simplify.automatic_simplify(b)]);
  }

  var separate_variables = function(a, x, y) {
    if (!Array.isArray(a))
      a = [a];

    var xfun = Types.ONE;
    var yfun = Types.ONE;
    for (var i = 0; i < a.length; ++i) {
      var op = a[i];
      if (Expression.free_of(op, y))
        xfun = Expression.prod(xfun, op);
      else if (Expression.free_of(op, x))
        yfun = Expression.prod(yfun, op);
      else
        return Types.UNDEFINED;
    }

    return [xfun, yfun];
  }

  var separable_ode = function(M, N, x, y) {
    var u = Rational.rational_div(Expression.prod(Types.MINUSONE, M), N);
    var v = Rational.rational_factorise(u, x, x);
    var sep = Types.UNDEFINED;
    if (Types.isOpOfType(v, Types.ProdOp) || Expression.isLeafNode(v)) {
      sep = separate_variables(v.children ? v.children : v, x, y);
    }
    if (!Types.isUndefined(sep)) {
      var t1 = context.integral(simplifyspecial(Expression.pow(sep[1], Types.MINUSONE)), y);
      var t2 = context.integral(simplifyspecial(sep[0]), x);
      if (!Types.isUndefined(t1) && !Types.isUndefined(t2)) {
        return rearrange(equate(t1, t2), y, C);
      }
    }
    return Types.UNDEFINED;
  }

  var homogeneous = function(M, N, x, y) {
    var f = Rational.rational_expand(Rational.rational_div(
        Expression.prod(Types.MINUSONE, M), N));
    var z = Expression.construct(Types.symbol, 'z', null);
    var r = Simplify.automatic_simplify(Rational.rational_expand(
        Expression.substitute(f, y, Expression.prod(z, x))));
    var result = Types.UNDEFINED;
    if (Expression.free_of(r, x)) {
      var t1 = context.integral(Expression.pow(Expression.diff(r, z), Types.MINUSONE), z);
      if (!Types.isUndefined(t1)) {
        var t2 = Expression.construct(Types.fn, Types.fnLOG, [x]);
        result = equate(t1, t2);
// 				result = rearrange(result, z, C);
        result = Simplify.automatic_simplify(Rational.rational_expand(
            Expression.substitute(result, z, Expression.div(y, x))));
        result = rearrange(result, y, C);
      }
    }
    return result;
  }

  var solve_exact = function(M, N, x, y) {
    // M, N: algebraic expressions
    // x, y: symbols
    var u;

    if (Types.isZero(N))
      return Types.UNDEFINED;
    else if (Types.isZero(M))
      return equate(y, C);

    var My = context.derivative(M, y);
    var Nx = context.derivative(N, x);
    var d = Expression.diff(My, Nx);
    if (Types.isZero(d))
      u = Types.ONE;
    else {
      var F = Rational.rational_expand(Rational.rational_div(d, N));
      if (Expression.free_of(F, y)) {
        u = expandspecial(Expression.construct(Types.fn, Types.fnEXP, context.integral(F, x)));
        d = Types.ZERO;
      } else {
        var G = Rational.rational_expand(Rational.rational_div(
            Expression.prod(Types.MINUSONE, d), M));
        if (Expression.free_of(G, x)) {
          u = expandspecial(Expression.construct(Types.fn, Types.fnEXP, context.integral(G, y)));
          d = Types.ZERO;
        }
      }
      if (!Types.isZero(d)) {
        var R = Rational.rational_div(d, Expression.diff(Expression.prod(N, y), Expression.prod(M, x)));
        var z = Expression.construct(Types.symbol, 'z', null);
        var S = Simplify.automatic_simplify(Expression.substitute(R, x, Expression.div(z, y)));
        if (Expression.free_of(S, y)) {
          var I = context.integral(S, z);
          I = Expression.substitute(I, z, Expression.prod(x, y));
          u = expandspecial(Expression.construct(Types.fn, Types.fnEXP, I));
          d = Types.ZERO;
        }
      }
    }
    if (Types.isZero(d)) {
      var g = context.integral(Expression.prod(u, M), x);
      var hp = Expression.diff(Expression.prod(u, N), context.derivative(g, y));
      var h = context.integral(hp, y);
      var s = Expression.sum(g, h);
      s = Simplify.factor_out(Transform.simplifyexp(s));
      return rearrange(equate(s, C), y, null);
    }

    return Types.UNDEFINED;
  }

  var rearrange = function(w, y, c) {
    return Solve.rearrange(w, y, c);
  }
})(Calculus);


var Complex = {};

(function(context) {
  context.setupComplex = function() {
    var ensureComplex = function(c) {
      if (Types.isI(c))
        return context.i;

      var craw = Types.toComplex(c);
      return Types.asComplex(craw.r, craw.i);
    };

    var make = function(re, im) {
      if (Types.isZero(im)) {
        return re;
      } else if (Types.isGeneralisedNumber(re) && Types.isGeneralisedNumber(im))
        return Types.asComplex(re, im);
      else
        return Expression.sum(re, Expression.prod(Types.I, im));
    }

    var makeFn = function(fn, arg) {
      return Expression.construct(Types.fn, fn, [arg]);
    }

    var r = function(c) {
      return c.value.r;
    };

    var i = function(c) {
      return c.value.i;
    };

    // complex parts need to be mpl types
    context.init = function(r, i) {
      return {r: r, i: i};
    },

        context.initConstants = function() {
          context.i = Types.asComplex(Types.ZERO, Types.ONE);
        },

        // (a+ib)-(c+id) = (a-c)+i(b-c)
        context.add = function(x, y) {
          x = ensureComplex(x);
          y = ensureComplex(y);
          return make(Expression.sum(r(x), r(y)), Expression.sum(i(x), i(y)));
        }

    // (a+ib)+(c+id) = (a+c)+i(b+c)
    context.sub = function(x, y) {
      x = ensureComplex(x);
      y = ensureComplex(y);
      return make(Expression.diff(r(x), r(y)), Expression.diff(i(x), i(y)));
    }

    // (a+ib).(c+id) = (ac-bd)+i(ad+bc)
    context.mul = function(x, y) {
      x = ensureComplex(x);
      y = ensureComplex(y);
      return make(
          Expression.diff(Expression.prod(r(x), r(y)), Expression.prod(i(x), i(y))),
          Expression.sum(Expression.prod(r(x), i(y)), Expression.prod(i(x), r(y)))
      );
    }

    // (a+ib)/(c+id) = ((ac+bd)+i(bc-ad))/(c^2+d^2)
    context.div = function(x, y) {
      x = ensureComplex(x);
      y = ensureComplex(y);
      var d = Expression.sum(Expression.pow(r(y), Types.TWO), Expression.pow(i(y), Types.TWO));
      return make(
          Expression.div(Expression.sum(Expression.prod(r(x), r(y)), Expression.prod(i(x), i(y))), d),
          Expression.div(Expression.diff(Expression.prod(i(x), r(y)), Expression.prod(r(x), i(y))), d)
      );
    }

    context.abs = function(x) {
      x = ensureComplex(x);
      return Expression.pow(Expression.sum(Expression.pow(r(x), Types.TWO),
          Expression.pow(i(x), Types.TWO)), Types.HALF);
    }

    context.arg = function(x) {
      x = ensureComplex(x);
      var a = Expression.numerical_evaluate(r(x));
      var b = Expression.numerical_evaluate(i(x));

      if (Types.isPositiveRealValue(a)) {
        return makeFn(Types.fnATAN, Expression.div(b, a));
      } else if (Types.isNegativeRealValue(a)) {
        if (Types.isNegativeRealValue(b))
          return Expression.diff(makeFn(Types.fnATAN, Expression.div(b, a)), Types.PI);
        else
          return Expression.sum(Types.PI, makeFn(Types.fnATAN, Expression.div(b, a)));
      } else {
        if (Types.isZero(b))
          return Types.UNDEFINED;
        else
          return Types.isPositiveRealValue(b) ? Expression.prod(Types.PI, Types.HALF) :
              Expression.prodAll(Types.PI, Types.HALF, Types.MINUSONE);
      }
    }

    context.equals = function(z, w) {
      if (Types.isComplex(z) && Types.isComplex(w)) {
        return Expression.equal_expressions(context.re(z), context.re(w))
            && Expression.equal_expressions(context.im(z), context.im(w));
      }
      return false;
    }

    context.complex_pow = function(a, z, force) {
      var x = context.re(z);
      var y = context.im(z);
      var absa = context.abs(a);
      if (Types.isZero(absa))
        return Types.ZERO;
      var arga = context.arg(a);
      // only let exact values through
      if (!force && Types.isFunctionOfType(arga, Types.fnATAN))
        return Expression.makenode(Types.PowOp, null, [a, z]);
      var r = Expression.pow(absa, x);
      var theta = Expression.prod(x, arga);
      if (!Types.isZero(y)) {
        r = Expression.prod(r, makeFn(Types.fnEXP, Expression.prod(Expression.neg(y), arga)));
        theta = Expression.sum(theta, Expression.prod(y, makeFn(Types.fnLOG, absa)));
      }
      var w = make(
          Expression.prod(r, makeFn(Types.fnCOS, theta)),
          Expression.prod(r, makeFn(Types.fnSIN, theta))
      );
      return w;
    }

    context.int_pow = function(x, n) {
      if (!Types.isInteger(n))
        return context.complex_pow(x, n);
      var result = Types.ONE;
      var nint = Types.toInteger(n);
      if (KBI.isNegative(nint)) {
        nint = KBI.negate(nint);
        x = context.div(Types.ONE, x);
      }
      while (!KBI.isZero(nint)) {
        if (KBI.isOdd(nint))
          result = context.mul(result, x);
        x = context.mul(x, x);
        nint = KBI.shiftRight(nint, 1);
      }
      return result;
    }

    context.pow = function(x, n, forcenumeric, forceexpand) {
      var p = internalpow(x, n, forceexpand);
      if (forcenumeric)
        return Expression.evaluate_node(p);
      else
        return p;
    }

    var internalpow = function(x, n, forceexpand) {
      x = ensureComplex(x);
      if (Types.isZero(n))
        return Types.ONE;
      else if (Types.isOne(n))
        return x;
      else if (Types.isMinusOne(n))
        return context.div(ensureComplex(Types.ONE), x);
      else if (Types.isInteger(n))
        return context.int_pow(x, n);
      else if (Types.isComplex(n))
        return context.complex_pow(x, n, forceexpand);
      else if (Types.isZero(r(x))) {
        var pow = Expression.pow(i(x), n);
        if (Types.isInteger(n)) {
          var nint = Types.toInteger(n) % 4;
          if (nint < 0)
            nint += 4;
          switch (nint) {
            case 0:
              return make(pow, Types.ZERO);
            case 1:
              return make(Types.ZERO, pow);
            case 2:
              return make(Expression.neg(pow), Types.ZERO);
            case 3:
              return make(Types.ZERO, Expression.neg(pow));
          }
        }
      } else if (!forceexpand && Types.isComplex(x) && Types.isRationalValue(n)) {
        var a = context.re(x);
        var b = context.im(x);
        if (Types.isInteger(a) && Types.isInteger(b) && !Types.isZero(a) && !Types.isZero(b)) {
          var rint = Types.toInteger(a);
          var iint = Types.toInteger(b);
          var gcd = KBI.gcd(rint, iint);
          if (!KBI.isOne(gcd)) {
            gcd = Types.asInteger(gcd);
            return Expression.makenode(Types.ProdOp, null, [
              Expression.pow(gcd, n),
              Expression.makenode(Types.PowOp, null, [Complex.div(x, gcd), n])]);
          }
        }
        return Expression.makenode(Types.PowOp, null, [x, n]);
      }

      // (a+ib)^n = r^n(cos n.th + i sin n.th)
      var rn = Expression.pow(context.abs(x), n);
      var thn = Expression.prod(context.arg(x), n);
      return make(
          Expression.prod(rn, makeFn(Types.fnCOS, thn)),
          Expression.prod(rn, makeFn(Types.fnSIN, thn))
      );
    }

    context.round = function(z, n) {
      var a = context.re(z);
      var b = context.im(z);
      return make(
          Eval.functions[Types.fnROUND].eval(a, n),
          Eval.functions[Types.fnROUND].eval(b, n)
      );
    }

    context.dec = function(z, n) {
      var a = context.re(z);
      var b = context.im(z);
      return make(
          Eval.functions[Types.fnDEC].eval(a),
          Eval.functions[Types.fnDEC].eval(b)
      );
    }

    context.conjugate = function(x) {
      x = ensureComplex(x);
      return make(r(x), Eval.neg(i(x)));
    }

    var printterm = function(t) {
      if (Types.isOpOfType(t, Types.SumOp))
        return "(" + Expression.printInfix(t) + ")";
      else
        return Expression.printInfix(t);
    }

    context.numToString = function(c) {
      c = ensureComplex(c);
      var re = r(c);
      var im = i(c);

      if (Types.isZero(im))
        return Expression.printInfix(re);
      else if (Types.isZero(re)) {
        if (Types.isOne(im))
          return "i";
        else if (Types.isMinusOne(im))
          return "-1*i";
        else
          return printterm(im) + "*i";
      } else if (Types.isOne(im))
        return Expression.printInfix(re) + " + i";
      else if (Types.isMinusOne(im))
        return Expression.printInfix(re) + " - i";
      else
        return Expression.printInfix(re) + " + " + printterm(im) + "*i";
    }

    context.sciString = function(x) {
      return Eval.functions[Types.fnSCI].eval(r(x)).value + " + " +
          Eval.functions[Types.fnSCI].eval(i(x)).value + "i";
    }

    context.re = function(c) {
      return r(ensureComplex(c));
    }

    context.im = function(c) {
      return i(ensureComplex(c));
    }

    // make a + bi
    context.split = function(z) {
      if (Types.isComplex(z))
        return {a: context.re(z), b: context.im(z)};
      else if (!Types.isNumber(z)) {
        var parts = Polynomial.linear_form(z, Types.I);
        if (parts)
          return {a: parts[1], b: parts[0]};
      }
      return {a: z, b: Types.ZERO};
    }

    context.cis = function(x) {
      var cosx = makeFn(Types.fnCOS, x);
      var sinx = makeFn(Types.fnSIN, x);
      return make(cosx, sinx);
    }

    // transforms of standard functions for complex argument
    // TODO integrate with standard transforms (or maybe make a special case?)

    context.log = function(z) {
      var {a, b} = context.split(z);

      var r = context.abs(z);
      var th = context.arg(z);

      return make(makeFn(Types.fnLOG, r), th);
    }

    context.exp = function(z) {
      var {a, b} = context.split(z);
      return Expression.prod(Expression.pow(Types.E, a), context.cis(b));
    }

    context.sin = function(z) {
      var {a, b} = context.split(z);
      return make(
          Expression.prod(makeFn(Types.fnSIN, a), makeFn(Types.fnCOSH, b)),
          Expression.prod(makeFn(Types.fnCOS, a), makeFn(Types.fnSINH, b)));
    }

    context.cos = function(z) {
      var {a, b} = context.split(z);
      return make(
          Expression.prod(makeFn(Types.fnCOS, a), makeFn(Types.fnCOSH, b)),
          Expression.neg(Expression.prod(makeFn(Types.fnSIN, a), makeFn(Types.fnSINH, b))));
    }

    context.tan = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.sum(makeFn(Types.fnCOS, a2), makeFn(Types.fnCOSH, b2));
      return Expression.prod(Expression.inv(d), make(
          makeFn(Types.fnSIN, a2), makeFn(Types.fnSINH, b2)));
    }

    context.sec = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.sum(makeFn(Types.fnCOS, a2), makeFn(Types.fnCOSH, b2));
      return Expression.prod(Expression.inv(d), make(
          Expression.prodAll([makeFn(Types.fnCOS, a), makeFn(Types.fnCOSH, b), Types.TWO]),
          Expression.prodAll([makeFn(Types.fnSIN, a), makeFn(Types.fnSINH, b), Types.TWO])
      ));
    }

    context.cosec = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.diff(makeFn(Types.fnCOS, a2), makeFn(Types.fnCOSH, b2));
      return Expression.prod(Expression.inv(d), make(
          Expression.prodAll([makeFn(Types.fnSIN, a), makeFn(Types.fnCOSH, b), Types.TWO, Types.MINUSONE]),
          Expression.prodAll([makeFn(Types.fnCOS, a), makeFn(Types.fnSINH, b), Types.TWO])
      ));
    }

    context.cot = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.diff(makeFn(Types.fnCOS, a2), makeFn(Types.fnCOSH, b2));
      return Expression.prod(Expression.inv(d), make(
          Expression.neg(makeFn(Types.fnSIN, a2)), makeFn(Types.fnSINH, b2))
      );
    }

    context.sinh = function(z) {
      var {a, b} = context.split(z);
      return make(
          Expression.prod(makeFn(Types.fnSINH, a), makeFn(Types.fnCOS, b)),
          Expression.prod(makeFn(Types.fnCOSH, a), makeFn(Types.fnSIN, b)));
    }

    context.cosh = function(z) {
      var {a, b} = context.split(z);
      return make(
          Expression.prod(makeFn(Types.fnCOSH, a), makeFn(Types.fnCOS, b)),
          Expression.prod(makeFn(Types.fnSINH, a), makeFn(Types.fnSIN, b)));
    }

    context.tanh = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.sum(makeFn(Types.fnCOSH, a2), makeFn(Types.fnCOS, b2));
      return Expression.prod(Expression.inv(d), make(
          makeFn(Types.fnSINH, a2), makeFn(Types.fnSIN, b2)));
    }

    context.sech = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.sum(makeFn(Types.fnCOSH, a2), makeFn(Types.fnCOS, b2));
      return Expression.prod(Expression.inv(d), make(
          Expression.prodAll([makeFn(Types.fnCOSH, a), makeFn(Types.fnCOS, b), Types.TWO]),
          Expression.prodAll([makeFn(Types.fnSINH, a), makeFn(Types.fnSIN, b), Types.TWO, Types.MINUSONE])
      ));
    }

    context.cosech = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.diff(makeFn(Types.fnCOS, b2), makeFn(Types.fnCOSH, a2));
      return Expression.prod(Expression.inv(d), make(
          Expression.prodAll([makeFn(Types.fnSINH, a), makeFn(Types.fnCOS, b), Types.TWO, Types.MINUSONE]),
          Expression.prodAll([makeFn(Types.fnCOSH, a), makeFn(Types.fnSIN, b), Types.TWO])
      ));
    }

    context.coth = function(z) {
      var {a, b} = context.split(z);
      var a2 = Expression.prod(Types.TWO, a);
      var b2 = Expression.prod(Types.TWO, b);
      var d = Expression.diff(makeFn(Types.fnCOS, b2), makeFn(Types.fnCOSH, a2));
      return Expression.prod(Expression.inv(d), make(
          Expression.neg(makeFn(Types.fnSINH, a2)), makeFn(Types.fnSIN, b2))
      );
    }

    context.asin = function(z) {
      // -i log(iz+sqrt(1-z^2))
      var arg = Expression.diff(Types.ONE, Expression.pow(z, Types.TWO));
      var result = Expression.sum(Expression.prod(Types.I, z), Expression.pow(arg, Types.HALF));
      return Expression.prodAll([Types.I, makeFn(Types.fnLOG, result), Types.MINUSONE]);
    }

    context.acos = function(z) {
      // -i log(z+sqrt(z^2-1))
      var arg = Expression.diff(Expression.pow(z, Types.TWO), Types.ONE);
      var result = Expression.sum(z, Expression.pow(arg, Types.HALF));
      return Expression.prodAll([Types.I, makeFn(Types.fnLOG, result), Types.MINUSONE]);
    }

    context.atan = function(z) {
      // i/2 (log(1-iz)-log(1+iz))
      var arg1 = Expression.diff(Types.ONE, Expression.prod(Types.I, z));
      var arg2 = Expression.sum(Types.ONE, Expression.prod(Types.I, z));
      var diff = Expression.diff(makeFn(Types.fnLOG, arg1), makeFn(Types.fnLOG, arg2));
      return Expression.prodAll([Types.I, Types.HALF, diff]);
    }

    context.asinh = function(z) {
      // log(z+sqrt(z^2+1))
      var arg = Expression.sum(Expression.pow(z, Types.TWO), Types.ONE);
      var result = Expression.sum(z, Expression.pow(arg, Types.HALF));
      return makeFn(Types.fnLOG, result);
    }

    context.acosh = function(z) {
      // log(z+sqrt(z^2-1))
      var arg = Expression.diff(Expression.pow(z, Types.TWO), Types.ONE);
      var result = Expression.sum(z, Expression.pow(arg, Types.HALF));
      return makeFn(Types.fnLOG, result);
    }

    context.atanh = function(z) {
      // log((1+z)/(1-z))/2
      var t1 = Expression.diff(Types.ONE, Expression.prod(Types.I, z));
      var t2 = Expression.sum(Types.ONE, Expression.prod(Types.I, z));
      var rat = makeFn(Types.fnLOG, Expression.div(t1, t2));
      return Expression.prod(rat, Types.HALF);
    }

    context.initConstants();
  }
})(Complex);


var Config = {};

(function(context) {
  context.naivePower = true;

  context.naiveLog = true;

  context.supportComplex = true;

  context.maxdenom = 100000000;

  context.tolerance = 1e-13;

  context.digits = Math.round(Math.log10(1 / context.tolerance)) - 1; // 12

  context.tolequals = function(a, b) {
    return Math.abs(a - b) < context.tolerance;
  }

  context.start = null;
  context.interrupted = false;
  context.pending = false;
  context.timelimit = 4000;
  context.deftimelimit = 4000;

  context.startTimeCheck = function() {
    context.start = Date.now();
    context.timelimit = context.deftimelimit;
    context.interrupted = false;
    context.pending = false;
  }

  context.checkTimeout = function() {
    if (context.deftimelimit == 0) return;
    if (!context.pending && context.start && (Date.now() - context.start > context.timelimit)) {
      if (!confirm("The calculation is taking a long time.  Hit OK to continue, else Cancel.")) context.cancel();
      else context.keepgoing();
    }
    return context.interrupted;
  }

  context.cancel = function() {
    context.start = null;
    context.interrupted = true;
    context.pending = false;
  }

  context.keepgoing = function() {
    context.timelimit *= 2;
    context.start = Date.now();
    context.pending = false;
  }
})(Config);


var Eval = {};

(function(context) {
  context.ops = [];
  context.functions = [];

  var isinteger = AvantiUtils.isinteger;
  var rand = AvantiUtils.randKISS();

  context.setupEval = function() {
    // calculate a^(n/d) where n/d is b
    function fracpow(a, b) {
      var result;
      if (b.value.d == 1)
        result = Types.asInteger(KBI.pow(a.value, b.value.n));
      else if (b.value.n > 0)
        result = Expression.makenode(Types.PowOp, null, [a, b]);
      else
        result = Expression.makenode(Types.PowOp, null,
            [Types.asFrac(1, Types.toInteger(a)), Types.asFrac(-b.value.n, b.value.d)]);
      return result;
    }

    this.ops[Types.FactOp] = {
      eval: function(n) {
        if (Array.isArray(n)) {
          if (n.length == 1)
            return context.ops[Types.FactOp].eval(n[0]);
          else
            return Types.UNDEFINED;
        }

        if (Types.isUndefined(n) || Types.isComplex(n))
          return Types.UNDEFINED;

        if (Types.isInteger(n))
          return Types.asInteger(KBI.factorial(n.value));
        else
          return Types.asReal(context.factorial(Types.toRealValue(n)));
      }
    };

    this.ops[Types.PowOp] = {
      eval: function(a, b, forcereal, complexpowexpand) {
        if (Array.isArray(a)) {
          if (a.length == 2 && !b)
            return context.ops[Types.PowOp].eval(a[0], a[1], forcereal, complexpowexpand);
          else
            return Types.UNDEFINED;
        }

        if (complexpowexpand === undefined)
          complexpowexpand = forcereal;

        if (Types.isUndefined(a) || Types.isUndefined(b))
          return Types.UNDEFINED;

        if (Types.isComplex(a) || Types.isComplex(b))
          return Complex.pow(a, b, forcereal, complexpowexpand);

        if (forcereal) {
          if (Types.toRealValue(a) < 0 && Types.isFraction(b))
            return Complex.pow(Complex.dec(a), Complex.dec(b), forcereal, complexpowexpand);
          else
            return Types.asReal(context.power(Types.toRealValue(a), Types.toRealValue(b)));
        }
        if (Types.isInteger(a)) {
          if (Types.isInteger(b))  // a^b
          {
            if (KBI.isZero(b.value) || KBI.isOne(a.value))
              return Types.ONE;
            else if (KBI.isZero(a.value))
              return Types.isPositiveIntegerValue(b) ? Types.ZERO : Types.UNDEFINED;
            var pow = KBI.pow(a.value, KBI.abs(b.value));
            if (KBI.isNegative(b.value))
              return Types.asFrac(1, pow);
            else
              return Types.asInteger(pow);
          } else if (Types.isFraction(b)) // a^(m/n)
          {
            if (KBR.isZero(b.value) || KBI.isOne(a.value))
              return Types.ONE;
            else if (KBI.isZero(a.value))
              return Types.isPositiveRationalValue(b) ? Types.ZERO : Types.UNDEFINED;
            else if (Types.isNegativeIntegerValue(a))
              return Complex.pow(a, b, forcereal, complexpowexpand);
            return fracpow(a, b);
          } else
            return Types.asReal(context.power(Types.toRealValue(a), Types.toRealValue(b)));
        } else if (Types.isFraction(a) && Types.isInteger(b)) {
          if (KBI.isZero(b.value) || KBR.isOne(a.value))
            return Types.ONE;
          else if (KBR.isZero(a.value))
            return Types.ZERO;
          var pow = Types.toInteger(b);
          if (pow > 0)
            return Types.asFrac(context.power(a.value.n, b.value), context.power(a.value.d, b.value));
          else
            return Types.asFrac(context.power(a.value.d, -b.value), context.power(a.value.n, -b.value));
        } else if (Types.isFraction(a) && Types.isFraction(b)) {
          var n = fracpow(Types.asInteger(a.value.n), b);
          var d = fracpow(Types.asInteger(a.value.d), b);
          if (Types.isInteger(n)) {
            if (Types.isInteger(d))
              return Types.asFrac(n.value, d.value);
            else
              return Expression.makenode(Types.QuotOp, null, [n, d]);
          } else {
            if (b.value.n > 0)
              return Expression.makenode(Types.PowOp, null, [a, b]);
            else {
              b.value.n = -b.value.n;
              return Expression.makenode(Types.PowOp, null,
                  [Types.asFrac(a.value.d, a.value.n), b]);
            }
          }
        } else if (Types.reducesToComplex(a) || Types.reducesToComplex(b)) {
          return Complex.pow(Complex.dec(a), Complex.dec(b), forcereal, complexpowexpand);
        } else
          return Types.asReal(context.power(Types.toRealValue(a), Types.toRealValue(b)));
      }
    };

    this.ops[Types.ProdOp] = {
      eval: function(a, b) {
        if (Array.isArray(a) && !b) {
          return a.reduce(context.ops[Types.ProdOp].eval);
        }

        if (Types.isUndefined(a) || Types.isUndefined(b))
          return Types.UNDEFINED;

        if (Types.isComplex(a) || Types.isComplex(b))
          return Complex.mul(a, b);

        if (Types.isInteger(a)) {
          if (Types.isInteger(b))
            return Types.asInteger(KBI.mul(a.value, b.value));
          else if (Types.isFraction(b))
            return Types.asFrac(KBR.mul(a.value, b.value));
          else
            return Types.asReal(Types.toRealValue(a) * Types.toRealValue(b));
        } else if (Types.isFraction(a)) {
          if (Types.isInteger(b))
            return Types.asFrac(KBI.mul(a.value.n, b.value), a.value.d);
          else if (Types.isFraction(b))
            return Types.asFrac(KBR.mul(a.value, b.value));
          else
            return Types.asReal(KBI.toDecimal(a.value.n) / KBI.toDecimal(a.value.d) * Types.toRealValue(b));
        } else if (Types.reducesToComplex(a) || Types.reducesToComplex(b))
          return Complex.mul(Complex.dec(a), Complex.dec(b));

        return Types.asReal(Types.toRealValue(a) * Types.toRealValue(b));
      }
    };

    this.ops[Types.ModOp] = {
      eval: function(a, b) {
        if (Array.isArray(a) && !b) {
          if (a.length == 2)
            return context.ops[Types.ModOp].eval(a[0], a[1]);
          else
            return Types.UNDEFINED;
        }

        if (Types.isComplex(a) || Types.isComplex(b))
          return Types.UNDEFINED;

        if (Types.isInteger(a) && Types.isInteger(b))
          return Types.modInteger(a, b);

        var quot = Types.asInteger(Types.toInteger(context.ops[Types.QuotOp].eval(a, b)));
        if (Types.isUndefined(quot))
          return Types.UNDEFINED;
        else // m-n Quotient[m,n]
          return Expression.diff(a, Expression.prod(b, quot));
      }
    };

    this.ops[Types.QuotOp] = {
      eval: function(a, b) {
        if (Array.isArray(a) && !b) {
          if (a.length == 2)
            return context.ops[Types.QuotOp].eval(a[0], a[1]);
          else
            return Types.UNDEFINED;
        }

        if (Types.isUndefined(a) || Types.isUndefined(b))
          return Types.UNDEFINED;

        if (Types.isComplex(a) || Types.isComplex(b))
          return Complex.div(a, b);

        if (Types.isZero(b))
          return Types.UNDEFINED;
        else if (Types.isUndefined(a) || Types.isUndefined(b))
          return Types.UNDEFINED;
        else if (Types.isInteger(a)) {
          if (Types.isInteger(b))
            return Types.asFrac(a.value, b.value);
          else if (Types.isFraction(b))
            return Types.asFrac(KBR.div(a.value, b.value));
        } else if (Types.isFraction(a)) {
          if (Types.isInteger(b) || Types.isFraction(b))
            return Types.asFrac(KBR.div(a.value, b.value));
        } else if (Types.reducesToComplex(a) || Types.reducesToComplex(b))
          return Complex.div(Complex.dec(a), Complex.dec(b));

        return Types.asReal(Types.toRealValue(a) / Types.toRealValue(b));
      }
    };

    this.ops[Types.SumOp] = {
      eval: function(a, b) {
        if (Array.isArray(a) && !b) {
          return a.reduce(context.ops[Types.SumOp].eval);
        }

        if (Types.isUndefined(a) || Types.isUndefined(b))
          return Types.UNDEFINED;

        if (Types.isComplex(a) || Types.isComplex(b))
          return Complex.add(a, b);

        if (Types.isInteger(a)) {
          if (Types.isInteger(b))
            return Types.asInteger(KBI.add(a.value, b.value));
          else if (Types.isFraction(b))
            return Types.asFrac(KBR.add(a.value, b.value));
          else
            return Types.asReal(Types.toRealValue(a) + Types.toRealValue(b));
        } else if (Types.isFraction(a)) {
          if (Types.isInteger(b) || Types.isFraction(b))
            return Types.asFrac(KBR.add(a.value, b.value));
          else
            return Types.asReal(KBR.toDecimal(a.value) + Types.toRealValue(b));
        } else if (Types.reducesToComplex(a) || Types.reducesToComplex(b))
          return Complex.add(Complex.dec(a), Complex.dec(b));
        else
          return Types.asReal(Types.toRealValue(a) + Types.toRealValue(b));
      }
    };

    this.ops[Types.DiffOp] = {
      eval: function(a, b) {
        if (Array.isArray(a) && !b) {
          if (a.length == 2)
            return context.ops[Types.DiffOp].eval(a[0], a[1]);
          else
            return Types.UNDEFINED;
        }

        if (Types.isUndefined(a) || Types.isUndefined(b))
          return Types.UNDEFINED;

        if (Types.isComplex(a) || Types.isComplex(b))
          return Complex.sub(a, b);

        if (Types.isInteger(a)) {
          if (Types.isInteger(b))
            return Types.asInteger(KBI.sub(a.value, b.value));
          else if (Types.isFraction(b))
            return Types.asFrac(KBR.sub(a.value, b.value));
        } else if (Types.isFraction(a)) {
          if (Types.isInteger(b) || Types.isFraction(b))
            return Types.asFrac(KBR.sub(a.value, b.value));
        } else if (Types.reducesToComplex(a) || Types.reducesToComplex(b))
          return Complex.sub(Complex.dec(a), Complex.dec(b));
        else
          return Types.asReal(KBI.sub(a.value, b.value));
      }
    };

    var trycomplex = function(x, fn) {
      if (Types.isComplex(x)) {
        var c = fn(x);
        return Types.asComplex(Expression.numerical_evaluate(Complex.re(c)), Expression.numerical_evaluate(Complex.im(c)));
      } else
        null;
    }

    context.functions[Types.fnEXP] = {
      eval: function(x) {
        return trycomplex(x, Complex.exp) || Types.asReal(Math.exp(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnSIN] = {
      eval: function(x) {
        return trycomplex(x, Complex.sin) || Types.asReal(Math.sin(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnCOS] = {
      eval: function(x) {
        return trycomplex(x, Complex.cos) || Types.asReal(Math.cos(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnTAN] = {
      eval: function(x) {
        return trycomplex(x, Complex.tan) || Types.asReal(Math.tan(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnCSC] = {
      eval: function(x) {
        return trycomplex(x, Complex.cosec) || Types.asReal(1.0 / Math.sin(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnSEC] = {
      eval: function(x) {
        return trycomplex(x, Complex.sec) || Types.asReal(1.0 / Math.cos(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnCOT] = {
      eval: function(x) {
        return trycomplex(x, Complex.cot) || Types.asReal(1.0 / Math.tan(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnASIN] = {
      eval: function(x) {
        return trycomplex(x, Complex.asin) || Types.asReal(Math.asin(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnACOS] = {
      eval: function(x) {
        return trycomplex(x, Complex.acos) || Types.asReal(Math.acos(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnATAN] = {
      eval: function(x) {
        return trycomplex(x, Complex.atan) || Types.asReal(Math.atan(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnSINH] = {
      eval: function(x) {
        return trycomplex(x, Complex.sinh) || Types.asReal(Math.sinh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnCOSH] = {
      eval: function(x) {
        return trycomplex(x, Complex.cosh) || Types.asReal(Math.cosh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnTANH] = {
      eval: function(x) {
        return trycomplex(x, Complex.tanh) || Types.asReal(Math.tanh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnASINH] = {
      eval: function(x) {
        return trycomplex(x, Complex.asinh) || Types.asReal(Math.arcsinh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnACOSH] = {
      eval: function(x) {
        return trycomplex(x, Complex.acosh) || Types.asReal(Math.arccosh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnATANH] = {
      eval: function(x) {
        return trycomplex(x, Complex.atanh) || Types.asReal(Math.arctanh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnCSCH] = {
      eval: function(x) {
        return trycomplex(x, Complex.cosech) || Types.asReal(1.0 / Math.sinh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnSECH] = {
      eval: function(x) {
        return trycomplex(x, Complex.sech) || Types.asReal(1.0 / Math.cosh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnCOTH] = {
      eval: function(x) {
        return trycomplex(x, Complex.coth) || Types.asReal(1.0 / Math.tanh(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnNTOR] = {
      eval: function(u) {
        return Rational.numerator(Rational.rationalise_expression(u));
      }
    };

    context.functions[Types.fnDTOR] = {
      eval: function(u) {
        return Rational.denominator(Rational.rationalise_expression(u));
      }
    };

    context.functions[Types.fnDEC] = {
      eval: function(x) {
        return trycomplex(x, Complex.dec) || Types.asReal(Types.toRealValue(x));
      }
    };

    context.functions[Types.fnLOG] = {
      eval: function(x) {
        if (Types.isPositiveIntegerValue(x))
          return Types.asReal(KBI.log(Types.toInteger(x)));
        else if (Types.isPositiveRationalValue(x))
          return Types.asReal(KBR.log(Types.toFrac(x)));
        else if (Config.supportComplex && Types.isNegativeIntegerValue(x)) {
          return Types.asComplex(KBI.log(-Types.toInteger(x)), Math.PI);
        } else if (Config.supportComplex && Types.isNegativeRationalValue(x)) {
          return Types.asComplex(KBR.log(KBR.neg(Types.toFrac(x))), Math.PI);
        } else
          return trycomplex(x, Complex.log) || Types.asReal(Math.log(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnLOG10] = {
      eval: function(x) {
        if (Types.isInteger(x))
          return Types.asReal(KBI.log10(Types.toInteger(x)));
        else
          return Types.asReal(Math.log10(Types.toRealValue(x)));
      }
    };

    context.functions[Types.fnFRAC] = {
      eval: function(x) {
        switch (x.type) {
          case Types.integer:
          case Types.fraction:
            return x;
          case Types.real:
            var x = Types.toRealValue(x);
            var f = decimalToFraction(x, Config.maxdenom);
            return Types.asFrac(f.numerator, f.denominator);
          default:
            return Types.UNDEFINED;
        }
      }
    };

    context.functions[Types.fnRND] = {
      eval: function(n) {
        if (Types.isZero(n))
          return Types.asReal(rand.random());
        else
          return Types.asInteger(rand.urand(Types.toInteger(n)));
      }
    };

    context.functions[Types.fnROUND] = {
      eval: function(x, n) {
        if (Types.isComplex(x)) {
          return Complex.round(x, n);
        } else {
          var x = Types.toRealValue(x);
          // hack because of broken rounding in Chrome
          if (x > 0)
            x += Config.tolerance;
          else
            x -= Config.tolerance;
          return Types.asReal(parseFloat(x.toFixed(Types.toRealValue(n))));
        }
      }
    };

    context.functions[Types.fnSCI] = {
      eval: function(x) {
        var s;
        switch (x.type) {
          case Types.integer:
            s = KBI.sciString(x.value);
            break;
          case Types.real:
            s = x.value.toExponential(6).replace(/e/g, 'E');
            break;
          case Types.fraction:
            s = KBR.sciString(x.value);
            break;
          case Types.complex:
            s = Complex.sciString(x);
            break;
          default:
            return Types.UNDEFINED;
        }
        s = s.replace(/[0]+E/, 'E').replace(/\.E/, '.0E').replace(/E\+0/, '');
        // 			s = s.replace(/(\d+).(\d+)E\+(\d+)/g, "$1.$2*10^($3)")
        // 				.replace(/(\d+).(\d+)E-(\d+)/g, "$1.$2*10^(-$3)");
        return Types.asString(s);
      }
    };

    context.functions[Types.fnGCD] = {
      eval: function(a, b) {
        if (Types.isInteger(a) && Types.isInteger(b))
          return Types.asInteger(KBI.gcd(Types.toInteger(a), Types.toInteger(b)));
        else
          return Types.UNDEFINED;
      }
    };

    context.functions[Types.fnLCM] = {
      eval: function(a, b) {
        if (Types.isInteger(a) && Types.isInteger(b))
          return Types.asInteger(KBI.lcm(Types.toInteger(a), Types.toInteger(b)));
        else
          return Types.UNDEFINED;
      }
    };

    context.functions[Types.fnCHOOSE] = {
      eval: function(a, b) {
        if (Types.isInteger(a) && Types.isInteger(b))
          return Types.asInteger(KBI.bico(Types.toInteger(a), Types.toInteger(b)));
        else
          return Types.UNDEFINED;
      }
    };

    context.functions[Types.fnABS] = {
      eval: function(a) {
        if (Types.reducesToComplex(a))
          return Expression.numerical_evaluate(Complex.abs(a));
        else
          return Types.toRealValue(a) >= 0 ? a : context.neg(a);
      }
    };

    context.functions[Types.fnARG] = {
      eval: function(a) {
        if (Types.reducesToComplex(a))
          return Expression.numerical_evaluate(Complex.arg(a));
        else
          return Types.toRealValue(Expression.numerical_evaluate(a)) >= 0 ? Types.ZERO : Types.PI;
      }
    };
  };

  context.add = function(a, b) {
    return context.ops[Types.SumOp].eval(a, b);
  }
  context.sub = function(a, b) {
    return context.ops[Types.DiffOp].eval(a, b);
  }
  context.mul = function(a, b) {
    return context.ops[Types.ProdOp].eval(a, b);
  }
  context.div = function(a, b) {
    return context.ops[Types.QuotOp].eval(a, b);
  }
  context.pow = function(a, n) {
    return context.ops[Types.PowOp].eval(a, n);
  }
  context.neg = function(a) {
    return context.ops[Types.ProdOp].eval(Types.MINUSONE, a);
  }
  context.abs = function(a) {
    return context.functions[Types.fnABS].eval(a);
  }
  context.greaterThan = function(a, b) {
    return Types.toRealValue(context.sub(a, b)) > 0;
  }

  context.gamma = function(z) {
    var g = 7;
    var C = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
      771.32342877765313, -176.61502916214059, 12.507343278686905,
      -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];

    if (z < 0.5)
      return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    else {
      z -= 1;

      var x = C[0];
      for (var i = 1; i < g + 2; i++)
        x += C[i] / (z + i);

      var t = z + g + 0.5;
      return Math.sqrt(2 * Math.PI) * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x;
    }
  }

  context.factorial = function(n) {
    if (n % 1 != 0 || n < 0) {
      return context.gamma(n + 1);
    } else {
      return KBI.factorial(n);
    }
  }

  context.bico = function(n, k) {
    // validate integers
    if (n % 1 != 0 || k % 1 != 0) {
      lasterror = "Invalid values in binomial calculation";
      throw lasterror;
    }

    function bico_r(n, k, lmul, rdiv) {
      if (k == 0)
        return lmul / rdiv;
      else {
        lmul *= n;
        rdiv *= k;
        var f = context.gcd(lmul, rdiv);
        if (f > 1) {
          lmul /= f;
          rdiv /= f;
        }
        return bico_r(n - 1, k - 1, lmul, rdiv);
      }
    }

    if (k > n || k < 0)
      return 0;
    else if (k == n || k == 0)
      return 1;
    if (k > n / 2)
      k = n - k;
    return bico_r(n, k, 1, 1);
  }

  context.power = function(x, n) {
    if ((typeof n === 'number') && ((n % 1) === 0)) {
      var result = 1.0;
      if (n < 0) {
        n = -n;
        x = 1.0 / x;
      }
      while (n) {
        if (n & 1) result *= x;
        x *= x;
        n >>= 1;
      }
      return result;
    } else
      return Math.pow(x, n);
  }

  context.smallprimes = null;

  context.sieve = function(max) {
    // Make array of length max and fill with true
    var sieve = new Array(max + 1).fill(true);

    // Iterate from 2 until square root of max
    for (var i = 2; i <= Math.sqrt(max); i++) {
      // If the number is labelled a prime then we can start at i^2 and mark every multiple of i
      // from there as NOT a prime
      if (sieve[i]) {
        for (let j = i * i; j <= max; j += i) {
          sieve[j] = false;
        }
      }
    }

    // Now we can reduce our sieve to only the Prime indexes that are true
    return sieve.reduce((primes, isPrime, i) => {
      if (isPrime && i > 1) {
        primes.push(i)
      }

      return primes
    }, []);
  }

  // TODO ensure integer or gaussian integer
  context.gcd = function(a, b) {
    if (!isinteger(a) || !isinteger(b))
      return 1;
    a = Math.floor(Math.abs(a));
    b = Math.floor(Math.abs(b));
    while (b) {
      var t = b;
      b = a % b;
      a = t;
    }
    return a;
  }

  // TODO ensure integer or gaussian integer
  context.lcm = function(a, b) {
    if (!isinteger(a) || !isinteger(b))
      return 1;
    a = Math.floor(Math.abs(a));
    b = Math.floor(Math.abs(b));
    return a / context.gcd(a, b) * b;
  }

  context.ext_gcd = function(a, b) {
    // output: the list [gcd(a, b), m, n]
    var mpp = 1;
    var mp = 0;
    var npp = 0;
    var np = 1;
    var q, r, m, n;

    while (b != 0) {
      q = Math.floor(a / b);
      r = a % b;
      a = b;
      b = r;
      m = mpp - q * mp;
      n = npp - q * np;
      mpp = mp;
      mp = m;
      npp = np;
      np = n;
    }
    if (a >= 0)
      return [a, mpp, npp];
    else
      return [-a, -mpp, -npp];
  }
})(Eval);


var Expand = {};

(function(context) {
  context.expand_complex_powers = false;

  context.expand_product = function(u, v) {
    var result = Types.UNDEFINED;

    if (Config.checkTimeout())
      return Types.UNDEFINED;

    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isOpOfType(u, Types.SumOp)) {
      var f = Expression.operand(u, 1);
      var g = Expression.dropfirstterm(u);
      result = Expression.construct(Types.SumOp, null,
          [context.expand_product(f, v), context.expand_product(g, v)]);
    } else if (Types.isOpOfType(v, Types.SumOp)) {
      result = context.expand_product(v, u);
    } else if (Config.naivePower && Types.isOpOfType(u, Types.PowOp) && Types.isOpOfType(v, Types.PowOp)) {
      var ubase = Expression.operand(u, 1);
      var uexp = Expression.operand(u, 2);
      var vbase = Expression.operand(v, 1);
      var vexp = Expression.operand(v, 2);
      if (Expression.equal_expressions(uexp, vexp))
        result = Expression.pow(context.expand_product(ubase, vbase), vexp);
      else
        result = Expression.construct(Types.ProdOp, null, [u, v]);
    } else {
      result = Expression.construct(Types.ProdOp, null, [u, v]);
    }

    return result;
  }

  context.expand_power = function(u, n) {
    var result = Types.UNDEFINED;

    function makeInt(n) {
      return Expression.makenode(Types.integer, n, null);
    };

    if (Config.checkTimeout())
      return Types.UNDEFINED;

    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isPositiveIntegerValue(n) && Types.isOpOfType(u, Types.SumOp)) {
      var k, nint = n.value;
      if (nint == 1)
        return u;
      var f = Expression.operand(u, 1);
      var r = Expression.dropfirstterm(u);
      var s = Expression.newType();
      for (k = 0; KBI.lessThanOrEqualTo(k, nint); k = KBI.add(k, 1))
          //   for (k = KBI.ZERO; KBI.lessThanOrEqualTo(k, nint); k = KBI.add(k, KBI.ONE))
          // 	  for (k = 0; k <= nint; ++k)
      {
        var c = makeInt(KBI.bico(nint, k));
        var fnk = Expression.construct(Types.PowOp, null, [f, makeInt(KBI.sub(nint, k))]);
        var cfnk = Expression.construct(Types.ProdOp, null, [c, fnk]);
        s = Expression.construct(Types.SumOp, null,
            [s, context.expand_product(cfnk, context.expand_power(r, makeInt(k)))]);
        if (lasterror)
          return Types.UNDEFINED;
      }
      return s;
    } else {
      return Expression.construct(Types.PowOp, null, [u, n], Expand.expand_complex_powers);
    }
  }

  context.expandmainop = function(e) {
    var a, rest;//, u, v, result;

    if (lasterror)
      return Types.UNDEFINED;

    a = Expression.operand(e, 1);
    rest = Expression.dropfirstterm(e);
    if (Types.isOpOfType(e, Types.ProdOp)) {
      return Simplify.automatic_simplify(context.expand_product(a, rest));
      //		return algebraic_expand(e);
      //		if (isUnexpanded(result))
      //			result = algebraic_expand(result);
      //		// apply (a *) to each term in rest
      //		exprTreePtr u, v;//, result;
      //		for (int i = 0; i < num_operands(rest); ++i)
      //		{
      //			u = operand(rest, i);
      //			v = automaticsimplify(maketreefromop(MUL, a, u));
      //			if (i == 0)
      //				result = v;
      //			else
      //				result = automaticsimplify(maketreefromop(ADD, result, v));
      //		}
      //		return automaticsimplify(result);
    } else if (Types.isOpOfType(e, Types.PowOp) && Types.isPositiveIntegerValue(rest)) {
      return Simplify.automatic_simplify(context.expand_power(a, rest));
    } else
      return e;
    /*
			(match u
				( ('* a . rest)
					(expand-product a
													(expand-main-op (apply * rest))) )
				( ('^ a b)
					(expand-power a b) )
				( else u )))
		)

		 (= (simp/kind u) :sumop) u
		 (= (simp/kind u) :prodop) (expand-product (second u) (third u))
		 (= (simp/kind u) :powop) (let [p (reduce #(list '* % %2) (repeat (third u) (second u)))]
																(expand-product (second p) (third p)))
		 */
  }

  context.isUnexpanded = function(root) {
    // is there an (a + b) * c term in the tree?
    // this will appear as an MUL operator with an ADD child
    if (Types.isOpOfType(root, Types.PowOp)) {
      return Types.isOpOfType(root.children[0], Types.SumOp) ||
          Types.isOpOfType(root.children[1], Types.SumOp);
    } else if (root.children) {
      return root.children.some(function(c) {
        return context.isUnexpanded(c);
      });
    }
    return false;
  }

  context.algebraic_expand = function(u)	// integer powers only (TODO fractions)
  {
    var result = null;

    if (lasterror)
      return Types.UNDEFINED;

    var v = null, w = null, base = null, exponent = null;

    // TODO validate integer exponents...
    if (Types.isOpOfType(u, Types.SumOp)) {
      v = Expression.operand(u, 1);
      w = Expression.dropfirstterm(u);
      result = Expression.construct(Types.SumOp, null,
          [context.algebraic_expand(v), context.algebraic_expand(w)]);
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      v = Expression.operand(u, 1);
      w = Expression.dropfirstterm(u);
      result = context.expand_product(
          context.algebraic_expand(v), context.algebraic_expand(w));
      // 		if (context.isUnexpanded(result))
      // 			result = context.algebraic_expand(result);
    } else if (Types.isOpOfType(u, Types.PowOp)) {
      base = Expression.operand(u, 1);
      exponent = Expression.operand(u, 2);
      var expbase = context.algebraic_expand(base);
      if (Types.isInteger(exponent) && (exponent.value >= 2))
        result = context.expand_power(expbase, exponent);
      else if (Types.isPositiveRationalValue(exponent)) {
        var n = exponent.value.n;
        var d = exponent.value.d;
        var nint = Math.floor(n / d);
        var nfrac = Types.asFrac(n % d, d);
        result = context.expand_power(expbase, Types.asInteger(nint));
        if (nfrac.value.n != 0) {
          result = context.expand_product(result, Expression.construct(Types.PowOp, null,
              [expbase, nfrac], Expand.expand_complex_powers));
        }
      } else {
        result = Expression.construct(Types.PowOp, null, [expbase, exponent],
            Expand.expand_complex_powers);
      }
    } else if (Types.isFunction(u)) {
      result = Expression.map(context.algebraic_expand, u);
    }

    return result ? Simplify.automatic_simplify(result) : u;
  }
})(Expand);


var Expression = {};

(function(context) {
  context.makenode = function(type, value, children) {
    if (value !== value)
      return Types.UNDEFINED;
    else if (Config.supportComplex && type == Types.symbol && value === "i")
      return Types.I;
    else if (!children || Array.isArray(children))
      return {type: type, value: value, children: children};
    else
      return {type: type, value: value, children: [children]};
  }

  context.construct = function(type, value, children) {
    // evaluate if purely numerical
    var u = children;
    var r = null;
    if (u && u.length == 2 && Eval.ops[type] && Types.isNumber(u[0]) && Types.isNumber(u[1])) {
      r = Eval.ops[type].eval(u[0], u[1], false);
    }
    return r ? r : context.makenode(type, value, children);
  }

  context.newType = function() {
    return context.construct(Types.integer, 0, null);
  }

  context.appendChild = function(node, child) {
    if (!node.children)
      node.children = [];
    node.children.push(child);
    return node;
  }

  context.prependChild = function(node, child) {
    if (!node.children)
      node.children = [];
    node.children.unshift(child);
    return node;
  }

  context.kind = function(u) {
    //	This operator returns the type of expression
    if (u.type == Types.fn)
      return u.value;
    else
      return u.type;
  }

  context.num_operands = function(u) {
    return u.children ? u.children.length : 0;
  }

  context.operand = function(u, n) {
    var s = context.num_operands(u);
    return n > s ? null : u.children[n - 1];
  }

  context.base = function(e) {
    switch (e.type) {
      case Types.PowOp:
        return context.operand(e, 1);
      case Types.fraction:
      case Types.integer:
      case Types.real:
        return Types.UNDEFINED;
      default:
        return e;
    }
  }

  context.exponent = function(e) {
    switch (e.type) {
      case Types.PowOp:
        return context.operand(e, 2);
      case Types.fraction:
      case Types.integer:
      case Types.real:
        return Types.UNDEFINED;
      default:
        return Types.ONE;
    }
  }

  context.term = function(e) {
    switch (e.type) {
      case Types.ProdOp:
        if (Types.isNumber(e.children[0]))
          return context.construct(Types.ProdOp, null, e.children.slice(1));
        else
          return e;
      case Types.fraction:
      case Types.integer:
      case Types.real:
        return Types.UNDEFINED;
      default:
        return context.construct(Types.ProdOp, null, e);
    }
  }

  context.constant = function(e) {
    switch (e.type) {
      case Types.ProdOp:
        if (Types.isNumber(e.children[0]))
          return e.children[0];
        else
          return Types.ONE;
      case Types.fraction:
      case Types.integer:
      case Types.real:
        return Types.UNDEFINED;
      default:
        return Types.ONE;
    }
  }

  context.get_constant_term = function(e) {
    var constant = Types.ONE;
    var term = Types.ONE;
    if (Types.isOpOfType(e, Types.ProdOp)) {
      for (var i = 1; i <= Expression.num_operands(e); ++i) {
        var op = Expression.operand(e, i);
        if (Types.reducesToNumber(op))
          constant = Expression.prod(op, constant);
        else
          term = Expression.prod(op, term);
      }
    } else
      term = e;

    return {constant, term};
  }

  context.dropfirstterm = function(e) {
    var result = null;

    var size = e.children.length;
    if (size < 1)
      result = Types.UNDEFINED;
    else if (size == 2)
      result = e.children[1];
    else
      result = context.makenode(e.type, e.value, e.children.slice(1));

    return result;
  }

  context.dropnthterm = function(e, n) {
    var result = null;

    var size = e.children.length;

    if (n <= 0 || n > size) {
      lasterror = "UNKNOWN_ERROR";
      return Types.UNDEFINED;
    } else if (n == 1)
      return context.dropfirstterm(e);
    else if (size < 1)
      result = Types.UNDEFINED;
    else if (size == 2)
      result = e.children[0];	// only possibility
    else {
      e.children.splice(n - 1, 1);
      result = context.makenode(e.type, e.value, e.children);
    }

    return result;
  }

  context.getfirstterm = function(e) {
    if (!e.children || e.children.length <= 1)
      return e;
    else
      return context.getfirstterm(context.operand(e, 1));
  }

  context.getInitialFactor = function(e) {
    if (Types.isNumber(e))
      return e;
    else if (Types.isOpOfType(e, Types.ProdOp))
      return context.operand(e, 1);
    else
      return null;
  }

  context.getInitialIntegerFactor = function(e) {
    if (Types.isInteger(e))
      return e;
    else if (Types.isOpOfType(e, Types.ProdOp) && Types.isInteger(context.operand(e, 1)))
      return context.operand(e, 1);
    else
      return null;
  }

  context.free_of = function(u, t, checkpower) {
    if (context.equal_expressions(u, t))
      return false;
    else if (Types.isNumber(u) && !Types.isNumber(t))
      return true;
    else if (Types.isI(t) && Types.isImaginary(u))
      return false;	// special check since 2i is a single number not a product
    var i = 1;
    while (i <= context.num_operands(u)) {
      if (!context.free_of(context.operand(u, i), t))
        return false;
      ++i;
    }
    return true;
  }

  context.set_free_of = function(u, S) {
    return S.every(function(x) {
      return context.free_of(u, x);
    });
  }

  function eInArray(e, a) {
    for (var i = 0; i < a.length; ++i) {
      if (context.equal_expressions(a[i], e))
        return true;
    }
    return false;
  }

  context.getVariables = function(e) {
    var vars = [];

    var getVariables_rec = function(e, vars) {
      if (context.isLeafNode(e)) {
        if (Types.isSymbol(e) && !Types.isGeneralisedNumber(e)) {
          if (!eInArray(e, vars))
            vars.push(e);
        }
      }
      for (var i = 1; i <= context.num_operands(e); ++i) {
        getVariables_rec(context.operand(e, i), vars);
      }
    }

    getVariables_rec(e, vars);
    return vars;
  }

  context.copy = function(r) {
    var node = context.construct(r.type, r.value, null);
    if (r.children)
      node.children = r.children.map(context.copy);
    return node;
  }

  context.countoperators = function(e) {
    var n = 0;
    var countterms_r = function(e) {
      if (e.children)
        e.children.map(function(u) {
          countterms_r(u);
        });
      return Types.isOperator(e) ? n++ : n;
    }
    return countterms_r(e);
  }

  context.countelems = function(e) {
    var count = {ops: 0, fns: 0, terms: 0};
    var countelems_r = function(e) {
      if (e.children)
        e.children.map(function(u) {
          countelems_r(u);
        });
      if (Types.isOperator(e))
        count.ops++;
      else if (Types.isFunction(e))
        count.fns++;
      else
        count.terms++;
      return count;
    }
    return countelems_r(e);
  }

  context.separate_factors = function(u, x) {
    var result = {free: Types.ONE, dep: Types.ONE};
    if (Types.isOpOfType(u, Types.ProdOp)) {
      for (var i = 1; i <= context.num_operands(u); ++i) {
        var f = context.operand(u, i);
        if (context.free_of(f, x))
          result.free = context.makenode(Types.ProdOp, null, [f, result.free]);
        else
          result.dep = context.makenode(Types.ProdOp, null, [f, result.dep]);
      }
      result.free = Simplify.automatic_simplify(result.free);
      result.dep = Simplify.automatic_simplify(result.dep);
    } else {
      if (context.free_of(u, x))
        result.free = u;
      else
        result.dep = u;
    }
    return result;
  }

  context.diff = function(u, v) {
    var diff = context.construct(Types.DiffOp, null, [u, v]);
    return Simplify.automatic_simplify(diff);
  }

  context.sum = function(u, v) {
    return Simplify.automatic_simplify(
        context.construct(Types.SumOp, null, [u, v]));
  }

  context.sumAll = function(u) {
    if (!u.length)
      return Types.ZERO;
    else if (u.length == 1)
      return u[0];
    return Simplify.automatic_simplify(context.construct(Types.SumOp, null, u));
  }

  context.prod = function(u, v) {
    return Simplify.automatic_simplify(
        context.construct(Types.ProdOp, null, [u, v]));
  }

  context.prodAll = function(u) {
    if (!u.length)
      return Types.ZERO;
    else if (u.length == 1)
      return u[0];
    return Simplify.automatic_simplify(context.construct(Types.ProdOp, null, u));
  }

  context.neg = function(u) {
    return context.prod(Types.MINUSONE, u);
  }

  context.inv = function(u) {
    return context.div(Types.ONE, u);
  }

  context.div = function(u, v) {
    return Simplify.automatic_simplify(
        context.construct(Types.QuotOp, null, [u, v]));
  }

  context.pow = function(u, v) {
    return Simplify.automatic_simplify(
        context.construct(Types.PowOp, null, [u, v]));
  }

  // replace all occurrences of g in r with v
  context.substitute = function(r, g, v) {
    if (context.free_of(r, g))
      return r;
    else {
      var rcopy = context.copy(r);
      return context.substitute_r(rcopy, g, v);
    }
  }

  context.substitute_r = function(r, g, v) {
    if (context.free_of(r, g))
      return r;
    else if (context.equal_expressions(r, g))
      return v;
    else if (r.children)
      r.children = r.children.map(function(e) {
        return context.substitute_r(e, g, v);
      });
    return r;
  }

  context.map = function(F, u) {
    var mappedchildren = u.children ? u.children.map(function(x) {
      return F(x);
    }) : null;
    return context.makenode(u.type, u.value, mappedchildren);
  }

  context.map2 = function(F, u, n) {
    var mappedchildren = u.children.map(function(x) {
      return F(x, n);
    });
    return context.makenode(u.type, u.value, mappedchildren);
  }

  context.sort = function(e) {
    function comparenumber(u, v) {
      var uval = Types.isComplex(u) ? Eval.functions[Types.fnABS].eval(u) : Types.toRealValue(u);
      var vval = Types.isComplex(u) ? Eval.functions[Types.fnABS].eval(v) : Types.toRealValue(v);
      return uval > vval ? 1 : (uval == vval ? 0 : -1);
    }

    function comparestring(s1, s2) {
      // str1 < str2 ? -1 : +(str1 > str2)
      return (s1 > s2) - (s1 < s2);
    }

    function Xcompareexpr(u, v) {
      var r = compareexpr2(u, v);
      console.log("Compare " + context.printInfix(u) + " and " +
          context.printInfix(v) + " returned " + r);
      return r;
    }

    function compareexpr(u, v, d) {
      if (!d)
        d = 1;
      else if (d++ > 1000) {
        console.log("Call stack " + context.printInfix(u) + " " + context.printInfix(v));
        return 0;
      }
      if (Types.isUndefined(u) && Types.isUndefined(v))
        return 0;
      else if (Types.isI(u))
        return -1;
      else if (Types.isI(v))
        return 1;
      else if (Types.isPi(u) && !Types.isNumber(v))
        return -1;
      else if (Types.isPi(v) && !Types.isNumber(u))
        return 1;
      else if (Types.isNumber(u) && Types.isNumber(v))
        return comparenumber(u, v);
      else if (Types.isNumber(u) && Types.reducesToNumber(v))
        return -1;
      else if (Types.reducesToNumber(u) && Types.isNumber(v))
        return +1;
      else if (Types.isSymbol(u) && Types.isSymbol(v))
        return comparestring(u.value, v.value);
      else if ((Types.isOpOfType(u, Types.SumOp) && Types.isOpOfType(v, Types.SumOp)) ||
          (Types.isOpOfType(u, Types.ProdOp) && Types.isOpOfType(v, Types.ProdOp))) {
        var m = u.children.length;
        var n = v.children.length;
        var minmn = n < m ? n : m;
        var um = context.operand(u, m);
        var vn = context.operand(v, n);
        if (context.equal_expressions(um, vn)) {
          for (var k = 0; k < minmn; ++k) {
            var umk = context.operand(u, m - k);
            var vnk = context.operand(v, n - k);
            if (!context.equal_expressions(umk, vnk))
              return compareexpr(umk, vnk, d);
          }
          if (m == n)
            return 0;
          else
            return m < n ? -1 : 1;
        } else {
          return compareexpr(um, vn, d);
        }
      } else if (Types.isOpOfType(u, Types.PowOp) && Types.isOpOfType(v, Types.PowOp)) {
        var baseu = context.base(u);
        var basev = context.base(v);
        if (context.equal_expressions(baseu, basev))
          return compareexpr(context.exponent(u), context.exponent(v), d);
        else
          return compareexpr(baseu, basev, d);
      } else if (Types.isFunction(u) && Types.isFunction(v)) {
        var namecmp = comparestring(u.value, v.value);
        if (namecmp)
          return namecmp;
        else {
          var m = u.children.length;
          var n = v.children.length;
          var minmn = n < m ? n : m;
          for (var k = 1; k <= minmn; ++k) {
            var umk = context.operand(u, k);
            var vnk = context.operand(v, k);
            if (!context.equal_expressions(umk, vnk))
              return compareexpr(umk, vnk, d);
          }
          if (m == n)
            return 0;
          else
            return m < n ? -1 : 1;
        }
      } else if (Types.isNumber(u)) {
        return -1;
      } else if (Types.reducesToNumber(u)) {
        return -1;
      } else if (Types.isOpOfType(u, Types.FactOp) && Types.isOpOfType(v, Types.FactOp)) {
        var uop = context.operand(u, 1);
        var vop = context.operand(v, 1);
        return compareexpr(uop, vop, d);
      } else if (Types.isOpOfType(u, Types.Deriv) && Types.isOpOfType(v, Types.Deriv)) {
        var uop = context.operand(u, 1);
        var vop = context.operand(v, 1);
        return compareexpr(uop, vop, d);
      } else if (Types.isOpOfType(u, Types.ProdOp)) {
        if (Types.isOpOfType(v, Types.PowOp) || Types.isOpOfType(v, Types.SumOp) ||
            Types.isSymbol(v) || Types.isOpOfType(v, Types.FactOp) || Types.isFunction(v)) {
          var node = context.makenode(Types.ProdOp, null, [v]);
          return compareexpr(u, node, d);
        }
      } else if (Types.isOpOfType(u, Types.PowOp)) {
        if (Types.isOpOfType(v, Types.SumOp) || Types.isSymbol(v) ||
            Types.isFunction(v) || Types.isOpOfType(v, Types.FactOp)) {
          var node = context.makenode(Types.PowOp, null, [v, Types.ONE]);
          return compareexpr(u, node, d);
        }
      } else if (Types.isOpOfType(u, Types.SumOp)) {
        if (Types.isSymbol(v) || Types.isFunction(v) || Types.isOpOfType(v, Types.FactOp)) {
          var node = context.makenode(Types.SumOp, null, [v]);
          return compareexpr(u, node, d);
        }
      } else if (Types.isOpOfType(u, Types.FactOp)) {
        if (Types.isSymbol(v) || Types.isFunction(v)) {
          var node = context.makenode(Types.FactOp, null, [v]);
          return compareexpr(u, node, d);
        }
      } else if (Types.isOpOfType(u, Types.Deriv)) {
        return 1;
      } else if (Types.isOpOfType(v, Types.Deriv)) {
        return -1;
      } else if (Types.isFunction(u) && Types.isSymbol(v)) {
        return 1;	// symbol always comes first
        //		int namecmp = strcmp(getName(u), getName(v));
        //		if (namecmp == 0)
        //			return 1;
        //		else
        //			return namecmp;
      }

      return -compareexpr(v, u, d);
    }

    if (e.children)
      return e.children.sort(compareexpr);
    else if (Array.isArray(e))
      return e.sort(compareexpr);
    else
      return e;
  }

  context.equal_expressions = function(v1, v2) {
    if (!v1 || !v2)
      return !v1 && !v2;	// both null is ok

    if (v1.type != v2.type)
      return 0;

    if (Types.isInteger(v1) && KBI.equals(v1.value, v2.value))
      return 1;

    if (Types.isFraction(v1) && KBR.equals(v1.value, v2.value))
      return 1;

    if (Types.isComplex(v1)) {
      return Complex.equals(v1, v2);
    }

    if (Number.isNaN(v1.value) && Number.isNaN(v2.value))
      return 1;

    if (v1.value != v2.value)
      return 0;

    if (!v1.children)
      return v2.children == null;

    if (v1.children.length != v2.children.length)
      return 0;

    for (var i = 0; i < v1.children.length; ++i) {
      if (!context.equal_expressions(v1.children[i], v2.children[i]))
        return 0;
    }

    return 1;
  }

  context.nodestring = function(node) {
    if (Types.isUndefined(node))
      return "Undefined";
    else if (Types.isOperator(node))
      return node.type;
    else if (Types.isComplex(node))
      return Complex.numToString(node);
    else if (Types.isNumber(node))
      return Types.numToString(node);
    else
      return node.value + "";
  }

  context.printExpression = function(root, level) {
    if (Array.isArray(root)) {
      var result = root.map(function(r) {
        return context.printExpression(r, level);
      });
      return result.join("\n");
    } else {
      var string = "";

      function printnode(node, level) {
        return Array(level + 1).join("  ") + context.nodestring(node) + "\n";
      }

      if (!level)
        level = 0;
      if (root) {
        string += printnode(root, level);
        if (root.children) {
          root.children.forEach(function(c) {
            string += context.printExpression(c, level + 1);
          });
        }
        ;
      }
      return string;
    }
  }

  context.printInfix = function(root, maxsize) {
    var holder = {s: ""};
    try {
      context.toInfix(holder, root, null, maxsize);
    } catch (x) {
      console.log(x);
      console.log("Error: " + x);
    }
    return holder.s;
  }

  context.toInfix = function(holder, root, lastop, maxsize) {
    function embrace(e, usebrackets, addspace) {
      var s = e.type ? context.nodestring(e) : e;
      // TODO hack to avoid spurious bracketing of extended relational expressions (like -3<x<2)
      if (s.match(/[<>≤≥≠]/))
        usebrackets = false;
      if (usebrackets && (s.startsWith('(') && s.endsWith(')'))) {
        if (s.match(/[\(\)]/g).length != 2)	// i.e. not only the outside brackets
          return "(" + s + ")";
        else
          return s;
      }
      if (usebrackets)
        return "(" + s + ")";
      else
        return s;
    }

    function nodestring(holder, node) {
      holder.s += context.nodestring(node);
    }

    // TODO alert and possibly continue?
    if (maxsize && maxsize > 0 && (holder.s.length > maxsize)) {
      holder.s += "&lt;<i>further terms omitted</i>&gt;";
      throw "full";
    }

    var i;
    if (root != null) {
      if (Types.isFunction(root)) {
        nodestring(holder, root);
        var args = {s: ""};
        for (i = 0; root.children && i < root.children.length; ++i) {
          context.toInfix(args, root.children[i], null, maxsize);
          if (i != root.children.length - 1) args.s += ",";
        }
        holder.s += embrace(args.s, true);
      } else if (!root.children) {
        var needbrackets = false;
        if (Types.isNumber(root) && Types.isNegativeValue(root)) // we have a unary minus
        {
          needbrackets = lastop && ((lastop.prec > 4) || (lastop.assoc == "Right"));
        }
        if (needbrackets || Types.isFullyComplex(root))
          holder.s += embrace(root, true);
        else
          nodestring(holder, root);
      } else {
        var op = classifier.getOperator(root.type);
        var needbrackets = op && lastop && ((lastop.prec >= op.prec) || (lastop.assoc == "Right"));

        var expr = {s: ""};
        if (root.children.length == 1) {
          i = 0;
          nodestring(expr, root);
        } else {
          for (i = 0; i < root.children.length - 1; ++i) {
            context.toInfix(expr, root.children[i], op, maxsize);
            nodestring(expr, root);
          }
        }
        context.toInfix(expr, root.children[i], op, maxsize);
        holder.s += embrace(expr.s, needbrackets);
      }
    }

    return holder.s;
  }


  context.printTree = function(root, level) {
    if (Array.isArray(root)) {
      var result = root.map(function(r) {
        return context.printTree(r, level);
      });
      return result.join("\n");
    } else {
      var string = "";

      function printASTnode(node, level) {
        return Array(level + 1).join("  ") + context.nodestring(node) + "\n";
      }

      if (!level)
        level = 0;
      if (root) {
        string += printASTnode(root, level);
        if (root.children) {
          root.children.forEach(function(c) {
            string += context.printTree(c, level + 1);
          });
        }
        ;
      }
      return string;
    }
  }

  context.isLeafNode = function(node) {
    return node.children == null;
  }

  context.isNonrecursiveNode = function(node) {
    return context.isLeafNode(node) ||
        node.children.every(context.isLeafNode);
  }

  context.numerical_evaluate = function(t) {
    return context.evaluate_node(Expression.copy(t));
  }

  context.evaluate_node = function(t) {
    if (context.isLeafNode(t)) {
      if (Types.isI(t))
        return t;
      else if (Types.isSpecialConstant(t))
        return Types.asReal(t);
      else
        return t;
    } else if (context.isNonrecursiveNode(t)) {
      if (Types.reducesToNumber(t)) {
        var v;
        if (Types.isOperator(t)) {
          v = Eval.ops[t.type].eval(t.children, null, true);
          if (Types.reducesToComplex(v))
            v = Complex.dec(v);
        } else if (Types.isFunction(t) && t.children && t.children.length == 1)	// TODO arity
          v = Eval.functions[t.value].eval(t.children[0]);
        else if (Types.isFunction(t) && t.children && t.children.length == 2)	// TODO arity
          v = Eval.functions[t.value].eval(t.children[0], t.children[1]);
        else
          return t;//Types.UNDEFINED;

        if (Types.isOperator(v))
          return Eval.ops[v.type].eval(v.children, null, true);
        else if (Types.isComplex(v))
          return Complex.dec(v);
        else
          return v;
      } else
        return t;
    } else {
      var tc = context.copy(t);
      t.children = t.children.map(function(c) {
        return context.evaluate_node(c);
      });
      if (context.equal_expressions(t, tc))
        return t;
      else
        return context.evaluate_node(t);
    }
  }

  context.numerical_evaluateX = function(root) {
    var numerical_evaluate_r = function(node) {
      if (node.children) {
        node.children.forEach(function(c) {
          numerical_evaluate_r(c);
        });
      }
      ;

      node.value = Types.toInteger(node);
      node.children = null;
      node.type = Types.real;

      return node;
    }

    if (Types.reducesToNumber(root)) {
      var result = numerical_evaluate_r(context.copy(root));
      if (result && !isNaN(result.value))
        return result;
    }

    return Types.UNDEFINED;
  }

  context.get_factors_by_type = function(u, x) {
    var c = Types.ONE;
    var linear = [];
    var quad = [];
    var poly = [];
    var other = [];

    var get_factors_rec = function(u, x, l, q, p, o) {
      var t;
      if (Types.isOpOfType(u, Types.SumOp)) {
        var lf = Polynomial.linear_form(u, x);
        if (lf != null)
          l.push(lf);
        else {
          var qf = Polynomial.quadratic_form(u, x);
          if (qf != null)
            q.push(qf);
          else if (Polynomial.polynomial_sv(u, x))
            p.push(u);
          else
            o.push(u);
        }
      } else if (Types.isOpOfType(u, Types.PowOp)) {
        t = context.operand(u, 1);
        get_factors_rec(t, x, l, q, p, o);
      } else if (Types.isOpOfType(u, Types.ProdOp)) {
        for (var i = 1; i <= context.num_operands(u); ++i) {
          t = context.operand(u, i);
          get_factors_rec(t, x, l, q, p, o);
        }
      } else if (context.free_of(u, x))
        c = context.prod(c, u);
      else if (Polynomial.polynomial_sv(u, x))
        p.push(u);
      else
        o.push(u);
    }

    get_factors_rec(u, x, linear, quad, poly, other);

    return {
      constant: c,
      linear: linear,
      quadratic: quad,
      polynomial: poly,
      other: other
    };
  }

  context.get_binomial_factors = function(u, x) {
    var c = Types.ONE;
    var binom = [];
    var other = [];

    var binom_form = function(u, x) {
      if (context.num_operands(u) == 2) {
        var t1 = context.operand(u, 1);
        var t2 = context.operand(u, 2);
        if (context.free_of(t1, x) && !context.free_of(t2, x))
          return [t2, t1];
        else if (!context.free_of(t1, x) && context.free_of(t2, x))
          return [t1, t2];
      }
      return null;
    }

    var get_factors_rec = function(u, x, b, o) {
      var t;
      if (Types.isOpOfType(u, Types.SumOp)) {
        var bt = binom_form(u, x);
        if (bt != null)
          b.push(bt);
        else
          o.push(u);
      } else if (Types.isOpOfType(u, Types.PowOp)) {
        t = context.operand(u, 1);
        get_factors_rec(t, x, b, o);
      } else if (Types.isOpOfType(u, Types.ProdOp)) {
        for (var i = 1; i <= context.num_operands(u); ++i) {
          t = context.operand(u, i);
          get_factors_rec(t, x, b, o);
        }
      } else if (context.free_of(u, x))
        c = context.prod(c, u);
      else
        o.push(u);
    }

    get_factors_rec(u, x, binom, other);

    return {constant: c, binom: binom, other: other};
  }
})(Expression);


var Humanise = function() {
  var me = {};

  var isPositive = function(node) {
    return !isNegative(node);
  }

  var isNegative = function(node) {
    // if -ve rational, return true and +ve
    // if product, check 1st argument is negative
    if (Types.isNegativeRationalValue(node))
      return true;
    else
      return Types.isOpOfType(node, Types.ProdOp) && node.children && isNegative(node.children[0]);
  }

  var isNegativePower = function(node) {
    return Types.isOpOfType(node, Types.PowOp) && node.children && isNegative(node.children[1]);
  }

  var isSumWithInitialNegative = function(node) {
    return Types.isOpOfType(node, Types.SumOp) && node.children && node.children.length > 1 &&
        isNegative(node.children[0]);
  }

  var isSumWithAnyNegative = function(node) {
    return Types.isOpOfType(node, Types.SumOp) && node.children && node.children.some(isNegative);
  }

  var isSumWithAllNegative = function(node) {
    return Types.isOpOfType(node, Types.SumOp) && node.children && node.children.every(isNegative);
  }

  // if input is -ve - X, output is X + -ve
  // if input is -ve + X, output is X - -ve
  var convertNegativeSum = function(node, skipExtraCheck) {
    if (!isSumWithAnyNegative(node))
      return false;	// nothing to do
    // if all negative we want to negate the lot
    if (node.children.every(isNegative)) {
      // multiply every term by -1
      node.children = node.children.map(c => Expression.prod(Types.MINUSONE, c));
      return true;
    }
    // if the first term is positive we want to negate and then rearrange
    else if (!skipExtraCheck && isPositive(node.children[0])) {
      // multiply every term by -1
      node.children = node.children.map(c => Expression.prod(Types.MINUSONE, c));
      convertNegativeSum(node, false);
      return true;
    } else {
// TODO for now only change order inside binomials
//			if (isPositive(node.children[node.children.length - 1]))	// reverse to get a positive at the front
      if (node.children.length == 2 && isPositive(node.children[1]))
        node.children.reverse();
      return false;
    }
  }

  var isNegativePowerOrFraction = function(node) {
    return isNegativePower(node) || (!Types.isInteger(node) && Types.isRationalValue(node));
  }

  // input is a^-ve, output is a^ve
  var convertNegativePower = function(node) {
    var pow = Expression.prod(Types.MINUSONE, node.children[1]);
    var c1 = node.children[0];
    if (Types.isOne(pow))
      return c1;
    else
      return Expression.construct(Types.PowOp, null, [c1, pow]);
  }

  var makeProd = function(u) {
    if (u.length == 0)
      return Types.ONE;
    else if (u.length == 1)
      return u[0];
    else
      return Expression.makenode(Types.ProdOp, null, u);
  }

  me.outputPostProcess = function(r) {
    if (Types.isUndefined(r))
      return r;
    if (Types.isOpOfType(r, Types.Equate) || Solve.isInequation(r)) {
      var split = Solve.splitEquation(r);
      return Expression.construct(r.type, null, [me.outputPostProcess(split.lhs), me.outputPostProcess(split.rhs)]);
    }
    var newnode = r;
    if (r.children)
      newnode.children = r.children.slice();
    if (isNegativePower(r)) {
      newnode.type = Types.QuotOp;
      newnode.children = [Types.ONE, convertNegativePower(newnode)];
    } else if (Types.isOpOfType(r, Types.ProdOp) && r.children.length >= 2 &&
        r.children.some(isNegativePowerOrFraction)) {
      var n = [];
      var d = [];
      newnode.children.forEach(c => {
        if (Types.isRationalValue(c)) {
          var fn = Rational.numerator(c);
          var fd = Rational.denominator(c);
          if (!Types.isOne(fn))
            n.push(fn);
          if (!Types.isOne(fd))
            d.push(fd);
        } else if (isNegativePower(c))
          d.push(convertNegativePower(c));
        else
          n.push(c);
      });
      newnode.type = Types.QuotOp;
      newnode.value = null;
      newnode.children = [makeProd(n), makeProd(d)];
    } else if (Types.isFunctionOfType(r, Types.fnEXP)) {
      if (newnode.children.length == 1 && Types.isOne(newnode.children[0]))
        return Types.E;
      else {
        newnode.type = Types.PowOp;
        newnode.value = null;
        newnode.children = [Types.E, newnode.children[0]];
      }
    } else if (Types.isOpOfType(r, Types.ProdOp) && r.children.length >= 2 &&
        Types.isImaginary(r.children[0]) && !Expression.free_of(r.children[1], Types.PI)) {
      var re = Complex.im(r.children[0]);
      newnode.children.splice(0, 2, re, r.children[1], Types.I);
      newnode.children = r.children.map(me.outputPostProcess);
    }
    if (newnode.children) {
      newnode.children = newnode.children.map(me.outputPostProcess);
    }
    return newnode;
  };

  function humaniseProd(r) {
    if (Types.isUndefined(r))
      return r;
    if (Types.isFunction(r)) {
      r.children = r.children.map(me.humaniseProd);
    } else if (Types.isOpOfType(r, Types.ProdOp)) {
      var minusones = [];
      var reversible = [];
      var initialFactor = Types.reducesToNumber(Expression.operand(r, 1)) ?
          Expression.operand(r, 1) : null;
      if (initialFactor && Types.isNegativeRationalValue(initialFactor)) {
        minusones.push(Types.MINUSONE);
        initialFactor = Expression.prod(Types.MINUSONE, initialFactor);
      }
      r.children.forEach(c => {
        if (isSumWithAllNegative(c)) {
          minusones.push(Types.MINUSONE);
          convertNegativeSum(c, false);
        } else if (isSumWithInitialNegative(c)) {
          convertNegativeSum(c, false);
          reversible.push(c);
        } else if (isSumWithAnyNegative(c)) {
          reversible.push(c);
        } else if (Types.isOpOfType(c, Types.PowOp)) {
          var base = Expression.operand(c, 1);
          var exp = Expression.operand(c, 2);
          if (isSumWithAllNegative(base)) {
            minusones.push(Expression.pow(Types.MINUSONE, exp));
            convertNegativeSum(base, false);
          }
        }
      });

      if (minusones.length) {
        var minusFactor = initialFactor ? Expression.prodAll([initialFactor, ...minusones])
            : Expression.prodAll(minusones);
        if (Types.isNegativeRationalValue(minusFactor) && reversible.length) {
          convertNegativeSum(reversible[0], false);
          minusFactor = Expression.prod(Types.MINUSONE, minusFactor);
        }
        if (initialFactor)
          r.children[0] = minusFactor;
        else if (!Types.isOne(minusFactor))
          r.children.unshift(minusFactor);
      }
    }
    return r;
  }

  me.humaniseNegatives = function(r) {
    if (Types.isUndefined(r))
      return r;
    if (Types.isFunction(r)) {
      r.children = r.children.map(me.humaniseNegatives);
    } else if (Types.isOpOfType(r, Types.Equate) || Solve.isInequation(r)) {
      var split = Solve.splitEquation(r);
      return Expression.construct(r.type, null, [me.humaniseNegatives(split.lhs), me.humaniseNegatives(split.rhs)]);
    } else if (Types.isOpOfType(r, Types.SumOp)) {
      if (convertNegativeSum(r, true))
        r = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, r]);
      if (r.children)
        r.children = r.children.map(me.humaniseNegatives);
    } else if (Types.isOpOfType(r, Types.PowOp)) {
      var base = Expression.operand(r, 1);
      var pow = Expression.operand(r, 2);
      r = me.humaniseNegatives(base);
      if (Types.isOpOfType(r, Types.ProdOp))
        r.children = r.children.map(b => Expression.pow(b, pow));
      else
        r = Expression.construct(Types.PowOp, null, [r, pow]);
    } else if (Types.isOpOfType(r, Types.QuotOp) || Rational.is_rational(r)) {
      var n = Rational.numerator(r);
      var d = Rational.denominator(r);
      var nh = me.humaniseNegatives(n);
      var dh = me.humaniseNegatives(d);
      var nhi = Expression.getInitialFactor(nh);
      var dhi = Expression.getInitialFactor(dh);
      if (nhi && dhi && isNegative(dhi)) {
        nh = me.humaniseNegatives(Expression.prod(Types.MINUSONE, nh));
        dh = me.humaniseNegatives(Expression.prod(Types.MINUSONE, dh));
      }
      if (nhi && isNegative(nhi) && isSumWithAnyNegative(dh)) {
        nh = me.humaniseNegatives(Expression.prod(Types.MINUSONE, nh));
        dh = me.humaniseNegatives(Expression.prod(Types.MINUSONE, dh));
      }
      r = Expression.construct(Types.QuotOp, null, [nh, dh]);
    } else if (Types.isOpOfType(r, Types.ProdOp)) {
      r = humaniseProd(r);
      if (r.children)
        r.children = r.children.map(me.humaniseNegatives);
    }

    if (Types.isOpOfType(r, Types.ProdOp) && Types.isOne(r.children[0])) {
      if (r.children.length > 2)
        r.children.shift();
      else
        r = r.children[1];
    }

    return r;
  }

  me.reversePoly = function(r) {
    if (Types.isUndefined(r))
      return r;
    if (Types.isFunction(r)) {
      r.children = r.children.map(me.reversePoly);
    } else if (Types.isOpOfType(r, Types.Equate) || Solve.isInequation(r)) {
      var split = Solve.splitEquation(r);
      return Expression.construct(r.type, null, [me.reversePoly(split.lhs), me.reversePoly(split.rhs)]);
    } else if (Types.isOpOfType(r, Types.QuotOp) || Rational.is_rational(r)) {
      var n = Rational.numerator(r);
      var d = Rational.denominator(r);
      var nh = me.reversePoly(n);
      var dh = me.reversePoly(d);
      r = Expression.construct(Types.QuotOp, null, [nh, dh]);
    } else if (Types.isOpOfType(r, Types.PowOp)) {
      var base = Expression.operand(r, 1);
      var pow = Expression.operand(r, 2);
      r = me.reversePoly(base);
      if (Types.isOpOfType(r, Types.ProdOp))
        r.children = r.children.map(b => Expression.pow(b, pow));
      else
        r = Expression.construct(Types.PowOp, null, [r, pow]);
    } else if (Types.isOpOfType(r, Types.ProdOp)) {
      r.children = r.children.map(me.reversePoly);
    }

    var L = Expression.getVariables(r);
    if (L && Types.isOpOfType(r, Types.SumOp) && Polynomial.polynomial_gpe(r, L)) {
      if (L.length == 1)
        r.children.reverse();
      else {
        // maintain order for each monomial degree
        var termsByDeg = [];
        r.children.forEach(c => {
          var deg = Types.toInteger(Polynomial.degree_monomial_gpe(c, L));
          var a = termsByDeg[deg];
          if (a)
            a.push(c);
          else
            termsByDeg[deg] = [c];
        });
        r.children = [];
        termsByDeg.reverse().forEach(t => r.children.push(...t));
      }
    }
    return r;
  }

  me.reverseODE = function(r) {
    if (Types.isUndefined(r))
      return r;
    if (Types.isOpOfType(r, Types.Equate)) {
      var split = Solve.splitEquation(r);
      return Solve.equate(me.reverseODE(split.lhs), me.reverseODE(split.rhs));
    } else if (Types.isOpOfType(r, Types.ProdOp)) {
      r.children = r.children.map(me.reverseODE);
    }

    if (Types.isOpOfType(r, Types.SumOp) && Calculus.isODE(r)) {
      r.children.reverse();
    }
    return r;
  }

  me.apply = function(output) {
    try {
      var newout = output.map(o => o.latex ? o : Expression.copy(o));
      newout = newout.map(me.outputPostProcess);
      newout = newout.map(me.reversePoly);
      newout = newout.map(me.reverseODE);
      newout = newout.map(me.humaniseNegatives);
      return newout;
    } catch (x) {
      console.log(x);
      return output;
    }
  }

  return me;
}

var classifier = new Classifier();
var lasterror = null;

Eval.setupEval();
Types.initConstants();
Complex.setupComplex();


// For debugging

function dpi(u) {
  return Array.isArray(u) ? u.map(dpi) : Expression.printInfix(u);
}

function dt(u) {
  return Expression.printTree(u);
}

function dfi(str, simp = true) {
  var u = parser.fromInfix(str);
  return simp ? das(u) : u;
}

function das(u) {
  return Array.isArray(u) ? u.map(Simplify.automatic_simplify) : Simplify.automatic_simplify(u);
}


var Polynomial = {};

(function(context) {
  context.linear_form = function(u, x) {
    var e, f, r;

    if (Types.isUndefined(u) || Types.isUndefined(x))
      return null;

    if (Expression.equal_expressions(u, x))
      return [Types.ONE, Types.ZERO];
    else if (Types.isNumber(u))
      return [Types.ZERO, u];
    else if (Types.isOpOfType(u, Types.ProdOp)) {
      if (Expression.free_of(u, x))
        return [Types.ZERO, u];
      else {
        var div = Rational.rational_div(u, x);
        if (Expression.free_of(div, x))
          return [div, Types.ZERO];
      }
      return null;
    } else if (Types.isOpOfType(u, Types.SumOp)) {
      e = Expression.operand(u, 1);
      f = context.linear_form(e, x)
      if (!f)
        return null;
      else {
        r = context.linear_form(Expression.diff(u, e), x);
        if (!r)
          return null;
        else
          return [Expression.sum(f[0], r[0]), Expression.sum(f[1], r[1])];
      }
    } else if (Expression.free_of(u, x))
      return [Types.ZERO, u];
    else
      return null;
  }

  context.quadratic_form = function(u, x) {
    var e, f, r;

    if (Types.isUndefined(u) || Types.isUndefined(x))
      return null;

    if (Expression.equal_expressions(u, x))
      return [Types.ZERO, Types.ONE, Types.ZERO];
    else if (Expression.equal_expressions(u, Expression.pow(x, Types.TWO)))
      return [Types.ONE, Types.ZERO, Types.ZERO];
    else if (Types.isNumber(u))
      return [Types.ZERO, Types.ZERO, u];
    else if (Types.isOpOfType(u, Types.ProdOp)) {
      if (Expression.free_of(u, x))
        return [Types.ZERO, Types.ZERO, u];
      else {
        var div = Rational.rational_div(u, x);
        if (Expression.free_of(div, x))
          return [Types.ZERO, div, Types.ZERO];
        div = Rational.rational_div(div, x);
        if (Expression.free_of(div, x))
          return [div, Types.ZERO, Types.ZERO];
      }
      return null;
    } else if (Types.isOpOfType(u, Types.SumOp)) {
      e = Expression.operand(u, 1);
      f = context.quadratic_form(e, x)
      if (!f)
        return null;
      else {
        r = context.quadratic_form(Expression.diff(u, e), x);
        if (!r)
          return null;
        else
          return [Expression.sum(f[0], r[0]), Expression.sum(f[1], r[1]),
            Expression.sum(f[2], r[2])];
      }
    } else if (Expression.free_of(u, x))
      return [Types.ZERO, Types.ZERO, u];
    else
      return null;
  }

  context.monomial_sv = function(u, x) {
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return false;
    else if (Types.isNumber(u))
      return true;
    else if (Expression.equal_expressions(u, x))
      return true;
    else if (Types.isOpOfType(u, Types.PowOp)) {
      var base = Expression.operand(u, 1);
      var exponent = Expression.operand(u, 2);
      if (Expression.equal_expressions(base, x) && Types.isPositiveIntegerValue(exponent))
        return true;
    } else if (Types.isOpOfType(u, Types.ProdOp) && Expression.num_operands(u) == 2) {
      return context.monomial_sv(Expression.operand(u, 1), x) &&
          context.monomial_sv(Expression.operand(u, 2), x);
    }
    return false;
  }

  context.polynomial_sv = function(u, x) {
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return false;
    else if (context.monomial_sv(u, x))
      return true;
    else if (Types.isOpOfType(u, Types.SumOp))
      return u.children.every(function(e) {
        return context.monomial_sv(e, x);
      });
    else
      return false;
  }

  context.degree_monomial_sv = function(u, x) {
    if (Types.isZero(u))
      return Types.NEGATIVEINFINITY;
    else if (Types.isNumber(u))
      return Types.ZERO;
    else if (Expression.equal_expressions(u, x))
      return Types.ONE;
    else if (Types.isOpOfType(u, Types.PowOp)) {
      var base = Expression.operand(u, 1);
      var exponent = Expression.operand(u, 2);
      if (Expression.equal_expressions(base, x) && Types.isPositiveIntegerValue(exponent))
        return exponent;
    } else if (Types.isOpOfType(u, Types.ProdOp) && Expression.num_operands(u) == 2) {
      var s = context.degree_monomial_sv(Expression.operand(u, 1), x);
      var t = context.degree_monomial_sv(Expression.operand(u, 2), x);
      if (!Types.isUndefined(s) && !Types.isUndefined(t))
        return t;
    }
    return Types.UNDEFINED;
  }

  context.degree_sv = function(u, x) {
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return Types.UNDEFINED;
    var d = context.degree_monomial_sv(u, x);
    if (!Types.isUndefined(d))
      return d;
    else if (Types.isOpOfType(u, Types.SumOp)) {
      d = Types.ZERO;
      for (var i = 1; i <= Expression.num_operands(u); ++i) {
        var f = context.degree_monomial_sv(Expression.operand(u, i), x);
        if (Types.isUndefined(f))
          return f;
        else if (Types.toInteger(f) > Types.toInteger(d))
          d = f;
      }
      return d;
    } else
      return Types.UNDEFINED;
  }

  // return [c,m] where c is the coefficient and m the degree
  context.coefficient_monomial_sv = function(u, x) {
    if (Types.isZero(u)) {
      return {
        coefficient: Types.ZERO,
        degree: Expression.construct(Types.ProdOp, null, [Types.MINUSONE, Types.INFINITY])
      };
    } else if (Types.isNumber(u)) {
      return {coefficient: u, degree: Types.ZERO};
    } else if (Expression.equal_expressions(u, x)) {
      return {coefficient: Types.ONE, degree: Types.ONE};
    } else if (Types.isOpOfType(u, Types.PowOp)) {
      var base = Expression.operand(u, 1);
      var exponent = Expression.operand(u, 2);
      if (Expression.equal_expressions(base, x) && Types.isPositiveIntegerValue(exponent))
        return {coefficient: Types.ONE, degree: exponent};
    } else if (Types.isOpOfType(u, Types.ProdOp) && Expression.num_operands(u) == 2) {
      var s = context.coefficient_monomial_sv(Expression.operand(u, 1), x);
      var t = context.coefficient_monomial_sv(Expression.operand(u, 2), x);
      if (!Types.isUndefined(s) && !Types.isUndefined(t))
        return {
          coefficient: Eval.ops[Types.ProdOp].eval(s.coefficient, t.coefficient),
          degree: t.degree
        };
    }
    return Types.UNDEFINED;
  }

  context.coefficient_sv = function(u, x, m) {
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return Types.UNDEFINED;
    var d = context.coefficient_monomial_sv(u, x);
    if (!Types.isUndefined(d))
      return Expression.equal_expressions(d.degree, m) ? d.coefficient : Types.ZERO;
    else if (Types.isOpOfType(u, Types.SumOp)) {
      for (var i = 1; i <= Expression.num_operands(u); ++i) {
        var f = context.coefficient_monomial_sv(Expression.operand(u, i), x);
        if (Types.isUndefined(f))
          return f;
        else if (Expression.equal_expressions(m, f.degree))
          return f.coefficient;
      }
      return Types.ZERO;
    } else
      return Types.UNDEFINED;
  }

  context.rational_sv = function(u, x) {
    if (!context.polynomial_sv(Rational.numerator(u)))
      return false;
    else
      return context.polynomial_sv(Rational.denominator(u));
  }

  context.monomial_gpe = function(u, x) {
    var i, S, base, exponent;
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return false;

    S = Array.isArray(x) ? x : [x];
    if (Types.setContains(u, S))
      return true;
    else if (Types.isOpOfType(u, Types.PowOp)) {
      base = Expression.operand(u, 1);
      exponent = Expression.operand(u, 2);
      if (Types.setContains(base, S) && Types.isInteger(exponent) && Types.toInteger(exponent) > 1)
        return true;
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      for (i = 1; i <= Expression.num_operands(u); ++i) {
        if (!context.monomial_gpe(Expression.operand(u, i), S))
          return false;
      }
      return true;
    }

    return Expression.set_free_of(u, S);
  }

  context.polynomial_gpe = function(u, x) {
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return false;
    var i, S;
    S = Array.isArray(x) ? x : [x];
    if (!Types.isOpOfType(u, Types.SumOp))
      return context.monomial_gpe(u, S);
    else {
      if (Types.setContains(u, S))
        return true;
      for (i = 1; i <= Expression.num_operands(u); ++i) {
        if (!context.monomial_gpe(Expression.operand(u, i), S))
          return false;
      }
    }
    return true;
  }

  context.coefficient_monomial_gpe = function(u, x) {
    var base, exponent, i, c, m, f;
    if (Expression.equal_expressions(u, x))
      return {coefficient: Types.ONE, degree: Types.ONE};
    else if (Types.isOpOfType(u, Types.PowOp)) {
      base = Expression.operand(u, 1);
      exponent = Expression.operand(u, 2);
      if (Expression.equal_expressions(base, x) && Types.isInteger(exponent) && Types.toInteger(exponent) > 1)
        return {coefficient: Types.ONE, degree: exponent};
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      m = Types.ZERO;
      c = u;
      for (i = 1; i <= Expression.num_operands(u); ++i) {
        f = context.coefficient_monomial_gpe(Expression.operand(u, i), x);
        if (Types.isUndefined(f))
          return Types.UNDEFINED;
        else if (!Types.isZero(f.degree)) {
          m = f.degree;
          c = Rational.rational_div(u, Expression.construct(Types.PowOp, null, [x, m]));
        }
      }
      return {coefficient: c, degree: m};
    }
    if (Expression.free_of(u, x))
      return {coefficient: u, degree: Types.ZERO};
    else
      return Types.UNDEFINED;
  }

  context.coefficient_gpe = function(u, x, j) {
    // returns:  The coefficient of x^j in the polynomial u
    var i, c, f;

    if (!Types.isOpOfType(u, Types.SumOp)) {
      f = context.coefficient_monomial_gpe(u, x);
      if (Types.isUndefined(f))
        return Types.UNDEFINED;
      else {
        if (Expression.equal_expressions(j, f.degree))
          return f.coefficient;
        else
          return Types.ZERO;
      }
    } else {
      if (Expression.equal_expressions(u, x)) {
        if (Types.isOne(j))
          return Types.ONE;
        else
          return Types.ZERO;
      }
      c = Types.ZERO;
      for (i = 1; i <= Expression.num_operands(u); ++i) {
        f = context.coefficient_monomial_gpe(Expression.operand(u, i), x);
        if (Types.isUndefined(f.coefficient))
          return Types.UNDEFINED;
        else if (Expression.equal_expressions(j, f.degree))
          c = Expression.sum(c, f.coefficient);
      }
      return c;
    }
  }

  context.degree_monomial_gpe = function(u, x) {
    var S = Array.isArray(x) ? x : [x];
    if (Types.isZero(u))
      return Types.NEGATIVEINFINITY;
    else if (Expression.set_free_of(u, S))
      return Types.ZERO;
    else if (Types.setContains(u, S))
      return Types.ONE;
    else if (Types.isOpOfType(u, Types.PowOp)) {
      var base = Expression.operand(u, 1);
      var exponent = Expression.operand(u, 2);
      if (Types.setContains(base, S) && Types.isInteger(exponent) && Types.toInteger(exponent) > 1)
        return exponent;
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      var deg = 0;
      for (var i = 1; i <= Expression.num_operands(u); ++i) {
        var opdeg = context.degree_monomial_gpe(Expression.operand(u, i), S);
        if (Types.isUndefined(opdeg))
          return Types.UNDEFINED;
        deg += Types.toInteger(opdeg);
      }
      return Types.asInteger(deg);
    }
    return Types.UNDEFINED;
  }

  context.degree_gpe = function(u, x) {
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return Types.UNDEFINED;
    if (Types.isOpOfType(u, Types.SumOp)) {
      var d = Types.ZERO;
      for (var i = 1; i <= Expression.num_operands(u); ++i) {
        var f = context.degree_monomial_gpe(Expression.operand(u, i), x);
        if (Types.isUndefined(f))
          return f;
        else if (Types.toInteger(f) > Types.toInteger(d))
          d = f;
      }
      return d;
    } else {
      return context.degree_monomial_gpe(u, x);
    }
  }

  context.leading_coefficient_gpe = function(u, x) {
    var deg = context.degree_gpe(u, x);
    if (!Types.isUndefined(deg))
      return context.coefficient_gpe(u, x, deg);
    else
      return Types.UNDEFINED;
  }

  context.coeff_var_monomial = function(u, v) {
    var S = Array.isArray(v) ? v : [v];
    if (!context.monomial_gpe(u, S))
      return Types.UNDEFINED;

    var variable;
    var coefficient;
    for (var i = 0; i < S.length; ++i) {
      if (!Expression.free_of(u, S[i])) {
        var cm = context.coefficient_monomial_gpe(u, S[i]);
        if (!Types.isUndefined(cm)) {
          if (Types.isOne(cm.degree))
            variable = S[i];
          else
            variable = Expression.construct(Types.PowOp, null, [S[i], cm.degree]);
          coefficient = Rational.rational_div(u, variable);
          return {coefficient: coefficient, variable: variable};
        }
      }
    }

    if (Expression.set_free_of(u, S))
      return {coefficient: u, variable: Types.ONE};
    else
      return Types.UNDEFINED;
  }

  context.collect_terms = function(u, S) {
    var f, combined, i, j, N, T, v;

    if (!Types.isOpOfType(u, Types.SumOp)) {
      if (Types.isUndefined(context.coeff_var_monomial(u, S)))
        return Types.UNDEFINED;
      else
        return u;
    } else {
      if (Types.setContains(u, S))
        return u;
      N = 0;
      T = [];
      for (i = 1; i <= Expression.num_operands(u); ++i) {
        f = context.coeff_var_monomial(Expression.operand(u, i), S);
        if (Types.isUndefined(f))
          return Types.UNDEFINED;
        else
          j = 1;
        combined = false;
        while (!combined && j <= N) {
          if (Expression.equal_expressions(f.variable, T[j][1])) {
            T[j] = [Expression.sum(f.coefficient, T[j][0]), f.variable];
            combined = true;
          }
          ++j;
        }
        if (!combined) {
          T[N + 1] = [f.coefficient, f.variable];
          N++;
        }
      }
      v = Types.ZERO;
      for (j = 1; j <= N; ++j) {
        v = Expression.sum(v, Expression.construct(Types.ProdOp, null, [T[j][0], T[j][1]]));
      }
      return v;
    }
  }

  context.variables = function(u, subsum, subprod) {
    var i, result;

    if (Types.reducesToNumber(u))
      result = [];
    else if (Types.isOpOfType(u, Types.PowOp)) {
      var exponent = Expression.exponent(u);
      if (Types.isInteger(u) && Types.toInteger(u) > 1)
        result = [Expression.operand(u, 1)];
    } else if (Types.isOpOfType(u, Types.SumOp)) {
      if (subprod) {
        result = [u];
      } else if (!subsum) {
        result = [];
        u.children.forEach(function(c) {
          var childvars = context.variables(c, true, false);
          childvars.forEach(function(v) {
            if (!Types.setContains(v, result))
              result.push(v);
          });
        });
      }
    } else if (!subprod && Types.isOpOfType(u, Types.ProdOp)) {
      result = [];
      u.children.forEach(function(c) {
        var childvars = context.variables(c, false, false);
        childvars.forEach(function(v) {
          if (!Types.setContains(v, result))
            result.push(v);
        });
      });
    } else {
      result = [u];
    }

    return result ? result : [u];
  }

  context.modcoefficients = function(u, x, m) {
    var modFactor = function(cf, m) {
      if (Types.isNumber(cf)) {
        if (Types.isInteger(cf))
          return Types.modInteger(cf, m);
        else if (Types.isRationalValue(cf))
          return Types.asFrac(KBR.add(KBI.mod(KBR.integerPart(cf.value), m.value), KBR.fracPart(cf.value)));
        else
          return Types.UNDEFINED;
      } else if (Types.isOpOfType(cf, Types.ProdOp)) {
        var a = Expression.operand(cf, 1);
        if (Types.isInteger(a))
          cf.children[0] = Types.modInteger(a, m);
        else if (Types.isRationalValue(a))
          return Types.asFrac(KBR.add(KBI.mod(KBR.integerPart(a.value), m.value), KBR.fracPart(a.value)));
        else if (Types.isNumber(a))
          return Types.UNDEFINED;
        return cf;
      } else if (Types.isOpOfType(cf, Types.SumOp)) {
        return cf.children.map(function(c) {
          return modFactor(cf, m);
        });
      }
      return Types.UNDEFINED;
    }

    if (Types.isUndefined(u) || Types.isUndefined(x))
      return Types.UNDEFINED;

    var result = Types.UNDEFINED;

    if (context.monomial_gpe(u, x)) {
      var cd = context.coefficient_monomial_gpe(u, x);
      var cf = cd.coefficient;
      var d = cd.degree;
      var xd = Expression.construct(Types.PowOp, null, [x, d]);
      result = Expression.prod(modFactor(cf, m), xd);
    } else if (Types.isOpOfType(u, Types.SumOp)) {
      result = Expression.copy(u);
      result.children = result.children.map(function(e) {
        return context.modcoefficients(e, x, m);
      });
    }

    return result;
  }

  context.polynomial_division = function(u, v, x, mod) {
    if (Types.isOne(v))
      return {quotient: u, remainder: Types.ZERO};
    else if (Types.isZero(v))
      return {quotient: Types.UNDEFINED, remainder: Types.UNDEFINED};
    // TODO ensure mod is prime if present
    var q = Types.ZERO;
    var r = u;
    var m = context.degree_gpe(r, x);
    var n = context.degree_gpe(v, x);
    if (Types.isUndefined(m) || Types.isUndefined(n))
      return {quotient: Types.UNDEFINED, remainder: Types.UNDEFINED};
    var lcv = context.leading_coefficient_gpe(v, x);
    while (Types.toInteger(m) >= Types.toInteger(n)) {
      var lcr = context.leading_coefficient_gpe(r, x);
      var s = Rational.rational_div(lcr, lcv);

      var xmn = Expression.construct(Types.PowOp, null, [x, Types.asInteger(Types.toInteger(m) - Types.toInteger(n))]);
      var sxmn = Expression.construct(Types.ProdOp, null, [s, xmn]);
      q = Simplify.automatic_simplify(Expression.sum(q, sxmn));

      var lcrxm = Expression.construct(Types.ProdOp, null, [lcr, Expression.construct(Types.PowOp, null, [x, m])]);
      var lcvxn = Expression.construct(Types.ProdOp, null, [lcv, Expression.construct(Types.PowOp, null, [x, n])]);

      var t1 = Simplify.automatic_simplify(Expression.diff(r, lcrxm));
      var t2 = Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null, [Expression.diff(v, lcvxn), sxmn]));
      t2 = Simplify.automatic_simplify(Expand.algebraic_expand(t2));
      r = Simplify.automatic_simplify(Expand.algebraic_expand(Expression.diff(t1, t2)));
      if (mod) {
        // turn all numbers into their modular equivalents in q and r
        q = Simplify.automatic_simplify(context.modcoefficients(q, x, mod));
        r = Simplify.automatic_simplify(context.modcoefficients(r, x, mod));
      }
      m = context.degree_gpe(r, x);
    }
    return {quotient: q, remainder: r};
  }

  context.quotient = function(u, v, x) {
    return context.polynomial_division(u, v, x).quotient;
  }

  context.remainder = function(u, v, x) {
    return context.polynomial_division(u, v, x).remainder;
  }

  context.gcd = function(u, v, x, mod) {
    var r;
    if (Types.isZero(u) && Types.isZero(v))
      return 0;
    if (Types.isOne(u) && Types.isOne(v))
      return 1;
    else {
      if (mod) {
        u = Simplify.automatic_simplify(context.modcoefficients(u, x, mod));
        v = Simplify.automatic_simplify(context.modcoefficients(v, x, mod));
      }
      while (!Types.isZero(v)) {
        if (Types.isUndefined(u))
          return Types.UNDEFINED;
        r = Simplify.automatic_simplify(context.remainder(u, v, x, mod));
        if (mod)
          r = Simplify.automatic_simplify(context.modcoefficients(r, x, mod));
        u = v;
        v = r;
      }
      var f = Expression.construct(Types.QuotOp, null,
          [Types.ONE, context.leading_coefficient_gpe(u, x)]);
      var result = Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null, [f, u]));
      result = Simplify.automatic_simplify(Expand.algebraic_expand(result));
      f = context.getintegercoefficientfactor_gpe(result, x);
      result = Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null, [f, result]));
      result = Simplify.automatic_simplify(Expand.algebraic_expand(result));
      if (mod)
        result = Simplify.automatic_simplify(context.modcoefficients(result, x, mod));
      return result;
    }
  }

  context.extended_euclidean_algorithm = function(u, v, x) {
    var gcd, A, B;
    var Ap, App, Bp, Bpp, q, r, A, B, c;

    if (Types.isZero(u) && Types.isZero(v))
      return [Types.ZERO, Types.ZERO, Types.ZERO];
    else {
      App = Types.ONE;
      Ap = Types.ZERO;
      Bpp = Types.ZERO;
      Bp = Types.ONE;
      while (!Types.isZero(v)) {
        var d = context.polynomial_division(u, v, x);
        q = Simplify.automatic_simplify(d.quotient);
        r = Simplify.automatic_simplify(d.remainder);
        A = Simplify.automatic_simplify(Expression.diff(App,
            Expression.construct(Types.ProdOp, null, [q, Ap])));
        B = Simplify.automatic_simplify(Expression.diff(Bpp,
            Expression.construct(Types.ProdOp, null, [q, Bp])));
        App = Ap;
        Ap = A;
        Bpp = Bp;
        Bp = B;
        u = v;
        v = r;
      }
      c = context.leading_coefficient_gpe(u, x);
      c = Expression.construct(Types.QuotOp, null, [Types.ONE, c]);
      App = Simplify.automatic_simplify(Expand.algebraic_expand(
          Expression.construct(Types.ProdOp, null, [App, c])));
      Bpp = Simplify.automatic_simplify(Expand.algebraic_expand(
          Expression.construct(Types.ProdOp, null, [Bpp, c])));
      u = Simplify.automatic_simplify(Expand.algebraic_expand(
          Expression.construct(Types.ProdOp, null, [u, c])));
      return [u, App, Bpp];
    }
  }

  context.rec_poly_div = function(u, v, L, Z) {
    var result;
    if (Types.isUndefined(u) || Types.isUndefined(v))
      return Types.UNDEFINED;

    if (Types.isOne(v)) {
      return {quotient: u, remainder: Types.ZERO};
    }

    if (L.length == 0) {
      var q = Expression.div(u, v);
      if (!Z || Types.isInteger(q))
        return {quotient: q, remainder: Types.ZERO};
      else
        return {quotient: Types.ZERO, remainder: u};
    } else {
      var x = L[0];
      var r = u;
      var m = context.degree_gpe(r, x);
      var n = context.degree_gpe(v, x);
      if (Types.isUndefined(m) || Types.isUndefined(n))
        return {quotient: Types.ZERO, remainder: u};
      var q = Types.ZERO;
      var lcv = context.leading_coefficient_gpe(v, x);
      while (m.value !== -Infinity && KBI.greaterThanOrEqualTo(Types.toInteger(m), Types.toInteger(n))) {
        var lcr = context.leading_coefficient_gpe(r, x);
        if (Types.isZero(lcr))
          break;
        var d = context.rec_poly_div(lcr, lcv, L.slice(1), Z);
        if (!Types.isZero(d.remainder))
          return {quotient: Expand.algebraic_expand(q), remainder: r};
        else {
          var c = d.quotient;
          var xmn = Expression.construct(Types.PowOp, null,
              [x, Types.asInteger(Types.toInteger(m) - Types.toInteger(n))]);
          var cxmn = Expression.prod(c, xmn);
          q = Expression.sum(q, cxmn);
          r = Simplify.automatic_simplify(Expand.algebraic_expand(Expression.diff(r, Expression.prod(v, cxmn))));
          m = context.degree_gpe(r, x);
        }
      }
      return {quotient: Expand.algebraic_expand(q), remainder: r};
    }
  }

  context.rec_quotient = function(u, v, L, Z) {
    var result = context.rec_poly_div(u, v, L, Z);
    if (result.quotient)
      return result.quotient;
    else
      return Types.UNDEFINED;
  }

  context.rec_remainder = function(u, v, L, Z) {
    var result = context.rec_poly_div(u, v, L, Z);
    if (result.remainder)
      return result.remainder;
    else
      return Types.UNDEFINED;
  }

  context.pseudo_division = function(u, v, x) {
    if (Types.isUndefined(u) || Types.isUndefined(v))
      return Types.UNDEFINED;
    if (Types.isZero(u))
      return {quotient: Types.ZERO, remainder: Types.ZERO};
    var p = Types.ZERO;
    var s = u;
    var m = context.degree_gpe(s, x);
    var n = context.degree_gpe(v, x);
    var dval = KBI.sub(KBI.add(Types.toInteger(m), 1), Types.toInteger(n));
    var delta = KBI.isNegative(dval) ? Types.ZERO : Types.asInteger(dval);
    var lcv = context.coefficient_gpe(v, x, n);
    var sigma = Types.ZERO;
    while (m.value !== -Infinity && KBI.greaterThanOrEqualTo(Types.toInteger(m), Types.toInteger(n))) {
      var lcs = context.coefficient_gpe(s, x, m);
      p = Expression.prod(p, lcv);
      var xmn = Expression.construct(Types.PowOp, null,
          [x, Types.asInteger(Types.toInteger(m) - Types.toInteger(n))]);
      var lcrxmn = Expression.construct(Types.ProdOp, null, [lcs, xmn]);
      p = Expression.sum(p, lcrxmn);

      var lcvs = Expression.prod(s, lcv);
      var lcsvxmn = Expression.prod(Expression.prod(v, lcs), xmn);
      s = Simplify.automatic_simplify(Expand.algebraic_expand(
          Expression.diff(lcvs, lcsvxmn)));
      sigma = Expression.sum(sigma, Types.ONE);
      m = context.degree_gpe(s, x);
    }
    var delsig = Expression.diff(delta, sigma);
    var lcvpow = Expression.pow(lcv, delsig);

    var q = Simplify.automatic_simplify(Expand.algebraic_expand(
        Expression.prod(lcvpow, p)));
    var r = Simplify.automatic_simplify(Expand.algebraic_expand(
        Expression.prod(lcvpow, s)));

    return {quotient: q, remainder: r};
  }

  context.pseudo_quotient = function(u, v, x) {
    var result = context.pseudo_division(u, v, x);
    if (result.quotient)
      return result.quotient;
    else
      return Types.UNDEFINED;
  }

  context.pseudo_remainder = function(u, v, x) {
    var result = context.pseudo_division(u, v, x);
    if (result.remainder)
      return result.remainder;
    else
      return Types.UNDEFINED;
  }

  context.mv_poly_gcd = function(u, v, L, Z) {
    if (Types.isUndefined(u) || Types.isUndefined(v))
      return Types.UNDEFINED;
    if (Types.isZero(u))
      return context.normalize(v, L, Z);
    else if (Types.isZero(v))
      return context.normalize(u, L, Z);
    else
      return context.normalize(context.mv_poly_gcd_rec(u, v, L, Z), L, Z);
  }

  context.mv_poly_gcd_rec = function(u, v, L, Z) {
    // Input
    // u, v : non-zero multivariate polynomials with variables in L and coefficients in Z or Q;
    // L : a list of symbols;
    // Output
    // gcd(u,v) (notnormalized)
    var r, pp_r, cont_r;

    if (L.length == 0) {
      if (Z && Types.isInteger(u) && Types.isInteger(v))
        return Types.asInteger(Eval.gcd(Types.toInteger(u), Types.toInteger(v)));
      else
        return Types.ONE;
    }

    var x = L[0];
    var R = L.slice(1);
    var cont_u = context.content(u, x, R, Z);
    var cont_v = context.content(v, x, R, Z);
    var d = context.mv_poly_gcd_rec(cont_u, cont_v, R);
    var pp_u = context.rec_quotient(u, cont_u, L, Z);
    var pp_v = context.rec_quotient(v, cont_v, L, Z);
    while (!Types.isZero(pp_v)) {
      r = context.pseudo_remainder(pp_u, pp_v, x);
      if (Types.isZero(r))
        pp_r = Types.ZERO;
      else {
        cont_r = context.content(r, x, R, Z);
        pp_r = context.rec_quotient(u, cont_r, L, Z);
      }
      pp_u = pp_v;
      pp_v = pp_r;
    }

    return Simplify.automatic_simplify(Expand.algebraic_expand(Expression.prod(d, pp_u)));
  }

  context.getcoefficients = function(u, x) {
    // confirm is polynomial
    // each child is a monomial - get it's coefficient
    // make sure all rationals
    if (Types.isUndefined(u) || Types.isUndefined(x))
      return Types.UNDEFINED;

    var coeffs = [];

    if (context.monomial_gpe(u, x)) {
      var dm = context.degree_monomial_gpe(u, x);
      coeffs = dm ? new Array(Types.toInteger(dm)).fill(Types.ZERO) : [];
      coeffs.unshift(context.coefficient_monomial_gpe(u, x).coefficient);
    } else if (Types.isOpOfType(u, Types.SumOp)) {
      var d = context.degree_gpe(u, x);
      for (var i = Types.toInteger(d); i >= 0; --i)
        coeffs.push(context.coefficient_gpe(u, x, Types.asInteger(i)));
    } else
      return Types.UNDEFINED;

    return coeffs;
  }

  context.getintegercoefficientfactor_gpe = function(u, x) {
    var coeffs = context.getcoefficients(u, x);

    if (Types.isUndefined(coeffs))
      return Types.UNDEFINED;

    var lcm = 1;
    for (var i = 0; i < coeffs.length; ++i) {
      var c = coeffs[i];
      if (Types.isOpOfType(c, Types.ProdOp)) {
        c = Expression.operand(c, 1);
        if (!Types.isNumber(c))
          continue;
      } else if (Types.isOpOfType(c, Types.SumOp)) {
        c = Simplify.factor_out(c);
        c = Expression.operand(c, 1);
        if (!Types.isNumber(c))
          continue;
      } else if (Types.isOperator(c))
        c = Types.ONE;
      if (!Types.isRationalValue(c))
        continue;
      if (Types.isZero(c))
        continue;
      lcm = KBI.lcm(lcm, Types.isInteger(c) ? 1 : c.value.d);
    }

    return Types.asInteger(lcm);
  }

  context.multi_square_free_factor = function(u, L, x, Z) {
    var c, d, P, R, F, j, G, s;

    u = Simplify.automatic_simplify(u);
    if (Types.isZero(u))
      return u;
    else {
      c = context.leading_coefficient_gpe(u, x);
      if (!Types.reducesToNumber(c))
        return u;
      u = Expand.algebraic_expand(Transform.simplifyall(Expand.algebraic_expand(Rational.rational_div(u, c))));
      P = Types.ONE;
      d = Expand.algebraic_expand(Transform.simplifyall(Expand.algebraic_expand(Calculus.derivative(u, x))));
      R = context.sub_resultant_gcd(u, d, L, Z);
      F = context.pseudo_quotient(u, R, x);
      j = 1;
      while (!Types.isOne(R)) {
        G = context.sub_resultant_gcd(R, F, L, Z);
        s = context.pseudo_quotient(F, G, x);
        P = Expression.prod(P, Expression.construct(Types.PowOp, null, [s, Types.asInteger(j)]));
        R = context.pseudo_quotient(R, G, x);
        F = G;
        if (Types.isUndefined(F))
          throw "Error";
        if (++j > 30)
          return u;	// taking too long
      }
      P = Expression.prod(P, Expression.construct(Types.PowOp, null, [F, Types.asInteger(j)]));
      return Expression.prod(c, P);
    }
  }

  context.square_free_factor = function(u, x) {
    var L = Expression.getVariables(u);
    if (!context.polynomial_gpe(u, L))
      return u;

    if (L.length > 1)
      return context.multi_square_free_factor(u, L, x, true);

    var c, d, P, R, F, j, G, s;

    u = Simplify.automatic_simplify(u);
    if (Types.isZero(u))
      return u;
    else {
      c = context.leading_coefficient_gpe(u, x);
      if (Types.isUndefined(c))
        return u;	// not a polynomial
      u = Expand.algebraic_expand(Transform.simplifyall(Expand.algebraic_expand(Rational.rational_div(u, c))));
      P = Types.ONE;
      d = Expand.algebraic_expand(Transform.simplifyall(Expand.algebraic_expand(Calculus.derivative(u, x))));
      R = Simplify.automatic_simplify(context.gcd(u, d, x));
      F = context.quotient(u, R, x);
      j = 1;
      while (!Types.isOne(R)) {
        G = context.gcd(R, F, x);
        s = context.quotient(F, G, x);
        P = Expression.prod(P, Expression.construct(Types.PowOp, null, [s, Types.asInteger(j)]));
        R = Simplify.automatic_simplify(context.quotient(R, G, x));
        F = G;
        if (Types.isUndefined(F)) {
          console.log("F undefined in square free factor of " + Expression.printInfix(u) + " [" +
              Expression.printInfix(x) + "]");
          return u;
        }
        ++j;
      }
      P = Expression.prod(P, Expression.construct(Types.PowOp, null, [F, Types.asInteger(j)]));
      return Expression.prod(c, P);
    }
  }

  context.berlekamp_factor = function(u, x, p) {
    // u: a monic, square-free polynomial in Zp[x]
    // x: a symbol
    // p: a prime > 1
    // returns The set of irrreducible factors of u;
    var n = context.degree_gpe(u, x);
    if (Types.isZero(n) || Types.isOne(n))
      return [u];
    else {
      var R = R_matrix(u, x, n, p);
      var S = context.auxiliary_basis(x, n, p, R);
      if (Expression.num_operands(S) == 1)
        return [u]
      else
        return context.find_factors(u, S, x, p);
    }
  }

  context.R_matrix = function(u, x, n, p) {
    // u: a monic, square-free polynomial in Zp[x];
    // x: a symbol;
    // n: a positive integer representing deg(u);
    // p: a prime > 1;

    // create R : an n by n matrix with entries in Zp;
    var mod = function(n, q) {
      // 		return KBI.mod(n, q);
      return KBI.mod(KBI.add(KBI.mod(n, q), q), q);
    }

    var symmod = function(n, q) {
      var r = ((n % q) + q) % q;
      return r > q / 2 ? r - q : r;
    }

    var a = [1, -3, -1, -3, 1, -3, 1];
    var q = 11;
    //var a = [4, 1, 0, 0, 0, 1, 1];
    //var q = 5;
    var n = a.length - 1;
    var Q = [];
    var r = new Array(n).fill(0);
    r[0] = 1;
    Q[0] = r.slice(0);
    Q[0][0] = 0;
    var s = [];
    for (var m = 1; m <= (n - 1) * q; ++m) {
      s = [mod(-r[n - 1] * a[0], q)];
      for (var j = 1; j < n; ++j)
        s[j] = mod(r[j - 1] - r[n - 1] * a[j], q);
      r = s;
      if (m % q == 0) {
        var k = m / q;
        Q[k] = r.slice();
        Q[k][k] = mod(Q[k][k] - 1, q);
      }
    }
    console.log(Q);

    var str = "{";
    for (var i = 0; i < Q.length; ++i) {
      if (i)
        str += "\n";
      str += "{";
      for (var j = 0; j < n; ++j) {
        str += Q[j][i] + (j < n - 1 ? "," : "");
      }
      str += "}";
      if (i < Q.length - 1)
        str += ",";
    }
    str += "}";

    console.log(str);
  }

  context.auxiliary_basis = function(x, n, p, R) {
    // output a list containing a basis of one or more auxiliary polynomials
    var R;	// an n by n matrix with entries in Zp
    var i, j, pivot_found, a, k, f, l, s, e, c;

    var P = [];
    for (i = 1; i <= n; ++i)
      P[i] = 0;
    var S = [];
    for (j = 1; j <= n; ++j) {
      i = 1;
      pivot_found = false;
      while (!pivot_found && i <= n) {
        if (R[i][j] != 0 && P[i] == 0)
          pivot_found = true;
        else
          i = i + 1;
      }
      if (pivot_found) {
        P[i] = j;
        a = context.multiplicative_inverse_p(R[i, j], p);
        for (l = 1; l <= n; ++l)
          R[i, l] = Irem(a * R[i, l], p);
        for (k = 1; k <= n; ++k) {
          if (k != i) {
            f = R[k, j];
            for (l = 1; l <= n; ++l)
              R[k, l] = Irem(R[k, l] - f * R[i, l], p);
          }
        }
      } else if (!pivot_found) {
        s = x ^ (j - 1);
        for (l = 1; l <= j - 1; ++l) {
          e = 0;
          i = 1;
          while (e == 0 && i <= n) {
            if (l == P[i])
              e = i;
            else
              i = i + 1;
          }
          if (e > 0) {
            c = Irem(-R[e, j], p);
            s = s + c * x ^ (l - 1);
          }
          S = Join(S, [s]);
        }
      }
    }
    return S;
  }

  context.find_factors = function(u, S, x, p) {
    // u : a monic square-free polynomial in Zp[x];
    // S : a list containing a basis of one or more auxiliary
    // polynomials where the first polynomial in S is b = 1
    // x : a symbol
    // p : a prime ≥ 2
    // Output: The set of irrreducible factors of u
    var k, b, old_factors, i, w, j, g, q;
    var r = S.length;
    var factors = [u];
    for (k = 1; k < r; ++k) {
      b = S[k];
      old_factors = factors;
      for (i = 0; i < old_factors.length; ++i) {
        w = old_factors[i];
        j = 0;
        while (j <= Types.toInteger(p) - 1) {
          g = context.gcd(Expression.diff(b, Types.asInteger(j)), w, x, p);
          if (Types.isOne(g))
            ++j;
          else if (Expression.equal_expressions(g, w))
            j = Types.toInteger(p);
          else {
            factors.splice(factors.indexOf(w), 1);	// remove w
            q = Expression.operand(context.polynomial_division(w, g, x, p), 1);
            factors.push(g);
            factors.push(q);
            if (factors.length == r)
              return factors;
            else {
              j = j + 1;
              w = q;
            }
          }
        }
      }
    }
  }

  context.factorise = function(u, x, allownonZ) {
    var saveu = Simplify.automatic_simplify(Expression.copy(u));
    if (!context.polynomial_gpe(u, x)) {
      u = Expand.algebraic_expand(u);
      if (!context.polynomial_gpe(u, x))
        return u;
    }
    var sqfree = Simplify.automatic_simplify(Simplify.factor_out(context.square_free_factor(u, x), allownonZ));
    var terms = [];
    var free = Types.ONE;
    var coeffs;
    var i, j;

    var addterm = function(v, terms) {
      if (Expression.free_of(v, x))
        free = Expression.prod(free, v);
      else if (Types.isOpOfType(v, Types.PowOp)) {
        var term = Expression.operand(v, 1);
        var pow = Expression.operand(v, 2);
        terms.push({term: term, pow: pow});
      } else {
        if (Expression.free_of(v, x))
          free = Expression.prod(free, v);
        else
          terms.push({term: v, pow: Types.ONE});
      }
    }
    // TODO handle free rational?
    var horner = function(p, x) {
      return p.reduce((a, c) => KBI.add(KBI.mul(a, x), c), 0);
    }

    if (Types.isOpOfType(sqfree, Types.ProdOp)) {
      for (i = 1; i <= Expression.num_operands(sqfree); ++i)
        addterm(Expression.operand(sqfree, i), terms);
    } else if (Types.isOpOfType(sqfree, Types.PowOp)) {
      addterm(sqfree, terms);
    } else {
      if (Expression.free_of(u, x))
        free = Expression.prod(free, u);
      else
        terms.push({term: u, pow: Types.ONE});
    }

    var diff = function(x, r) {
      if (Types.isFraction(r))
        return Expression.diff(Expression.prod(x, Rational.denominator(r)), Rational.numerator(r));
      else
        return Expression.diff(x, r);
    }

    var result = Types.ONE;
    for (i = 0; i < terms.length; ++i) {
// 			if (context.linear_form(terms[i].term, x))
// 			{
// 				result = Expression.prod(result, Expression.pow(Simplify.factor_out(terms[i].term, allownonZ),
// 					terms[i].pow));
// 				continue;
// 			}
      // check each term
      coeffs = context.getcoefficients(terms[i].term, x);

      // are they all integers or fractions?
      var cansolve = coeffs.every(function(e) {
        return Types.isRationalValue(e);
      });
      var n = coeffs.length;
      var candidates = [];
      var roots = [];
      if (cansolve) {
        // check powers
        var nonzeroindices = coeffs.reduce((a, e, i) => !Types.isZero(e) ? a.concat(i) : a, []);
        var reducepowers = nonzeroindices.length > 2 ||
            (nonzeroindices.length == 2 && nonzeroindices.indexOf(0) == -1);
        var powgcd = reducepowers ? nonzeroindices.reduce(Eval.gcd) : 1;
        if (powgcd > 1) {
          coeffs = coeffs.filter(e => !Types.isZero(e));
        }
        // if gcd != 1, then we can change variable...

        // transform monic with integer coefficients
        // our original polynomial {a_i, i=0,n} becomes {a_i.a_n^(n-i-1), i=0,n}
        // with javascript indexing this {a[n-i], i=0,n} becomes {a[n-i].a[0]^(n-i-1), i=0,n}
        var factor = context.getintegercoefficientfactor_gpe(terms[i].term, x);
        if (!Types.isOne(factor)) {
          coeffs = coeffs.map(c => Expression.prod(c, factor));
          terms[i].term = Expression.prod(terms[i].term, factor);
          free = Rational.rational_div(free, factor);
        }
        var a_0 = coeffs[0];
        var adjcoeffs = coeffs.map(function(c, i) {
          return Eval.ops[Types.ProdOp].eval(c, Eval.ops[Types.PowOp].eval(a_0, Types.asInteger(i - 1)));
        }).map(Types.toInteger);

        // test for linear factors using rational roots theorem
        candidates = Factors.divisors(Math.abs(adjcoeffs[adjcoeffs.length - 1]));
        for (j = 0; j < candidates.length; ++j) {
          var c = candidates[j];
          var res = horner(adjcoeffs, c);
          if (res == 0)
            roots.push(Types.asFrac(c, Types.toInteger(a_0)));
          res = horner(adjcoeffs, -c);
          if (res == 0)
            roots.push(Types.asFrac(-c, Types.toInteger(a_0)));
          if (roots.length == n - 1) {
            break;
          }
        }
        ;
        var root = Types.ONE;
        if (powgcd > 1) {
          root = Simplify.automatic_simplify(
              roots.reduce((a, r) => Simplify.factor_out(
                  Expression.prod(a, diff(Expression.pow(x, Types.asInteger(powgcd)), r))), Types.ONE), allownonZ);
          // 				root = Simplify.automatic_simplify(
          // 					roots.reduce((a, r) => Expression.construct(Types.ProdOp, null,
          // 						[a, diff(Expression.pow(x, Types.asInteger(powgcd)), r)]), Types.ONE));
        } else {
          root = Simplify.automatic_simplify(
              roots.reduce((a, r) => Simplify.factor_out(Expression.prod(a, diff(x, r))), Types.ONE), allownonZ);
        }
        var left = context.quotient(Expand.algebraic_expand(terms[i].term), Expand.algebraic_expand(root), x);
        terms[i].term = Expression.prod(left, root);

        coeffs = context.getcoefficients(left, x);
        if (coeffs.length > 2) {
          var nonzeroindices = coeffs.reduce((a, e, i) => !Types.isZero(e) ? a.concat(i) : a, []);
          var reducepowers = nonzeroindices.length > 2 ||
              (nonzeroindices.length == 2 && nonzeroindices.indexOf(0) == -1);
          var powgcd = reducepowers ? nonzeroindices.reduce(Eval.gcd) : 1;
          if (powgcd > 1) {
            coeffs = coeffs.filter(e => !Types.isZero(e));
          }
          // if gcd != 1, then we can change variable...

          // transform monic with integer coefficients
          // our original polynomial {a_i, i=0,n} becomes {a_i.a_n^(n-i-1), i=0,n}
          // with javascript indexing this {a[n-i], i=0,n} becomes {a[n-i].a[0]^(n-i-1), i=0,n}
          var factor = context.getintegercoefficientfactor_gpe(left, x);
          if (!Types.isOne(factor)) {
            coeffs = coeffs.map(c => Expression.prod(c, factor));
            left = Expression.prod(left, factor);
            free = Rational.rational_div(free, factor);
          }
          var a_0 = coeffs[0];
          var adjcoeffs = coeffs.map(function(c, i) {
            return Eval.ops[Types.ProdOp].eval(c, Eval.ops[Types.PowOp].eval(a_0, Types.asInteger(i - 1)));
          }).map(Types.toInteger);
          var newtry = Solve.bairstowRoots(adjcoeffs);
          newtry.forEach(t => {
            if (t.length == 2) {
              t[0] = parseFloat(t[0].toFixed(8));
              t[1] = parseFloat(t[1].toFixed(8));
              if (t[0] % 1 === 0 && t[1] % 1 === 0) {
                var a2 = a_0.value * a_0.value;
                var a1 = a_0.value * t[0];
                var a0 = t[1];
                var gcd = [a0, a1, a2].reduce(Eval.gcd);
                a2 /= gcd;
                a1 /= gcd;
                a0 /= gcd;
                var c = Expression.sumAll([
                  Expression.prod(Types.asInteger(a2), Expression.pow(x, Types.TWO)),
                  Expression.prod(Types.asInteger(a1), x),
                  Types.asInteger(a0)
                ]);
                var d = context.polynomial_division(left, c, x);
                if (Types.isZero(d.remainder)) {
                  left = d.quotient;
                  root = Expression.prod(root, c);
                  terms[i].term = Expression.prod(root, left);
                }
              }
            }
            // TODO linear root?
          });
        }
      } else {
        /*
					Better algorithm
					- set all but one the first variable to small primes and factor as a polynomial
					- test each factor by replacing the constants by a dividing substituted variable
					- repeat for all other variables
				*/
        var vars = Expression.getVariables(terms[i].term);
        if (vars.length >= 1) {
          var primes = [2, 3, 5, 7, 11, 13, 17, 19].slice(0, vars.length - 1);
          var candidates = [];
          for (var k = 0; k < vars.length; ++k) {
            var u = Expression.copy(terms[i].term);
            var R = vars.slice(0);
            var x = R.splice(k, 1)[0];
            // replace all occurrences of g in r with v
            for (j = 0; j < R.length; ++j) {
              u = Simplify.automatic_simplify(Expression.substitute(u, R[j], Types.asInteger(primes[j])));
              u = Simplify.automatic_simplify(u);
              if (Types.isZero(u)) {
                candidates.push(Expression.diff(R[j], Types.asInteger(primes[j])));
                continue;
              }
            }
            u = Simplify.automatic_simplify(u);
            if (Types.isZero(u)) {
              continue;
            }
            // TODO what does u = 0 imply?
            var f = Expression.equal_expressions(u, saveu) ? u : context.factorise(u, x, allownonZ);
            var ftypes = Expression.get_binomial_factors(f, x);
            var binomterms = ftypes.binom;
            var m = Types.isInteger(ftypes.constant) ? Types.toInteger(ftypes.constant) : 1;
            binomterms.forEach(l => {
              if (Types.isInteger(l[1])) {
                var n = Types.toInteger(l[1]);
                candidates.push(Expression.sum(l[0], l[1]));
                primes.forEach((p, idx) => {
                  var gcd = Eval.gcd(n, p);
                  if (gcd > 1) {
                    var c = Expression.sum(l[0], Expression.prod(Types.asInteger(n / gcd), R[idx]));
                    candidates.push(c);
                  } else if (m != 1) {
                    gcd = Eval.gcd(m * n, p);
                    if (gcd > 1) {
                      var c = Expression.sum(
                          Expression.prod(Types.asInteger(m), l[0]), Expression.prod(Types.asInteger(m * n / gcd), R[idx]));
                      candidates.push(c);
                    }
                  }
                });
              }
            });
          }

          candidates = candidates.filter((c, i, a) =>
              i === a.findIndex(e => Expression.equal_expressions(c, e)));
          candidates = candidates.map(c => Simplify.extractCF(c)[1]);
          var roots = [];
          for (k = 0; k < candidates.length; ++k) {
            var f = candidates[k];
            do {
              res = context.rec_poly_div(terms[i].term, f, vars, true);
              if (Types.isZero(res.remainder)) {
                roots.push(f);
                terms[i].term = res.quotient;
              }
            } while (Types.isZero(res.remainder));
            if (roots.length == n - 1)
              break;
          }
          ;
          if (roots.length) {
            var root = Types.ONE;
            root = Simplify.automatic_simplify(
                roots.reduce((a, r) => Simplify.factor_out(Expression.prod(a, r)), Types.ONE), allownonZ);
            terms[i].term = Expression.prod(context.factorise(terms[i].term, x, allownonZ), root,
                Types.reducesToNumber(terms[i].term));
          }
        }
      }
      // if not, no further simplification is possible (except for enhanced factor out)
      var pow = Expression.pow(Simplify.factor_out(terms[i].term, allownonZ), terms[i].pow);
      result = Expression.prod(result, pow);
      // 		result = Expression.prod(result, Expression.pow(terms[i].term, terms[i].pow));
    }
    result = Expression.prod(free, result, Types.reducesToNumber(free));

    return result;
  }

  context.get_secondary_variables = function(p, x) {
    if (Types.isUndefined(p) || Types.isUndefined(x))
      return Types.UNDEFINED;
    var vars = Expression.getVariables(p);
    vars.removeElem(x);
    return vars;
  }

  context.normalize = function(v, L, Z) {
    var lc = context.leading_coefficient_gpe(v, L.length ? L[0] : []);
    if (Z && Types.isNegativeIntegerValue(lc))
      return Expression.prod(Types.MINUSONE, v);
    else
      return v;
  }

  context.content = function(p, x, R, Z) {
    var coeffs = context.getcoefficients(p, x);
    if (coeffs.length == 0)
      return Types.ONE;
    var gcd = coeffs.reduce(function(a, b) {
      var g = context.mv_poly_gcd(a, b, R, Z);
      return Types.isUndefined(g) ? Types.ONE : g;
    })
    return gcd;
  }

  context.pp = function(p, x, R, Z) {
    var c = context.content(p, x, R, Z);
    return context.polynomial_division(p, c, x).quotient;
  }

  context.content_sr = function(p, x, L, Z) {
    var coeffs = context.getcoefficients(Expand.algebraic_expand(p), x);
    if (coeffs.length == 0)
      return Types.ONE;
    var gcd = coeffs.reduce(function(a, b) {
      var g = context.sub_resultant_gcd(a, b, L, Z);
      return Types.isUndefined(g) ? Types.ONE : g;
    })
    return gcd;
  }

  context.pp_sr = function(p, x, L, Z) {
    var c = context.content_sr(p, x, L, Z);
    return context.polynomial_division(p, c, x).quotient;
  }

  /*
	Factor
		1. square free factor
		2. for each term
			a. factor out
			b. special forms (difference of powers [including exp forms], and symbolic quadratic)
			c. if can be transformed to integer coefficients
				i. test integer factors using the rational root theorem
				ii. bairstow's method to find factors
				(check (m + r)^2?)
				iii. convert real factors to integer by multiplying together as necessary
				iv. reverse transform

	NSolve
		Just do steps 1 & 2c

	Generalised quadratic solution
	Generalised cubic solution?  Probably too messy to be worthwhile

	Transform x -> x / a_n
						v -> a_n^(n-1) v

	Consider term i
			a_i x^i -> (a_i/a_n^i).x^i.a_n^(n-1) = a_i.a_n^(n-i-1).x^i
	and hence has integer coefficient

	So our original polynomial {a_i, i=0,n} becomes {a_i.a_n^(n-i-1), i=0,n}

	Solve over integers, then transform back
		x->a_n.x, v-> 1/a^(n-1).v
	and factor out and Simplify

	Example: (2x+1)(x-2) = 2x^2-3x-2 has solutions x=2,-1/2

	substitute x = v/2 to get
		2(v^2)/4 - 3v/2 - 2 = 0
		v^2/2 - 3v/2 - 2 = 0
	multiply through by 2^(2-1) = 2 to get
		4v^2/4 - 6v/2 - 4 = 0
		v^2 - 3v - 4 = 0
	integer coefficients, so can solve
		(v-4)(v+1) = 0
		so v = 4,-1
	transform back
		x = v/2,
		so x = 2,-1/2 as required
		and factors are (x-2)(2x+1)
	need to consider any constant multiplier as well


	Alt:

	start with { a_i }
	x = v / a_n
	then multiply by a_n^(n-1)
	to get
	{ a_(n-j).a_n^(j-1) }
	*/


  context.sub_resultant_gcd = function(u, v, L, Z) {
    // Input
    // u,v: multivariate polynomials with variables in L and coefficients in Z or Q
    // L: list of symbols
    // Z: true if Z, else Q
    // Output
    // gcd(u,v)
    if (Types.isZero(u))
      return context.normalize(v, L, Z);
    else if (Types.isZero(v))
      return context.normalize(u, L, Z);
    else
      return context.normalize(context.sub_resultant_gcd_rec(u, v, L, Z), L, Z);
  }

  context.sub_resultant_gcd_rec = function(u, v, L, Z) {
    // Input
    // u,v: multivariate polynomials with variables in L and coefficients in Z or Q
    // L: list of symbols
    // Z: true if Z, else Q
    // Output
    // gcd(u,v) (not normalized)

    if (Types.isOne(u) || Types.isOne(v)) {
      return Types.ONE;
    }

    if (Types.isUndefined(u) || Types.isUndefined(v)) {
      return Types.UNDEFINED;
    }

    if (L.length == 0) {
      if (Z)
        return Types.asInteger(Eval.gcd(u, v));
      else // Q
        return Types.ONE;
    }

    var x = L[0];
    var U, V;
    if (Types.toInteger(context.degree_gpe(u, x)) >= Types.toInteger(context.degree_gpe(v, x))) {
      U = u;
      V = v;
    } else {
      U = v;
      V = u
    }
    var R = L.slice(1);
    var cont_u = context.content_sr(U, x, R, Z);
    var cont_v = context.content_sr(V, x, R, Z);
    var d = context.sub_resultant_gcd_rec(cont_u, cont_v, R, Z);
    U = context.rec_quotient(U, cont_u, L, Z);
    V = context.rec_quotient(V, cont_v, L, Z);
    var g = context.sub_resultant_gcd_rec(
        context.leading_coefficient_gpe(U, x), context.leading_coefficient_gpe(V, x), R, Z);
    var i = 1;
    while (!Types.isZero(V)) {
      var r = context.pseudo_remainder(U, V, x);
      if (!Types.isZero(r)) {
        var delta, psi, beta;
        if (i == 1) {
          delta = Types.asInteger(Types.toInteger(context.degree_gpe(U, x)) -
              Types.toInteger(context.degree_gpe(V, x)) + 1);
          psi = Types.MINUSONE;
          beta = Expression.pow(Types.MINUSONE, delta);
        } else if (i > 1) {
          var deltap = delta;
          delta = Types.asInteger(Types.toInteger(context.degree_gpe(U, x)) -
              Types.toInteger(context.degree_gpe(V, x)) + 1);
          var f = context.leading_coefficient_gpe(U, x);
          var t1 = Expression.pow(Expression.prod(Types.MINUSONE, f), Expression.diff(deltap, Types.ONE));
          t1 = Expand.algebraic_expand(t1);
          var t2 = Expression.pow(psi, Expression.diff(deltap, Types.TWO));
          t2 = Expand.algebraic_expand(t2);
          psi = context.rec_quotient(t1, t2, R, Z);
          beta = Expand.algebraic_expand(Expression.prod(
              Expression.prod(Types.MINUSONE, f), Expression.pow(psi, Expression.diff(deltap, Types.ONE))));
        }
        U = V;
        V = context.rec_quotient(r, beta, L, Z);
        i++;
      } else	// r = 0
      {
        U = V;
        V = r
      }
    }
    var s = context.rec_quotient(context.leading_coefficient_gpe(U, x), g, R, Z);
    var W = context.rec_quotient(U, s, L, Z);
    var cont_W = context.content_sr(W, x, R, Z);
    var pp_W = context.rec_quotient(W, cont_W, L, Z);
    return Expand.algebraic_expand(Expression.prod(d, pp_W));
  }
})(Polynomial);


var Rational = {};

(function(context) {
  context.denominator = function(u) {
    if (lasterror)
      return Types.UNDEFINED;

    // 	if (Types.isOperator(u) && !Types.isOpOfType(u, Types.SumOp))
    // 	{
    // 		// don't do this for sum because of the recursion
    // 		u = context.rationalise_expression(u);
    // 	}


    if (Types.isFraction(u))
      return Types.asInteger(u.value.d);
    else if (Types.isOpOfType(u, Types.QuotOp)) {
      return Expression.operand(u, 2);
    } else if (Types.isOpOfType(u, Types.PowOp)) {
      var e = Expression.exponent(u);
      if (Types.isNumber(e)) {
        if (Types.isNegativeRealValue(e))
          return Simplify.automatic_simplify(Simplify.simplify_power(
              Expression.construct(Types.PowOp, null, [u, Types.MINUSONE])));
        else
          return Types.ONE;
      }
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      var v = Expression.operand(u, 1);
      var w = Expression.dropfirstterm(u);
      return Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null,
          [context.denominator(v), context.denominator(w)]));
    }

    return Types.ONE;
  }

  context.numerator = function(u) {
    if (lasterror)
      return Types.UNDEFINED;

    //  	if (Types.isOperator(u) && !Types.isOpOfType(u, Types.SumOp))
    // 	{
    // 		// don't do this for sum because of the recursion
    // 		u = context.rationalise_expression(u);
    // 	}

    if (Types.isFraction(u))
      return Types.asInteger(u.value.n);
    else if (Types.isOpOfType(u, Types.QuotOp)) {
      return Expression.operand(u, 1);
    } else if (Types.isOpOfType(u, Types.PowOp)) {
      var e = Expression.exponent(u);
      if (Types.isNumber(e)) {
        if (Types.isNegativeRealValue(e))
          return Types.ONE;
        else
          return u;
      }
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      var v = Expression.operand(u, 1);
      var w = Expression.dropfirstterm(u);
      return Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null,
          [context.numerator(v), context.numerator(w)]));
    }

    return u;
  }

  context.is_rational = function(u) {
    if (Types.isUndefined(u))
      return false;
    // 	var r = context.rationalise_expression(u);
    var d = context.denominator(u);
    return !Types.isUndefined(u) && !Types.reducesToNumber(d);
// 		return !Types.isOne(d);
  }

  // m/r + n/s
  context.rationalise_sum = function(u, v) {
    var result;

    if (lasterror)
      return Types.UNDEFINED;

    var m = context.numerator(u);
    var r = context.denominator(u);
    var n = context.numerator(v);
    var s = context.denominator(v);
    if (Types.isOne(r) && Types.isOne(s)) {
      result = Expression.construct(Types.SumOp, null, [u, v]);
    } else if (Expression.equal_expressions(r, s))	// returns (m + n)/r
    {
      result = Expression.construct(Types.QuotOp, null,
          [Expression.construct(Types.SumOp, null, [m, n]), r]);
    } else	// returns (ms + nr)/(rs)
    {
      var ms = Expression.construct(Types.ProdOp, null, [m, s]);
      var nr = Expression.construct(Types.ProdOp, null, [n, r]);
      var rs = Expression.construct(Types.ProdOp, null, [r, s]);
      result = Expression.construct(Types.QuotOp,
          null, [context.rationalise_sum(
              context.rationalise_expression(ms), context.rationalise_expression(nr)), rs]);
    }
    return result;
  }

  context.rationalise_expression = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    var result = null;

    if (Types.isOpOfType(e, Types.PowOp)) {
      var e1 = Expression.operand(e, 1);
      var e2 = Expression.operand(e, 2);
      result = Expression.construct(Types.PowOp, null, [context.rationalise_expression(e1), e2]);
    } else if (Types.isOpOfType(e, Types.ProdOp)) {
      var e1 = Expression.operand(e, 1);
      var e2 = Expression.dropfirstterm(e);
      result = Expression.construct(Types.ProdOp, null, [context.rationalise_expression(e1), e2]);
    } else if (Types.isOpOfType(e, Types.SumOp)) {
      var e1 = Expression.operand(e, 1);
      var e2 = Expression.dropfirstterm(e);
      result = context.rationalise_sum(context.rationalise_expression(e1),
          context.rationalise_expression(e2));
    }

    return result ? Simplify.automatic_simplify(context.cancel(result)) : e;
  }

  context.cancel = function(u) {
    if (lasterror)
      return Types.UNDEFINED;

    var n = context.numerator(u);
    var d = context.denominator(u);
    n = Simplify.factor_out(n);
    d = Simplify.factor_out(d);
    if (Types.isOne(n) || Types.isOne(d))
      return u;
    else {
      var ni = Expression.getInitialIntegerFactor(n);
      var di = Expression.getInitialIntegerFactor(d);
      if (ni && di && !Types.isOne(ni) && !Types.isOne(di)) {
        var gcd = Eval.functions[Types.fnGCD].eval(ni, di);
        if (!Types.isOne(gcd)) {
          n = Simplify.factor_out(Expression.div(n, gcd));
          d = Simplify.factor_out(Expression.div(d, gcd));
        }
      }
      // 	  return Expression.construct(Types.QuotOp, null, [n, d]);
      return Simplify.automatic_simplify(Expression.construct(Types.QuotOp, null, [n, d]));
    }
  }

  context.rational_expand = function(e, depth) {
    if (lasterror)
      return Types.UNDEFINED;
    if (!depth)
      depth = 1;
    if (depth > 10) {
      return e;
    }

    var result = null;

    var f = Expand.algebraic_expand(context.numerator(e));
    var g = Expand.algebraic_expand(context.denominator(e));

    if (Types.isZero(g))
      return Types.UNDEFINED;
    if (Types.isOne(g))
      return Simplify.automatic_simplify(f);

    var h = context.rational_div(f, g);
// 		Simplify.automatic_simplify(context.rationalise_expression(
// 			Simplify.automatic_simplify(Expression.construct(Types.QuotOp, null, [f, g]))));
    if (Expression.equal_expressions(e, h)) {
      result = e;
    } else {
      result = context.rational_expand(h, ++depth);
    }
    return context.cancel(result);
  }

  context.rational_div = function(u, v) {
    if (lasterror)
      return Types.UNDEFINED;
    if (!Types.isUndefined(u) && !Types.isZero(v) && Expression.equal_expressions(u, v))
      return Types.ONE;

    return Simplify.automatic_simplify(
        Transform.trigtransform(
            context.cancel(
                context.rationalise_expression(
                    Simplify.automatic_simplify(
                        Expression.construct(Types.QuotOp, null, [u, v]))))));
  }

  context.rational_simplify = function(u) {
    var v = context.rationalise_expression(u);
    var n = context.numerator(v);
    var d = context.denominator(v);
    var nf = Transform.simplifyall(n);
    var df = Transform.simplifyall(d);
    return Types.isOne(df) ? nf : context.poly_div(context.rational_div(nf, df));
  }

  context.poly_div = function(u) {
    var result;
    var n = context.numerator(u);
    var d = context.denominator(u);
    var L = [...new Set([n, d].map(Expression.getVariables))];
    if (!Types.isOne(d) && Polynomial.polynomial_gpe(n, L) && Polynomial.polynomial_gpe(d, L)) {
      var q = Polynomial.rec_poly_div(n, d, Expression.getVariables(n), true);
      return Expression.sum(q.quotient, context.rational_div(q.remainder, d));
// 			return Expression.sum(q.quotient, Expression.div(q.remainder, d));
    }
    return u;
  }

  var partial_fraction_1 = function(u, v1, v2, x) {
    // input: gcd(v1, v2) = 1, and u/(v1 v2) is proper;
    var s, A, B, u1, u2;

    s = Polynomial.extended_euclidean_algorithm(v1, v2, x);
    A = s[1];
    B = s[2];
    u1 = Polynomial.remainder(Simplify.automatic_simplify(Expand.algebraic_expand(
        Expression.prod(B, u))), v1, x);
    u2 = Polynomial.remainder(Simplify.automatic_simplify(Expand.algebraic_expand(
        Expression.prod(A, u))), v2, x);

    return [Simplify.automatic_simplify(u1), Simplify.automatic_simplify(u2)];
  }

  var partial_fraction_2 = function(u, v, x) {
    // input: u: a polynomial,
    // v: the irreducible factorization of a polynomial with positive degree and u/v proper;
    var f, r, s, u1, w, c;

    if (lasterror)
      return Types.UNDEFINED;

    if (!Types.isOpOfType(v, Types.ProdOp))
      return context.rational_div(u, v);
    else {
      f = Expression.operand(v, 1);
      r = context.rational_div(v, f);
      if (Expression.free_of(f, x)) {
        c = Expression.construct(Types.QuotOp, null, [Types.ONE, f]);
        return Expression.prod(c, partial_fraction_2(u, r, x));
      } else {
        s = partial_fraction_1(u, Expand.algebraic_expand(f), Expand.algebraic_expand(r), x);
        u1 = s[0];
        w = s[1];
        c = Expression.construct(Types.QuotOp, null, [u1, f]);
        return Expression.sum(c, partial_fraction_2(w, r, x));
      }
    }
  }

  var poly_expansion = function(u, v, x, t) {
    if (lasterror)
      return Types.UNDEFINED;
    if (Types.isZero(u))
      return Types.ZERO;

    var qr = Polynomial.polynomial_division(u, v, x);
    var q = qr.quotient;
    var r = qr.remainder;
    return Expand.algebraic_expand(Expression.sum(Expression.prod(t, poly_expansion(q, v, x, t)), r));
  }

  var partial_fraction_transform = function(op, x) {
    var p;
    var opd = context.denominator(op);
    var t = Expression.construct(Types.symbol, 'T', null);
    if (Types.isNumber(opd))
      return op;
    var opdconst = Expression.getInitialFactor(opd);
    if (opdconst && !Types.isOne(opdconst))
      opd = Expression.dropfirstterm(opd);
    if (Types.isOpOfType(opd, Types.PowOp)) {
      var n = Expand.algebraic_expand(context.numerator(op));
      var base = Expression.operand(opd, 1);
      var xn = poly_expansion(n, base, x, t);
      var subd = Expression.substitute(opd, base, t);
      var p0 = Expand.algebraic_expand(context.rational_div(xn, subd));
      if (opdconst)
        p = Expression.div(Expression.substitute(p0, t, base), opdconst);
      else
        p = Expression.substitute(p0, t, base);
      return p;
    } else
      return op;
  }

  var partial_fraction_3 = function(u, v, x) {
    if (lasterror)
      return Types.UNDEFINED;

    var w = Simplify.automatic_simplify(partial_fraction_2(u, v, x));
    var n, base, xn;
    if (Types.isOpOfType(w, Types.SumOp)) {
      var p = Types.ZERO;
      for (var i = 1; i <= Expression.num_operands(w); ++i) {
        p = Expression.sum(p, partial_fraction_transform(Expression.operand(w, i), x));
      }
      return p;
    } else if (Types.isOpOfType(w, Types.ProdOp)) {
      return partial_fraction_transform(w, x);
    } else
      return w;
  }

  context.partial_fraction = function(e, x) {
    if (lasterror)
      return Types.UNDEFINED;

    if (context.is_rational(e)) {
      var n = Expand.algebraic_expand(context.numerator(e));
      var d = Expand.algebraic_expand(context.denominator(e));
      if (Polynomial.polynomial_sv(n, x) && Polynomial.polynomial_sv(d, x)) {
        var degn = Polynomial.degree_sv(n, x);
        var degd = Polynomial.degree_sv(d, x);
        var t = Types.ZERO;
        var df = Polynomial.factorise(d, x);
        if (KBI.lessThanOrEqualTo(Types.toInteger(degd), Types.toInteger(degn))) {
          var qr = Polynomial.polynomial_division(n, d, x);
          var q = qr.quotient;
          var r = qr.remainder;
          return Expression.sum(q, partial_fraction_3(r, df, x));
        } else {
          return partial_fraction_3(n, df, x);
        }
      }
    }
    return e;
  }

  context.rational_factorise = function(u, varn, vard) {
    u = context.rationalise_expression(u);
    var n = context.numerator(u);
    var d = context.denominator(u);
    var nf, df;
    if (Types.isOpOfType(n, Types.ProdOp)) {
      nf = Expression.map(c => Simplify.factor_out(Polynomial.factorise(c, varn)), n);
      nf = Simplify.simplify_product(nf);
    } else
      nf = Simplify.factor_out(Polynomial.factorise(n, varn));
    if (Types.isOpOfType(d, Types.ProdOp)) {
      df = Expression.map(c => Simplify.factor_out(Polynomial.factorise(c, vard)), d);
      df = Simplify.simplify_product(df);
    } else
      df = Simplify.factor_out(Polynomial.factorise(d, vard));
    return Types.isOne(df) ? nf : context.rational_div(nf, df);
  }
})(Rational);


var Simplify = {};

(function(context) {
  context.simplify_rational_number = function(u) {
    // Input u : a fraction in function (FracOp) notation (with non-zero denominator)
    // 			 or an integer;
    // Output: a fraction in standard form in function (FracOp) notation or an integer;
    var n, d, g;
    var k = Expression.kind(u);

    if (k == Types.integer)
      return u;
    else if (k == Types.fraction) {
      n = u.value.n;
      d = u.value.d;
      if (KBI.isZero(d))
        return Types.UNDEFINED;
      else if (KBI.isOne(d))
        return Types.asInteger(n);
      else if (KBI.isZero(KBI.mod(n, d)))
        return Types.asInteger(KBI.div(n, d));
      else
        return Types.asFrac(n, d);
    } else
      return u;
  }

  context.merge_sums = function(u, v) {
    var result = null;

    if (!v.length)
      result = u;
    else if (!u.length)
      result = v;
    else {
      var p1 = u[0];
      var q1 = v[0];
      var a = [p1, q1];
      var h = context.simplify_sum_rec(a);
      if (h.length == 0)
        result = context.merge_sums(u.slice(1), v.slice(1));
      else if (h.length == 1)
        result = h.concat(context.merge_sums(u.slice(1), v.slice(1)));
      else if (h[0] === p1 && h[1] === q1)
        result = [p1].concat(context.merge_sums(u.slice(1), v));
      else	// h is [q1, p1]
        result = [q1].concat(context.merge_sums(u, v.slice(1)));
    }

    return result;
  }

  context.simplify_sum_rec = function(u) {
    var n = u.length;
    if (n == 2) {
      if (Types.isOpOfType(u[0], Types.SumOp) && Types.isOpOfType(u[1], Types.SumOp)) {
        return context.merge_sums(u[0].children, u[1].children);
      } else if (Types.isOpOfType(u[0], Types.SumOp)) {
        return context.merge_sums(u[0].children, [u[1]]);
      } else if (Types.isOpOfType(u[1], Types.SumOp)) {
        return context.merge_sums([u[0]], u[1].children);
      } else if (Types.isNumber(u[0]) && Types.isNumber(u[1])) {
        var r = Expression.construct(Types.SumOp, null, [u[0], u[1]]);
        return [r];
      } else if (Types.isZero(u[0]))
        return [u[1]];
      else if (Types.isZero(u[1]))
        return [u[0]];
      var term1 = Expression.term(u[0]);
      var term2 = Expression.term(u[1]);
      if (Expression.equal_expressions(term1, term2)) {
        // ax + bx = (a+b)x
        var s = context.simplify_sum(Expression.construct(Types.SumOp, null,
            [Expression.constant(u[0]), Expression.constant(u[1])]));
        var children = [s].concat(term1.children);
        var p = context.simplify_product(Expression.construct(Types.ProdOp, null, children));
        return [p];
      }
      var ct1 = Expression.get_constant_term(u[0]);
      var ct2 = Expression.get_constant_term(u[1]);
      if (!Types.isOne(ct1.term) && Expression.equal_expressions(ct1.term, ct2.term)) {
        var s = context.simplify_sum(Expression.construct(Types.SumOp, null, [ct1.constant, ct2.constant]));
        var p = context.simplify_product(Expression.construct(Types.ProdOp, null, [s, ct1.term]));
        return [p];
      } else {
        return Expression.sort(u);
      }
    } else if (n > 2) {
      var result;
      var w = context.simplify_sum_rec(u.slice(1));
      if (Types.isOpOfType(u[0], Types.SumOp))
        result = context.merge_sums(u[0].children, w);
      else
        result = context.merge_sums([u[0]], w);
      return result;
    } else {
      return Expression.sort(u);
    }
  }

  context.simplify_sum = function(u) {
    var i;
    var size = u.children ? u.children.length : 0;
    if (size == 0)
      return u;
    else if (size == 1)
      return u.children[0];
    else if (u.children.some(function(c) {
      return Types.isUndefined(c);
    }))
      return Types.UNDEFINED;

    var result = context.simplify_sum_rec(u.children);
    result = result.filter(r => !Types.isZero(r));
    var rsize = result ? result.length : 0;
    if (rsize == 0)
      result = Types.ZERO;
    else if (rsize == 1)
      result = result[0];
    else if (rsize > 1) {
      result = Expression.sort(result);
      result = Expression.construct(Types.SumOp, null, result);
    }
    return result;
  }

  context.merge_products = function(u, v) {
    var result = null;

    if (!v.length)
      result = u;
    else if (!u.length)
      result = v;
    else {
      var p1 = u[0];
      var q1 = v[0];
      var a = [p1, q1];
      var h = context.simplify_product_rec(a);
      if (h.length == 0)
        result = context.merge_products(u.slice(1), v.slice(1));
      else if (h.length == 1)
        result = h.concat(context.merge_products(u.slice(1), v.slice(1)));
      else if (Expression.equal_expressions(h[0], p1))
        result = [p1].concat(context.merge_products(u.slice(1), v));
      else if (Expression.equal_expressions(h[0], q1))
        result = [q1].concat(context.merge_products(u, v.slice(1)));
      else
        result = h.concat(context.merge_products(u.slice(1), v.slice(1)));
    }

    return result;
  }

  context.simplify_product_rec = function(u) {
    var result;
    var n = u.length;

    if (n == 2) {
      if (Types.isOpOfType(u[0], Types.ProdOp) && Types.isOpOfType(u[1], Types.ProdOp)) {
        return context.merge_products(u[0].children, u[1].children);
      } else if (Types.isOpOfType(u[0], Types.ProdOp)) {
        return context.merge_products(u[0].children, [u[1]]);
      } else if (Types.isOpOfType(u[1], Types.ProdOp)) {
        return context.merge_products([u[0]], u[1].children);
      } else if (Types.isNumber(u[0]) && Types.isNumber(u[1])) {
        var t = Expression.construct(Types.ProdOp, null, [u[0], u[1]]);
        return [t];
      } else if (Types.isOne(u[0]))
        return [u[1]];
      else if (Types.isOne(u[1]))
        return [u[0]];
      if (Expression.equal_expressions(Expression.base(u[0]), Expression.base(u[1]))) {
        var s = context.simplify_sum(Expression.construct(Types.SumOp, null,
            [Expression.exponent(u[0]), Expression.exponent(u[1])]));
        var p = context.simplify_power(Expression.construct(Types.PowOp, null,
            [Expression.base(u[1]), s]));
        return [p];
      } else if (Types.isInteger(u[0]) && Types.reducesToNumber(u[1])) {
        if (Types.isOpOfType(u[1], Types.PowOp)) {
          var base = Expression.base(u[1]);
          var exponent = Expression.exponent(u[1]);
          if (Types.isRationalValue(base) && Expression.equal_expressions(exponent, Types.HALF)) {
            var n = Types.toInteger(u[0]);
            var q = Types.toFrac(base);
            var z = Types.asFrac(KBI.mul(KBI.mul(n, n), q.n), q.d);
            var gcd = KBI.gcd(KBI.mul(n, n), q.d);
            if (gcd > 1) {
              result = Expression.construct(Types.PowOp, null, [z, Types.HALF]);
              if (KBI.isNegative(n))
                result = Expression.neg(result);
              return [result];
            }
          }
        }
      } else if (Types.reducesToNumber(u[0]) && Types.reducesToNumber(u[1])) {
        var u0isFrac = Types.isFraction(u[0]) && u[0].value.n == 1;
        var u1isFrac = Types.isFraction(u[1]) && u[1].value.n == 1;
        if ((u0isFrac || Types.isOpOfType(u[0], Types.PowOp)) &&
            (u1isFrac || Types.isOpOfType(u[1], Types.PowOp))) {
          var base0 = u0isFrac ? Types.asInteger(u[0].value.d) : Expression.base(u[0]);
          var exponent0 = u0isFrac ? Types.MINUSONE : Expression.exponent(u[0]);
          var base1 = u1isFrac ? Types.asInteger(u[1].value.d) : Expression.base(u[1]);
          var exponent1 = u1isFrac ? Types.MINUSONE : Expression.exponent(u[1]);
          if (Types.isRationalValue(base0) && Types.isRationalValue(base1)) {
            if (Expression.equal_expressions(exponent0, exponent1)) {
              var q = Types.toFrac(base0);
              var r = Types.toFrac(base1);
              var z = Types.asFrac(r.n * q.n, r.d * q.d);
              return [context.simplify_fractional_power(
                  Expression.construct(Types.PowOp, null, [z, exponent0]))];
            } else if (Expression.equal_expressions(base0, base1)) {
              var s = context.simplify_sum(Expression.construct(Types.SumOp, null, [exponent0, exponent1]));
              var p = context.simplify_power(Expression.construct(Types.PowOp, null, [base1, s]));
              return [p];
            }
          }
        }
      }
      return Expression.sort(u);
    } else {
      var w = context.simplify_product_rec(u.slice(1));
      if (Types.isOpOfType(u[0], Types.ProdOp))
        result = context.merge_products(u[0].children, w);
      else
        result = context.merge_products([u[0]], w);
      return result;
    }
  }

  context.simplify_product = function(u) {
    var i;
    var size = u.children ? u.children.length : 0;

    if (size == 0)
      return u;
    else if (size == 1)
      return u.children[0];
    else if (u.children.some(function(c) {
      return Types.isUndefined(c);
    }))
      return Types.UNDEFINED;
    else if (u.children.some(function(c) {
      return Types.isZero(c);
    }))
      return Types.ZERO;

    var result = context.simplify_product_rec(u.children);
    result = result.filter(r => !Types.isOne(r));
    if (result.length == 0)
      return Types.ONE;
    else if (result.length == 1)
      return result[0];
    else if (result.length > 1) {
      if (result.length == 2 && Types.isNumber(result[0]) && Types.isOpOfType(result[1], Types.SumOp)) {
        // replace each term in result[1] with result[0] * value
        var a = [];	// gcd of all
        var b = [];	// gcd of internal
        var hasnonint = false;
        var hasint = false;
        for (i = 0; i < result[1].children.length; ++i) {
          var factor = Expression.getInitialFactor(result[1].children[i]);
          var e;
          if (factor)
            e = Expression.prod(result[0], factor);
          else
            e = result[0];
          var isint = Types.isInteger(e);
          if (!hasint)
            hasint = isint;
          if (!hasnonint)
            hasnonint = !isint;
          a.push(e);
          b.push(factor ? factor : Types.ONE);
        }
        return Expression.construct(Types.ProdOp, null, result);
      } else {
        result = Expression.sort(result);
        return Expression.construct(Types.ProdOp, null, result);
      }
    }
    return u;
  }

  context.simplify_integer_power = function(v, n) {
    /*
		 * Input is v^n
		 */
    if (Types.isZero(n))
      return Types.ONE;
    else if (Types.isOne(n))
      return v;
    else if (Types.isOpOfType(v, Types.PowOp)) {
      if (Expression.num_operands(v) != 2)
        return null;
      var r = Expression.operand(v, 1);
      var s = Expression.operand(v, 2);
      var p = context.simplify_product(Expression.construct(Types.ProdOp, null, [s, n]));
      if (Types.isValueOfType(p, Types.integer))
        return context.simplify_integer_power(r, p);
      else
        return Expression.construct(Types.PowOp, null, [r, p]);
    } else if (Types.isOpOfType(v, Types.ProdOp)) {
      var r = Expression.map2(context.simplify_integer_power, v, n);
      return context.simplify_product(r);
    } else
      return Expression.construct(Types.PowOp, null, [v, n]);
  }

  context.simplify_power = function(u) {
    var result;
    if (!Types.isOpOfType(u, Types.PowOp))
      return u;
    /*
		 * Input is v^expr
		 */
    var w = Expression.exponent(u);
    var v = Expression.base(u);
    if (Types.isUndefined(w) || Types.isUndefined(v))
      return Types.UNDEFINED;
    else if (Types.isZero(v)) {
      if (Types.isPositiveRationalValue(w))
        return Types.ZERO;
      else
        return Types.UNDEFINED;
    } else if (Types.isOne(v))
      return Types.ONE;
    else if (Types.isInteger(v) && Types.isFraction(w)) {
      return context.simplify_fractional_power(u);
    } else if (Types.isFraction(v) && Types.isFraction(w)) {
      var n = Expression.construct(Types.PowOp, null, [Types.asInteger(v.value.n), w]);
      var d = Expression.construct(Types.PowOp, null, [Types.asInteger(v.value.d), w]);
      var t1 = context.simplify_fractional_power(n);
      var t2 = context.simplify_fractional_power(d);
      // 		if (Types.isInteger(t2))
      // 			result = context.simplify_product(Expression.construct(Types.ProdOp, null,
      // 				[Types.asFrac(1, t2.value), t1]));
      // 		else
      result = context.simplify_quotient(Expression.construct(Types.QuotOp, null, [t1, t2]));
      return result;
    } else if (Types.isZero(w))
      return Types.ONE;
    else if (Types.isValueOfType(w, Types.integer))
      return context.simplify_integer_power(v, w);
    else if (Types.isFraction(w)) {
      if (Types.isOpOfType(v, Types.SumOp)) {
        var cf = context.extractCF(v);
        if (!Types.isOne(cf[0])) {
          return Expression.prod(Expression.pow(cf[0], w), Expression.pow(cf[1], w));
        }
      } else if (Config.naivePower) {
        var naiveSimplify = function(y, z) {
          if (Types.isRationalValue(y)) {
            // if exact root...
            result = context.simplify_fractional_power2(y, z);
            return result ? [result, Types.ONE] : null;
          } else if (Types.isOpOfType(y, Types.PowOp)) {
            var a = Expression.base(y);
            var b = Expression.exponent(y);
            if ((Types.isInteger(a) || !Types.isNumber(a)) && Types.isRationalValue(b)) {
              var newpow = Eval.mul(z, b);
              return [Expression.pow(a, newpow), newpow];
            }
          }
          return null;
        };

        if (Types.isOpOfType(v, Types.ProdOp)) {
          var reduced = Types.ONE;
          var remain = Types.ONE;
          for (var i = 1; i <= Expression.num_operands(v); ++i) {
            var c = Expression.operand(v, i);
            var s = naiveSimplify(c, w);
            if (s && Types.isPositiveIntegerValue(s[1]))
              reduced = Expression.prod(reduced, s[0]);
            else
              remain = Expression.prod(remain, c);
          }
          if (!Types.isOne(reduced))
            return Expression.construct(Types.ProdOp, null,
                [Expression.construct(Types.PowOp, null, [remain, w]), reduced]);
          // 				return Expression.prod(Expression.pow(remain, w), reduced);
        } else {
          result = naiveSimplify(v, w);
          if (result)
            return result[0];
        }
      }
    } else if (Types.isFullyComplex(w) && !Types.isFullyComplex(v)) {
      var re = Complex.re(w);
      var im = Complex.im(w);
      if (Types.isRationalValue(re) && Types.isRationalValue(im))
        return Expression.prod(
            Expression.pow(v, re),
            Expression.pow(v, Expression.prod(Types.I, im))
        );
    }
    return u;
  }

  context.simplify_quotient = function(u) {
    var result;
    if (!Types.isOpOfType(u, Types.QuotOp))
      return u;

    /*
		 * a/b -> a*b^-1
		 */
    var a = Expression.operand(u, 1);
    var b = Expression.operand(u, 2);
    if (Types.isUndefined(a) || Types.isUndefined(b))
      result = Types.UNDEFINED;
    else if (Types.isRationalValue(a) && Types.isRationalValue(b))
      result = context.simplify_rational_number(Eval.ops[u.type].eval(a, b));
    else if (Types.isOne(a) && Types.isOpOfType(b, Types.PowOp)) {
      var base = Expression.base(b);
      if (Types.isInteger(base)) {
        var exponent = Expression.exponent(b);
        var newbase = Types.asFrac(1, Types.toInteger(base));
        result = Expression.construct(Types.PowOp, null, [newbase, exponent]);
      } else if (Types.isRationalValue(base)) {
        var exponent = Expression.exponent(b);
        var frac = Types.toFrac(base)
        var newbase = Types.asFrac(frac.d, frac.n);
        result = Expression.makenode(Types.PowOp, null, [newbase, exponent]);
      }
    } else if (Types.isOpOfType(a, Types.PowOp) && Types.isOpOfType(b, Types.PowOp)) {
      var base0 = Expression.base(a);
      var exponent0 = Expression.exponent(a);
      var base1 = Expression.base(b);
      var exponent1 = Expression.exponent(b);
      if (Types.isRationalValue(base0) && Types.isRationalValue(base1) &&
          Expression.equal_expressions(exponent0, exponent1)) {
        var q = Types.toFrac(base0);
        var r = Types.toFrac(base1);
        var z = Types.asFrac(KBI.mul(q.n, r.d), KBI.mul(q.d, r.n));
        result = context.simplify_fractional_power(
            Expression.construct(Types.PowOp, null, [z, exponent0]));
      }
    }

    if (!result) {
      var v = Expression.makenode(Types.PowOp, null, [b, Types.MINUSONE]);
      v = context.simplify_power(v);
      if (Types.isOne(v))
        result = a;
      else {
        result = Expression.construct(Types.ProdOp, null, [a, v]);
        result = context.simplify_product(result);
      }
    }

    return result;
  }

  context.simplify_difference = function(u) {
    /*
		 * a - b -> a + -1 * b
		 */
    var result;
    var a = Expression.operand(u, 1);
    if (Expression.num_operands(u) == 1) {
      if (Types.isUndefined(a))
        return Types.UNDEFINED;
      else
        result = context.simplify_product(Expression.construct(Types.ProdOp, null, [Types.MINUSONE, a]));
    } else {
      var b = Expression.operand(u, 2);
      if (Types.isUndefined(a) || Types.isUndefined(b))
        return Types.UNDEFINED;
      else {
        var v = context.simplify_product(Expression.construct(Types.ProdOp, null, [Types.MINUSONE, b]));
        result = Types.isZero(v) ? a : context.simplify_sum(Expression.construct(Types.SumOp, null, [a, v]));
      }
    }
    return context.automatic_simplify(result);
  }

  context.simplify_unaryminus = function(u) {
    /*
		 * -b -> -1 * b
		 */
    var a = Expression.operand(u, 1);
    if (Types.isUndefined(a))
      return Types.UNDEFINED;
    return Types.isZero(a) ? Types.ZERO : Expression.construct(
        Types.PowOp, null, [Types.MINUSONE, a]);
  }

  context.simplify_factorial = function(u) {
    var a = Expression.operand(u, 1);
    if (!a)
      throw "Invalid expression";
    if (Types.isUndefined(a))
      return Types.UNDEFINED;
    else if (Types.isInteger(a) && KBI.isPositive(a.value))
      return Expression.construct(Types.integer, Eval.factorial(a.value), null);
    else
      return u;
  }

  context.simplify_function = function(u) {
    u = Transform.checkinverses(u);
    var exact = Transform.checkexactvalues(u);
    return exact ? exact : u;
  }

  /* put as much as possible into a power term */
  context.separate = function(u) {
    if (Types.isOpOfType(u, Types.PowOp)) {
      return {
        coeff: Types.ONE,
        base: Expression.operand(u, 1),
        power: Expression.operand(u, 2)
      };
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      var coeff = Types.ONE;
      var power, base, commonpower;
      var powers = [];
      var gcd = null;
      var fail = false;
      // walk through the powers calling factor_out on each
      // collect the numerical factors and calculate their gcd
      for (var i = 1; i <= Expression.num_operands(u); ++i) {
        var c = Expression.operand(u, i);
        if (Types.isOpOfType(c, Types.PowOp))	// product of powers
        {
          powers.push({
            base: Expression.operand(c, 1),
            power: Expression.operand(c, 2)
          });
        } else if (Types.reducesToNumber(c)) {
          coeff = Expression.prod(coeff, c);
        } else {
          fail = true;
          break;
        }
      }
      if (fail || !powers.length)
        return {coeff: u, base: Types.ONE, power: Types.ZERO};

      commonpower = powers[0].power;
      var k = 1;
      var n = powers.length;
      while (k < n) {
        commonpower = context.common_factors(commonpower, powers[k].power);
        k++;
      }

      if (Types.isOne(commonpower))
        return {coeff: u, base: Types.ONE, power: Types.ZERO};

      // base is (u/coeff)^(1/commonpower)
      base = Types.ONE;
      powers.forEach(p => {
        base = Expression.prod(base, Expression.pow(p.base, Eval.div(p.power, commonpower)));
      });

      return {coeff: coeff, base: base, power: commonpower};
    } else
      return {coeff: u, base: Types.ONE, power: Types.ZERO};
  }

  context.handle_powers = function(u, op1, op2, s1, s2, op3, s3, allownonZ) {
    var pthroot = function(s, p, negate) {
      var r = negate ? Expression.prod(Types.MINUSONE, s.coeff) : s.coeff;
      r = context.automatic_simplify(Expression.pow(r, Rational.rational_div(Types.ONE, Types.asInteger(p))));
      var k = Types.asInteger(Types.toInteger(s.power) / p);
      return context.automatic_simplify(Expression.prod(r, Expression.pow(s.base, k)));
    }

    var isevenpower = function(s) {
      return s && s.power && Types.isInteger(s.power) && Types.toInteger(s.power) % 2 == 0 &&
          isexactconstantroot(s.coeff, 2);
    }

    var isexactconstantroot = function(n, k) {
      if (!Types.isInteger(n))
        return false;
      var m = Math.abs(Types.toInteger(n));
      if (m == 1)
        return true;
      if (allownonZ)
        return Types.reducesToNumber(n);
      var introot = Math.round(Math.pow(m, 1 / k));
      return Eval.power(introot, k) == m;
    }

    var transformcyclotomic = function(a, b, d, neg1, neg2, oppsigns) {
      var cp = NumericalPolynomial.cyclotomic(d);
      var terms = [];
      var k = cp.length - 1;
      if (neg1 && !neg2) {
        var temp = a;
        a = b;
        b = temp;
      }
      for (var n = 0; n <= k; ++n) {
        var c = cp[n];
        if (c) {
          var term;
          if (!oppsigns && n % 2) {
            c = -c;
          }
          var t1 = Expression.pow(a, Types.asInteger(k - n));
          var t2 = Expression.pow(b, Types.asInteger(n));
          term = Expression.prodAll([Types.asInteger(c), t1, t2]);
          terms.push(term);
        }
      }
      return Expression.sumAll(terms);
    }

    var neg1 = Types.isNegativeRationalValue(s1.coeff);
    var neg2 = Types.isNegativeRationalValue(s2.coeff);
    var oppsigns = neg1 != neg2;
    var m = Types.toInteger(s1.power);
    var n = Types.toInteger(s2.power);
    var gcd = (m || n) ? Eval.gcd(m, n) : 1;
    var gcd2 = gcd;
    while (gcd2 % 2 == 0)
      gcd2 /= 2;
    if (!op3) {
      if (gcd > 1 && (oppsigns || gcd2 > 1) && isexactconstantroot(s1.coeff, gcd) && isexactconstantroot(s2.coeff, gcd)) {
        if (!oppsigns)
          gcd = gcd2;
        m /= gcd;
        n /= gcd;
        var a = pthroot(s1, gcd, neg1);
        var b = pthroot(s2, gcd, neg2);
        var fs = [];
        for (var d = 1; d <= gcd; ++d) {
          if (gcd % d == 0) {
            fs.push(transformcyclotomic(a, b, d, neg1, neg2, oppsigns));
          }
        }
        var result = Expression.prodAll(fs);
        return result;
      }
    } else if (isevenpower(s1) && isevenpower(s2) && !oppsigns)	// look for perfect square
    {
      var a = pthroot(s1, 2, neg1);
      var b = pthroot(s2, 2, neg2);
      var m = Expression.prod(Types.TWO, Expression.prod(a, b));
      if (Expression.equal_expressions(op3, m)) {
        return Expression.pow(Expression.sum(a, b), Types.TWO);
      } else if (Expression.equal_expressions(op3, Expression.prod(Types.MINUSONE, m))) {
        return Expression.pow(Expression.diff(a, b), Types.TWO);
      }
    }

    return null;
  }

  /*
		teach it perfect squares and sum/differences of powers
	*/
  context.special_form = function(u, allownonZ) {
    var result = u;

    var n = Expression.num_operands(u);
    if (Types.isOpOfType(u, Types.SumOp) && ((n == 2) || (n == 3))) {
      var op1 = Expression.operand(u, 1);
      var op2 = Expression.operand(u, n);

      var s1 = context.separate(op1);
      var s2 = context.separate(op2);

      var op3, s3;

      if (n == 3) {
        op3 = Expression.operand(u, 2);	// the middle one
        s3 = context.separate(op3);
      }

      var spec = context.handle_powers(u, op1, op2, s1, s2, op3, s3, allownonZ);
      if (spec) {
        return context.factor_out(spec);
      }
    }

    return result;
  }

  context.extractCF = function(u) {
    if (Types.isOpOfType(u, Types.SumOp)) {
      var i, k = 1;
      var n = u.children.length;
      var c = Expression.operand(u, k);
      while (k < n) {
        k++;
        c = context.common_factors(c, Expression.operand(u, k));
      }
      if (!Types.isOne(c)) {
        for (i = 0; i < n; ++i) {
          u.children[i] = context.automatic_simplify(
              Expression.construct(Types.QuotOp, null, [Expression.operand(u, i + 1), c]));
        }
      }
      return [c, context.automatic_simplify(u)];
    } else
      return [Types.ONE, u];
  }

  context.factor_out = function(u, allownonZ) {
    if (lasterror)
      return Types.UNDEFINED;

    var mappable = function(v) {
      return context.factor_out(v, allownonZ);
    }

    if (Types.isOpOfType(u, Types.ProdOp)) {
      return context.automatic_simplify(Expression.map(mappable, u), true);
    } else if (Types.isOpOfType(u, Types.PowOp)) {
      var base = Expression.operand(u, 1);
      var exponent = Expression.operand(u, 2);
      var fo = context.automatic_simplify(context.factor_out(context.automatic_simplify(base)));
      return Expression.pow(fo, exponent);
    }
    // if complex with common factor in re and im parts...
    else if (Types.isOpOfType(u, Types.SumOp)) {
      var s = Expression.map(mappable, u);
      var cf = context.extractCF(s);
      if (!Types.isOne(cf[0]))
          //			return Expression.prod(cf[0], context.factor_out(context.special_form(cf[1])));
        return Expression.construct(Types.ProdOp, null, [cf[0], context.special_form(cf[1], allownonZ)]);
      else
        return context.automatic_simplify(context.special_form(u, allownonZ));
    } else if (Types.isComplex(u)) {
      var r = Complex.re(u);
      var i = Complex.im(u);
      if (Types.isInteger(r) && Types.isInteger(i)) {
        var rint = Types.toInteger(r);
        var iint = Types.toInteger(i);
        if (rint && iint) {
          var gcd = KBI.gcd(rint, iint);
          if (!KBI.isOne(gcd)) {
            gcd = Types.asInteger(gcd);
            return Expression.makenode(Types.ProdOp, null, [gcd, Complex.div(u, gcd)]);
          }
        }
      }
      return u;
    } else
      return u;
  }

  context.common_factors = function(u, v) {
    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isNumber(u) && Types.isNumber(v)) {
      if (Types.isInteger(u) && Types.isInteger(v))
        return Expression.construct(Types.integer, KBI.gcd(u.value, v.value), null);
      else if (Types.isRationalValue(u) && Types.isRationalValue(v)) {
        var f1 = Types.toFrac(u);
        var f2 = Types.toFrac(v);
        var d1 = KBR.div(f1, f2);
        if (KBI.isOne(d1.d))
          return v;
        var d2 = KBR.inverse(d1);
        if (KBI.isOne(d2.d))
          return u;
      }
      return Types.ONE;
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      var f = Expression.operand(u, 1);
      var r = context.common_factors(f, v);
      //		exprTreePtr v_on_r = rationalexpand(automaticsimplify(maketreefromop(DIV, v, r)));
      //		exprTreePtr s = common_factors(dropfirstterm(u), automaticsimplify(v_on_r));
      var v_on_r = context.automatic_simplify(
          Expression.construct(Types.QuotOp, null, [v, r]));
      var s = context.common_factors(Expression.dropfirstterm(u), v_on_r);
      return context.automatic_simplify(Expression.construct(Types.ProdOp, null, [r, s]));
    } else if (Types.isOpOfType(v, Types.ProdOp)) {
      return context.common_factors(v, u);
    } else {
      var base_u = Types.isOpOfType(u, Types.PowOp) ? Expression.operand(u, 1) : u;
      var exp_u = Types.isOpOfType(u, Types.PowOp) ? Expression.operand(u, 2) : Types.ONE;
      var base_v = Types.isOpOfType(v, Types.PowOp) ? Expression.operand(v, 1) : v;
      var exp_v = Types.isOpOfType(v, Types.PowOp) ? Expression.operand(v, 2) : Types.ONE;
      var result;
      if (Expression.equal_expressions(base_u, base_v)) {
        var diff = Expression.diff(exp_u, exp_v);
        if (Types.reducesToNumber(diff)) {
          if (Types.isPositiveRealValue(Expression.numerical_evaluate(diff)))
            return v;
          else
            return u;
        }
      }
      return Types.ONE;
    }
  }

  context.simplify_fractional_power = function(u) {
    /*
		 * Input is u^(p/r)
		 */
    var v = Expression.base(u);
    var w = Expression.exponent(u);

    if (Types.isNegativeIntegerValue(v) && Expression.equal_expressions(w, Types.HALF)) {
      var q = Expression.prod(Types.MINUSONE, v);
      var r = context.simplify_fractional_power2(q, w);
      return Expression.prod(Types.I, r);
    }

    if (!Types.isRationalValue(v) || !Types.isRationalValue(w))
      return u;

    return context.simplify_fractional_power2(v, w);
  }

  context.simplify_fractional_power2 = function(v, w) {
    var base, power, root, mul = 1, k;

    base = Types.toFrac(v);

    if (Types.isInteger(w)) {
      power = w.value;
      root = 1;
    } else {
      power = w.value.n;
      root = w.value.d;
    }

    // first adjust the power
    var gcd = KBI.gcd(power, root);
    if (gcd > 1) {
      power = KBI.div(power, gcd);
      root = KBI.div(root, gcd);
    }

    if (power > root && root > 1) {
      var pr = KBI.div(power, root);
      var f = KBI.pow(base.n, pr);
      mul = KBI.mul(mul, f);
      power = KBI.mod(power, root);
    }

    for (k = 2; k <= Math.floor(Math.sqrt(KBI.toDecimal(base.n))); ++k) {
      var kr = KBI.pow(k, root);
      while (KBI.isZero(KBI.mod(base.n, kr))) // i.e. base = k^r*x - extract the k
      {
        base.n = KBI.div(base.n, kr);
        mul = KBI.mul(mul, k);
      }
    }

    //  if (base > 1)
    //  {
    //    while (mul % base == 0)
    //    {
    //      mul /= base;
    //      power += root;
    //    }
    //  }

    // is base an integer power?
    for (k = 2; k <= Math.floor(Math.sqrt(base.n == 1 ? base.d : base.n)); ++k) {
      if (base.d == 1) {
        var t = Math.log(base.n) / Math.log(k);
        if (Config.tolequals(Math.round(t), t)) {
          // base numerator = k ^ t
          base.n = k;
          power *= Math.round(t);
          break;
        }
      } else if (base.n == 1) {
        var t = Math.log(base.d) / Math.log(k);
        if (Config.tolequals(Math.round(t), t)) {
          // base denominator = k ^ t
          base.d = k;
          power *= Math.round(t);
          break;
        }
      } else {
        var t = Math.log(base.n) / Math.log(k);
        if (Config.tolequals(Math.round(t), t)) {
          // base = k ^ t
          var s = t == 0 ? Math.log(base.d) / Math.log(k) : Math.pow(base.d, 1.0 / t);
          if (Config.tolequals(Math.round(s), s)) {
            base.n = k;
            base.d = Math.round(s);
            power *= t;
            break;
          }
        }
      }
    }

    var mul_t = Types.asInteger(mul);
    if (base.n == 0)
      return power == 0 ? mul_t : Types.ZERO;
    else if (base.n == base.d)
      return mul_t;

    var result = Types.asFrac(power, root);
    var newbase = Types.asFrac(base.n, base.d);
    result = Expression.makenode(Types.PowOp, null,
        [Types.asFrac(base.n, base.d), result]);
    if (mul != 1)
      result = Expression.makenode(Types.ProdOp, null, [mul_t, result]);

    return result;
  }

  context.automatic_simplify = function(u) {
    // Input u: a BAE in function notation
    // Output: An ASAE in function notation or the symbol Undefined
    var result;
    if (Config.checkTimeout())
      return Types.UNDEFINED;
    var k = Expression.kind(u);
    if (Types.isUndefined(u))
      return Types.UNDEFINED;
    else if (Types.isFraction(u))
      result = context.simplify_rational_number(u);
    else if (Types.isNumber(u))
      result = u;
    else if (k == Types.symbol)
      result = u;
    else {
      var v = Expression.map(context.automatic_simplify, u);
      var kv = Expression.kind(v);
      if (kv == Types.PowOp)
        result = context.simplify_power(v);
      else if (kv == Types.ProdOp)
        result = context.simplify_product(v);
      else if (kv == Types.SumOp)
        result = context.simplify_sum(v);
      else if (kv == Types.QuotOp)
        result = context.simplify_quotient(v);
      else if (kv == Types.DiffOp)
        result = context.simplify_difference(v);
      else if (kv == Types.FactOp)
        result = context.simplify_factorial(v);
      else if (kv == Types.Deriv)
        result = u;
          // 		else if (Types.reducesToComplex(u))
      // 			result = context.simplify_complex_number(u);
      else
        result = context.simplify_function(v);
    }

    return result;
  }
})(Simplify);


var Solve = {};

(function(context) {
  context.equate = function(a, b) {
    return Expression.construct(Types.Equate, null, [a, b]);
  }

  context.canSolve = function(u) {
    return context.isEquation(u) || context.isInequation(u);
  }

  context.isEquation = function(u) {
    return Types.isOpOfType(u, Types.Equate);
  }

  context.isInequation = function(u) {
    return Types.isOpOfType(u, Types.LT) || Types.isOpOfType(u, Types.LTE) ||
        Types.isOpOfType(u, Types.GT) || Types.isOpOfType(u, Types.GTE);
  }

  context.check_powers = function(u, x) {
    var coeffs = Polynomial.getcoefficients(u, x);
    // check powers
    var nonzeroindices = coeffs.reduce((a, e, i) => !Types.isZero(e) ? a.concat(i) : a, []);
    var powgcd = nonzeroindices.reduce(Eval.gcd);
    if (powgcd > 1)
      return Expression.pow(x, Types.asInteger(powgcd));
    else
      return x;
  }

  context.solve_linear = function(u, x) {
    x = context.check_powers(u, x);
    var lin = Polynomial.linear_form(u, x);
    if (lin && !Types.isZero(lin[0]))
      return context.equate(x, Expression.prod(Types.MINUSONE, Expression.div(lin[1], lin[0])));
    else
      return null;
  }

  context.solve_quad = function(u, x, skip) {
    var savex = x;
    x = skip ? x : context.check_powers(u, x);
    var q = Polynomial.quadratic_form(u, x);
    if (q) {
      var a = q[0];
      if (Types.isZero(a))
        return !skip ? context.solve_quad(u, savex, true) : null;

      var imag = false;
      var b = q[1];
      var c = q[2];
      var d = Expression.diff(Expression.prod(b, b),
          Expression.prod(Types.asInteger(4), Expression.prod(a, c)));
      if (Types.isNegativeRationalValue(d)) {
        if (Config.supportComplex) {
          d = Expression.prod(Types.MINUSONE, d);
          imag = true;
        } else
          return [context.equate(u, Types.ZERO)];
      }
      var t = Expression.pow(d, Types.HALF);
      if (imag)
        t = Expression.prod(t, Types.I);
      var r1 = Expression.div(
          Expression.sum(Expression.prod(Types.MINUSONE, b), t),
          Expression.prod(Types.TWO, a));

      if (Types.isZero(d))
        return [context.equate(x, r1)];

      var r2 = Expression.div(
          Expression.diff(Expression.prod(Types.MINUSONE, b), t),
          Expression.prod(Types.TWO, a));
      return [context.equate(x, Simplify.automatic_simplify(Rational.rational_simplify(r1))),
        context.equate(x, Simplify.automatic_simplify(Rational.rational_simplify(r2)))];
    } else
      return null;
  }

  // todo return found solutions and unsolved part
  context.solve_polynomial = function(u, x, numerical, factorise = true) {
    // TODO normalise should also remove pure powers...(x-a)^n=0 => x-a=0
    if (Types.isOpOfType(u, Types.Equate)) {
      u = context.normaliseEquation(u, [x], true);
      u = context.splitEquation(u).lhs;
    }

    if (Types.isOpOfType(u, Types.PowOp)) {
      u = Expression.operand(u, 1);
    }

    var quad = context.solve_quad(u, x);
    if (quad) {
      var s2s = [];
      for (var i = 0; i < quad.length; ++i) {
        var q = quad[i];
        if (Expression.equal_expressions(Expression.operand(q, 1), x))
          s2s.push(q);
        else {
          var s2 = context.solve(q, x, false);
          if (s2 && s2.solutions)
            s2s = s2s.concat(s2.solutions);
          else
            s2s.push(q);
        }
      }
      return {solutions: s2s, unsolved: null, numeric: false};
    }

    factorise &= !Types.includesRealNumber(u);
    var factored = factorise ? Polynomial.factorise(u, x, true) : u;
    if (Types.isOpOfType(factored, Types.ProdOp)) {
      var unsolved = Types.ONE;
      var solved = [];
      factored.children.forEach(f => {
        var s = null;
        if (!Expression.free_of(f, x)) {
          if (Polynomial.polynomial_gpe(Expand.algebraic_expand(f), x))
            s = context.solve_polynomial(context.equate(f, Types.ZERO), x, numerical, false);
          if (s) {
            solved = solved.concat(s.solutions);
            if (s.unsolved && !Types.isOne(s.unsolved))
              unsolved = Expression.prod(unsolved, s.unsolved);
          } else
            unsolved = Expression.prod(unsolved, f);
        }
      });
      return {solutions: solved, unsolved: unsolved, numeric: false};
    }

    var lin = context.solve_linear(u, x);
    if (lin)
      return {solutions: [lin], unsolved: null};

    var coeffs = Polynomial.getcoefficients(u, x);
    // are they all numbers
    var cansolve = coeffs.every(function(e) {
      return Types.isGeneralisedNumber(e);
    });
    if (numerical && cansolve) {
      var broots = context.bairstowRoots(coeffs.map(c => Types.toRealValue(c)));
      if (broots && broots.length) {
        var solved = [];
        var makerealsol = function(x, v) {
          return context.equate(x, Types.asReal(v));
        }
        var makecomplexsol = function(x, a, b) {
          return context.equate(x, Types.asComplex(Types.asReal(a), Types.asReal(b)));
        }
        broots.forEach((a) => {
          if (a.length == 2) {
            var d = a[0] * a[0] - 4 * a[1];
            if (d == 0)
              solved.push(Types.asReal(-a[0] / 2));
            else if (d > 0) {
              solved.unshift(makerealsol(x, (-a[0] + Math.sqrt(d)) / 2));
              solved.unshift(makerealsol(x, (-a[0] - Math.sqrt(d)) / 2));
            } else {
              if (Config.supportComplex) {
                d = -d;
                solved.push(makecomplexsol(x, -a[0] / 2, Math.sqrt(d) / 2));
                solved.push(makecomplexsol(x, -a[0] / 2, -Math.sqrt(d) / 2));
              } else {
                solved.unshift(context.equate(Expression.sumAll(
                    [Expression.pow(x, Types.TWO), Expression.prod(Types.asReal(a[0]), x), Types.asReal(a[1])]), Types.ZERO));
              }
            }
          } else // a.length == 1
          {
            solved.unshift(makerealsol(x, Types.asReal(-a[0])));
          }
        });

        // if real, use real value
        // if complex, use magnitude
        var getval = function(e) {
          var op = Expression.operand(e, 2);
          if (Types.isComplex(op))
            return Types.toRealValue(Complex.re(op));
          else
            return Types.toRealValue(op);
        };
        var sorted = solved.sort((a, b) => getval(a) - getval(b));
        return {solutions: sorted, numeric: true};
      }
      return {solutions: solved, numeric: true};
    }

    return null;
  }

  /* bairstow.c -- Bairstow's complex root finder
	 * (adapted from http://www.crbond.com/download/misc/bairstow.c)
	 *
	 *  (C) 1991, C. Bond
	 *
	 *  Finds all real and complex roots of polynomials
	 *  with real coefficients.
	 *
	 *  Features:
	 *      o Global, self-starting method,
	 *      o Does not require initial estimates,
	 *      o Finds all roots and quadratic factors,
	 *
	 *  Caveats:
	 *      All polynomial root finders have problems
	 *      maintaining accuracy in the presence of
	 *      repeated roots.
	 *      This is no exception!
	 */

  // a[0] is highest order term, a[n] lowest order
  context.find_poly_roots = function(a, b, c, d, n) {
    var r = 0;
    var s = 0;
    var dr = 1.0;
    var ds = 0;
    var eps = 1e-14;
    var iter = 1;
    var dn, drn, dsn;
    var i;

    while ((Math.abs(dr) + Math.abs(ds)) > eps) {
      if ((iter % 200) == 0) {
        r = Math.random() / 16000.0;
      }
      if ((iter % 500) == 0) {
        eps *= 10.0;
        console.log("Loss of precision\n");
      }
      b[1] = a[1] - r;
      c[1] = b[1] - r;

      for (i = 2; i <= n; i++) {
        b[i] = a[i] - r * b[i - 1] - s * b[i - 2];
        c[i] = b[i] - r * c[i - 1] - s * c[i - 2];
      }
      dn = c[n - 1] * c[n - 3] - c[n - 2] * c[n - 2];
      drn = b[n] * c[n - 3] - b[n - 1] * c[n - 2];
      dsn = b[n - 1] * c[n - 1] - b[n] * c[n - 2];

      if (Math.abs(dn) < 1e-16) {
        dn = 1;
        drn = 1;
        dsn = 1;
      }
      dr = drn / dn;
      ds = dsn / dn;

      r += dr;
      s += ds;
      iter++;
    }
    for (i = 0; i < n - 1; i++)
      a[i] = b[i];
    a[n] = s;
    a[n - 1] = r;
  }

  context.bairstowRoots = function(a) {
    var order = a.length - 1;
    var n = order;
    var b = [1.0];
    var c = [1.0];
    var d = [1.0];

    var factors = [];

    var tmp = a[0];
    a[0] = 1.0;

    for (var i = 1; i <= n; i++) {
      a[i] /= tmp;
      d[i] = a[i];
    }

    while (n > 2) {
      context.find_poly_roots(a, b, c, d, n);
      n -= 2;
    }
    for (i = order; i >= 2; i -= 2) /* quadratics */
      factors.push([a[i - 1], a[i]]);
//			factors.push("t^2 + " + a[i - 1] + "t + " + a[i]);
    if ((n % 2) == 1)
      factors.push([a[1]]);
//			factors.push("t + " + a[1]);

    return factors;
  }

  var testbairstow = function(a) {
    var order = a.length - 1;
    var n = order;
    var b = [1.0];
    var c = [1.0];
    var d = [1.0];

    var tmp = a[0];
    a[0] = 1.0;

    for (var i = 1; i <= n; i++) {
      a[i] /= tmp;
      d[i] = a[i];
    }

    while (n > 2) {
      context.find_poly_roots(a, b, c, d, n);
      n -= 2;
    }
    console.log("The quadratic factors are:\n");

    for (i = order; i >= 2; i -= 2) /* print quadratics */
      console.log("t^2 + " + a[i - 1] + "t + " + a[i]);
    if ((n % 2) == 1)
      console.log("The linear term is: t + " + a[1]);
  }

  context.splitEquation = function(e) {
    if (Types.isOpOfType(e, Types.Equate) || context.isInequation(e)) {
      return {lhs: Expression.operand(e, 1), rhs: Expression.operand(e, 2)};
    } else {
      lasterror = "NOT_AN_EQUATION";
      return Types.UNDEFINED;
    }
  }

  context.normaliseEquation = function(e, L, allonleft) {
    if (!Types.isOpOfType(e, Types.Equate) && !context.isInequation(e)) {
      lasterror = "NOT_AN_EQUATION";
      return Types.UNDEFINED;
    }
    var split = context.splitEquation(e);
    var norm = Expression.diff(split.lhs, split.rhs);
    if (allonleft || Types.isZero(split.rhs))
      return context.equate(norm, Types.ZERO);

    // get the constant term
    var lhs = Types.ZERO;
    var rhs = Types.ZERO;
    norm = Expand.algebraic_expand(norm);
    if (!Polynomial.polynomial_gpe(norm, L))
      return e;
    for (var i = 1; i <= Expression.num_operands(norm); ++i) {
      var t = Expression.operand(norm, i);
      if (Expression.set_free_of(t, L))
        rhs = Expression.sum(rhs, t);
      else
        lhs = Expression.sum(lhs, t);
    }

    return Simplify.automatic_simplify(context.equate(lhs, Expression.prod(Types.MINUSONE, rhs)));
  }

  context.oneVarNormalise = function(u, x) {
    var xterms = [];
    var otherterms = [];
    var t = context.splitEquation(context.normaliseEquation(u, [x], true)).lhs;
    if (Types.isOpOfType(t, Types.SumOp)) {
      for (var i = 1; i <= Expression.num_operands(t); ++i) {
        var op = Expression.operand(t, i);
        if (Expression.free_of(op, x))
          otherterms.push(op);
        else
          xterms.push(op);
      }
    } else {
      if (Expression.free_of(t, x))
        otherterms.push(t);
      else
        xterms.push(t);
    }

    return context.equate(Expression.sumAll(xterms),
        Expression.prod(Types.MINUSONE, Expression.sumAll(otherterms)));
  }

  context.critical_points = function(n, d, x) {
    // TODO extend to other forms (but not trig)
    n = Expand.algebraic_expand(n);
    d = Expand.algebraic_expand(d);
    if (!Polynomial.polynomial_gpe(n, x) || !Polynomial.polynomial_gpe(d, x))
      return null;
    var nsol = context.solve(context.equate(n, Types.ZERO), x, false);
    var dsol = context.solve(context.equate(d, Types.ZERO), x, false);

    return {nsol, dsol};
  }

  context.solve_rational = function(n, d, x) {
    var cps = context.critical_points(n, d, x);
    if (cps) {
      var {nsol, dsol} = cps;
      if (Expression.free_of(n, x))
        return {solutions: []};
      if (Expression.free_of(d, x))
        return nsol;
      if (!nsol.unsolved && !dsol.unsolved) {
        var na = nsol.solutions;
        var da = dsol.solutions;
        var dups = na.filter(function(e, i) {
          return da.findIndex(x => Expression.equal_expressions(e, x)) >= 0
        });
        var sols = na.filter(function(e, i) {
          return dups.findIndex(x => Expression.equal_expressions(e, x)) < 0
        });

        da.forEach(e => e.type = Types.NEQ);

        return {solutions: sols, exclusions: da};
      }
    }
    return Types.UNDEFINED;
  }

  context.solve_system = function(eqns) {
    // are they linear equations?
    // - terms must be numeric, symbol or numeric times symbol
    // - number of symbols must equal number of equations
    var n = eqns.length;
    eqns = eqns.map(e => Simplify.automatic_simplify(e));
    var vars = [].concat(...eqns.map(e => Expression.getVariables(e)))
        .filter((c, i, a) => i === a.findIndex(e => c.value === e.value));
    eqns = eqns.map(e => context.normaliseEquation(e, vars, false)).map(e => context.splitEquation(e));
    if (n && vars.length === n) {
      var a = [];
      var x = [];
      eqns.forEach((e, i) => {
        a.push([]);
        vars.forEach((v, j) => a[i].push(Polynomial.coefficient_gpe(e.lhs, v, Types.ONE)))
        x.push(e.rhs);
      });
      return {vars: vars, soln: context.gauss(a, x)};
    } else
      return Types.UNDEFINED;
  }

  /**
   * Gaussian elimination
   * @param  array a matrix
   * @param  array x vector
   * @return array x solution vector
   * Matrix.gauss([[1, 2, 3], [4, 0, 2], [5, 5, 4]], [9, 14, 17])
   */
  context.gauss1 = function(a, x) {
    a.forEach((r, i, m) => m[i] = r.map(e => Types.asInteger(e)));
    x = x.map(e => Types.asInteger(e));
    return context.gauss(a, x);
  }

  context.gauss = function(a, x) {
    var i, k, j;

    // Append the vector to the array
    var n = a.length;
    for (i = 0; i < n; i++) {
      a[i].push(x[i]);
    }

    for (i = 0; i < n; i++) {
      // Search for maximum in this column
      var maxElem = Eval.abs(a[i][i]);
      var maxRow = i;
      for (k = i + 1; k < n; k++) {
        if (Eval.greaterThan(Eval.abs(a[k][i]), maxElem)) {
          maxElem = Eval.abs(a[k][i]);
          maxRow = k;
        }
      }

      // Swap maximum row with current row (column by column)
      for (k = i; k < n + 1; k++) {
        var tmp = a[maxRow][k];
        a[maxRow][k] = a[i][k];
        a[i][k] = tmp;
      }

      var invalid = false;
      // Make all rows below this one 0 in current column
      for (k = i + 1; k < n; k++) {
        if (Types.isZero(a[i][i])) {
          invalid = true;
          break;
        }
        var c = Eval.div(Eval.neg(a[k][i]), a[i][i]);
        for (j = i; j < n + 1; j++) {
          if (i === j) a[k][j] = Types.ZERO;
          else a[k][j] = Eval.add(a[k][j], Eval.mul(c, a[i][j]));
        }
      }
    }

    // Solve equation Ax=b for an upper triangular matrix A
    x = new Array(n);
    for (i = n - 1; i > -1; i--) {
      if (Types.isZero(a[i][i])) {
        invalid = true;
        break;
      }
      x[i] = Simplify.automatic_simplify(Eval.div(a[i][n], a[i][i]));
      for (k = i - 1; k > -1; k--) {
        a[k][n] = Eval.sub(a[k][n], Eval.mul(x[i], a[k][i]));
      }
    }

    return invalid ? Types.UNDEFINED : x;
  }

  context.separate = function(u, y) {
    var w = context.normaliseEquation(u, null, true);
    if (Types.isUndefined(w))
      return u;
    w = context.splitEquation(w).lhs;

    var otherterms = [];
    var yterms = [];
    for (var i = 1; i <= Expression.num_operands(w); ++i) {
      var op = Expression.operand(w, i);
      if (Expression.free_of(op, y))
        otherterms.push(op);
      else
        yterms.push(op);
    }
    var lhs, rhs;
    if (Types.isOpOfType(w, Types.SumOp)) {
      lhs = Expression.sumAll(yterms);
      rhs = Expression.neg(Expression.sumAll(otherterms));
    }
    return context.equate(lhs, rhs);
  }

  context.rearrange = function(w, y, c) {
// 		w = Transform.handleexp(w, false);
    if (!Types.isOpOfType(w, Types.Equate) || Expression.num_operands(w) != 2)
      return w;
    var lhs = Expression.operand(w, 1);
    var rhs = Expression.operand(w, 2);
    if (Expression.equal_expressions(y, lhs))
      return c ? context.equate(lhs, Expression.sum(rhs, c)) : w;
    if (Expression.free_of(lhs, y)) {
      if (Expression.free_of(rhs, y))
        return context.equate(lhs, c ? Expression.sum(rhs, c) : rhs);
      else if (Expression.free_of(lhs, y))
        return context.rearrange(context.equate(rhs, lhs), y, c);
    }

    if (Types.isOpOfType(lhs, Types.SumOp)) {
      var xterms = [];
      var yterm;
      for (var i = 1; i <= Expression.num_operands(lhs); ++i) {
        var op = Expression.operand(lhs, i);
        if (Expression.free_of(op, y))
          xterms.push(op);
        else if (!yterm)
          yterm = op;
        else
          return c ? context.equate(lhs, Expression.sum(rhs, c)) : w;
      }
      lhs = yterm;
      rhs = Expression.sum(rhs, Expression.neg(Expression.sumAll(xterms)));
      if (c)
        rhs = Expression.sum(rhs, c);
      return context.rearrange(context.equate(lhs, rhs), y, null);
    } else if (Types.isOpOfType(lhs, Types.ProdOp)) {
      // Ay = f(x) + c' => y = 1/A * f(x) + c
      var coeff = Expression.operand(lhs, 1);
      if (Expression.free_of(coeff, y)) {
        lhs = Expression.div(lhs, coeff);
        var coeffneg = Types.isNegativeRationalValue(coeff) ||
            (Types.isOpOfType(coeff, Types.ProdOp) && Types.isNegativeRationalValue(Expression.operand(coeff, 1)));
        if (c)
          rhs = Expression.sum(rhs, coeffneg ? Expression.neg(c) : c);
        rhs = Expression.div(rhs, coeff);
        return context.rearrange(context.equate(lhs, rhs), y, null);
      }
    } else if (Types.isOpOfType(lhs, Types.PowOp)) {
      if (Expression.equal_expressions(y, Expression.operand(lhs, 1))) {
        var n = Expression.operand(lhs, 2);
        if (Types.isNegativeRationalValue(n)) {
          // y^(-n) = f(x) + c' => y^n = 1/(f(x) + c)
          lhs = Expression.pow(y, Expression.neg(n));
          if (c)
            rhs = Expression.sum(rhs, c);
          rhs = Expression.inv(rhs);
          return context.rearrange(context.equate(lhs, rhs), y, null);
        }
      }
    } else if (Types.isFunctionOfType(lhs, Types.fnLOG)) {
      // ln(y) = f(x) + c' => y = ce^f(x)
      lhs = Expression.operand(lhs, 1);
      rhs = Expression.construct(Types.fn, Types.fnEXP, rhs);
      if (c)
        rhs = Expression.prod(c, rhs);
      return context.rearrange(context.equate(lhs, rhs), y, null);
    } else if (Types.isFunctionOfType(lhs, Types.fnEXP)) {
      // e^y = f(x) + c' => y = ln(f(x) + c)
      lhs = Expression.operand(lhs, 1);
      if (c)
        rhs = Expression.sum(c, rhs);
      rhs = Expression.construct(Types.fn, Types.fnLOG, rhs);
      return context.rearrange(context.equate(lhs, rhs), y, null);
    }
    if (Transform.containsTrig(lhs, true, false)) {
      var result = context.trigsolve(lhs, rhs, y, c);
      if (result)
        return result;
    }
    return c ? context.equate(lhs, Expression.sum(rhs, c)) : w;
  }

  context.trigsolve = function(lhs, rhs, x, c) {
    lhs = Transform.contracttrig(lhs);
    // is it linear in the trig function?
    var trigfns = extractTrig(lhs, x);
    if (trigfns.length == 1) {
      // can invert
      var lin = Polynomial.linear_form(lhs, trigfns[0]);
      if (lin && !Types.isZero(lin[0])) {
        var f = trigfns[0];
        var newrhs = Expression.div(Expression.diff(rhs, lin[1]), lin[0]);
        var lhsarg = Expression.operand(f, 1);
        var result;
        switch (f.value) {
          case Types.fnCSC:
            newrhs = Expression.inv(newrhs);
          case Types.fnSIN:
            if (Types.isZero(newrhs)) {
              result = Expression.prod(Types.PI, Types.N);
            } else if (Types.isOne(newrhs)) {
              result = Expression.construct(Types.SumOp, null,
                  [Expression.prodAll([Types.TWO, Types.PI, Types.N]),
                    Expression.prod(Types.HALF, Types.PI)]);
            } else {
              result = [Expression.construct(Types.SumOp, null,
                  [Expression.construct(Types.fn, Types.fnASIN, [newrhs]),
                    Expression.prodAll([Types.TWO, Types.PI, Types.N])]),
                Expression.construct(Types.SumOp, null,
                    [Expression.neg(Expression.construct(Types.fn, Types.fnASIN, [newrhs])),
                      Expression.prodAll([Types.TWO, Types.PI, Types.N]), Types.PI])];
            }
            break;
          case Types.fnSEC:
            newrhs = Expression.inv(newrhs);
          case Types.fnCOS:
            if (Types.isOne(newrhs)) {
              result = Expression.prodAll([Types.TWO, Types.PI, Types.N]);
            } else if (Types.isZero(newrhs)) {
              result = Expression.diff(Expression.prod(Types.N, Types.PI),
                  Expression.prod(Types.HALF, Types.PI));
            } else {
              result = [Expression.construct(Types.SumOp, null,
                  [Expression.construct(Types.fn, Types.fnACOS, [newrhs]),
                    Expression.prodAll([Types.TWO, Types.PI, Types.N])]),
                Expression.construct(Types.SumOp, null,
                    [Expression.neg(Expression.construct(Types.fn, Types.fnACOS, [newrhs])),
                      Expression.prodAll([Types.TWO, Types.PI, Types.N])])];
            }
            break;
          case Types.fnCOT:
            newrhs = Expression.inv(newrhs);
          case Types.fnTAN:
            result = Expression.construct(Types.SumOp, null,
                [Expression.construct(Types.fn, Types.fnATAN, [newrhs]),
                  Expression.prod(Types.PI, Types.N)]);
            break;
        }
        var result2;
        if (Array.isArray(result)) {
          var solutions = [];
          result.forEach(r => {
            var eq = context.equate(lhsarg, r);
            var result2 = context.solve(eq, x, false);
            if (result2 && result2.solutions)
              solutions = solutions.concat(result2.solutions);
            else
              solutions = solutions.concat(eq);
          });
          return solutions;
        } else {
          result = context.equate(lhsarg, result);
          result2 = context.solve(result, x, false);
          return result2 && result2.solutions ? result2.solutions : result;
        }
      }
    }

    return null;
  }

  var extractTrig = function(e, x, fns) {
    if (!fns)
      fns = [];
    if (Transform.istrigfunction(e)) {
      if (!Expression.free_of(e.children[0], x))
        fns.push(e);
    } else if (e.children)
      e.children.forEach(c => extractTrig(c, x, fns));
    return fns;
  }

  var tol = 0.000001;

  context.newton = function(f, xvar) {
    var getval = function(e) {
      return Types.toRealValue(Expression.operand(e, 2))
    };
    var results = [];
    var xs = [-10000, -100];
    for (var x = -10; x < 10; x += Math.random() * 2)
      xs.push(x);
    xs.push(100, 10000);
    xs.forEach(x => {
      var result = context.onenewton(f, xvar, x);
      if (result) {
        var skip = false;
        var resultval = getval(result);
        for (var i = 0; i < results.length; ++i) {
          if (Math.abs(getval(results[i]) - resultval) < tol) {
            skip = true;
            break;
          }
        }
        if (!skip)
          results.push(result);
      }
    });

    if (results.length) {
      var sorted = results.sort((a, b) => getval(a) - getval(b));
      sorted = sorted.filter((x, i, a) => i == 0 || Math.abs(getval(a[i]) - getval(a[i - 1])) > 1.1 * tol);
      return {solutions: sorted, numeric: true};
    } else
      return {unsolved: f};
  }

  context.onenewton = function(f, xvar, x0) {
    var g = Calculus.derivative(f, xvar);

    var converged = false;
    var x = x0;
    var x_prev;
    var iter = 0;
    var max_iters = 100; 		// max iterations

    var evaluate = function(fn, x) {
      return Types.toRealValue(Simplify.automatic_simplify(
          Expression.substitute(fn, xvar, Types.asReal(x))));
    }

    do {
      iter++;
      x_prev = x;
      x = x_prev - evaluate(f, x_prev) / evaluate(g, x_prev);
// 			if (isinf(x))
// 				break;
    } while (Math.abs(x - x_prev) > tol && iter < max_iters);

    if (Math.abs(x - x_prev) <= tol)// && (evaluate(f, x) <= tol))
      converged = true;
    return converged ? context.equate(xvar, Types.asReal(parseFloat(x.toFixed(5)))) : null;
  }

  context.solveinequality = function(u, xvar) {
    var soln = null;
    if (context.isInequation(u)) {
      function makeIneq(a, op1, b, op2, c) {
        var result;
        if (!c)	// a op b
          result = Expression.construct(op1, null, [a, b]);
        else if (!a) // b op c
          result = Expression.construct(op2, null, [b, c]);
        else // a op b op c
          result = Expression.construct(op2, null, [Expression.construct(op1, null, [a, b]), c]);
        return context.isInequation(result) ? result : Types.UNDEFINED;
      }

      if (Expression.getVariables(u).length > 1)
        return null;	// can't solve
      var op = u.type;
      var t = context.splitEquation(context.normaliseEquation(u, [xvar], true)).lhs;
      var r = Rational.rationalise_expression(t);
      var n = Rational.numerator(r);
      var d = Rational.denominator(r);
      var cps = context.critical_points(n, d, xvar);
      if (cps) {
        var {nsol, dsol} = cps;
        var checkpts = [];
        var fail = false;
        // add all critical points along with their numeric equivalents
        if (nsol && nsol.solutions)
          nsol.solutions.forEach(s => {
            if (!Expression.equal_expressions(Expression.operand(s, 1), xvar))
              fail = true;
            else {
              var v = Expression.operand(s, 2);
              var val = Expression.numerical_evaluate(v);
              if (Types.isUndefined(val))
                fail = true;
              else if (!Types.reducesToComplex(v))
                checkpts.push({
                  x: v,
                  val: Types.toRealValue(val),
                  zero: true,
                  asymptote: false
                });
            }
          });
        if (!fail && dsol && dsol.solutions)
          dsol.solutions.forEach(s => {
            if (!Expression.equal_expressions(Expression.operand(s, 1), xvar))
              fail = true;
            else {
              var v = Expression.operand(s, 2);
              var val = Expression.numerical_evaluate(v);
              if (Types.isUndefined(val))
                fail = true;
              else if (!Types.reducesToComplex(v))
                checkpts.push({
                  x: v,
                  val: Types.toRealValue(val),
                  zero: false,
                  asymptote: true
                });
            }
          });
        if (fail)
          return null;

        var evaluate = function(fn, xvar, xval) {
          return Types.toRealValue(Expression.numerical_evaluate(
              Expression.substitute(fn, xvar, Types.asReal(xval))));
        }

        checkpts.sort((a, b) => a.val - b.val);
        var tol = 0.0001;
        var results = [];
        var exclusions = [];
        var start;
        var end = {x: null, zero: false};
        var fx, fx2;
        for (var i = 0; i < checkpts.length; ++i) {
          var pt = checkpts[i];
          start = end;
          end = pt;
          var x = pt.val;
          fx = evaluate(t, xvar, x - tol);
          fx2 = evaluate(t, xvar, x + tol);
          if (pt.asymptote) {
            if (fx * fx2 > 0) {
              exclusions.push(Expression.construct(Types.NEQ, null, [xvar, pt.x]));
              end = start;
              continue;
            }
          }
          if (fx < 0 && op === Types.LT)
            results.push(makeIneq(start.x, Types.LT, xvar, Types.LT, end.x));
          else if (fx <= 0 && op === Types.LTE)
            results.push(makeIneq(start.x, start.zero ? Types.LTE : Types.LT, xvar,
                end.zero ? Types.LTE : Types.LT, end.x));
          else if (fx > 0 && op === Types.GT)
            results.push(makeIneq(start.x, Types.LT, xvar, Types.LT, end.x));
          else if (fx >= 0 && op === Types.GTE)
            results.push(makeIneq(start.x, start.zero ? Types.LTE : Types.LT, xvar,
                end.zero ? Types.LTE : Types.LT, end.x));
        }

        if (fx2 === undefined) {
          fx2 = evaluate(t, xvar, 0);
          if ((fx2 < 0 && op === Types.LT) || (fx2 <= 0 && op === Types.LTE) ||
              (fx2 > 0 && op === Types.GT) || (fx2 >= 0 && op === Types.GTE))
            results.push(makeIneq(Types.NEGATIVEINFINITY, Types.GT, xvar, Types.GT, Types.INFINITY));
        } else if (end.x) {
          if (fx2 < 0 && op === Types.LT)
            results.push(makeIneq(null, null, xvar, Types.GT, end.x));
          else if (fx2 <= 0 && op === Types.LTE)
            results.push(makeIneq(null, null, xvar, end.zero ? Types.GTE : Types.GT, end.x));
          else if (fx2 > 0 && op === Types.GT)
            results.push(makeIneq(null, null, xvar, Types.GT, end.x));
          else if (fx2 >= 0 && op === Types.GTE)
            results.push(makeIneq(null, null, xvar, end.zero ? Types.GTE : Types.GT, end.x));
        }

        return {solutions: results.concat(exclusions)};
      }
      return null;
    }
  }

  context.solve = function(u, x, numerical) {
    var soln = null;
    if (context.isInequation(u)) {
      return context.solveinequality(u, x);
    } else if (Array.isArray(u)) {
      soln = context.solve_system(u);
      var result = [];
      for (var i = 0; i < soln.vars.length; ++i)
        result.push(context.equate(soln.vars[i], soln.soln[i]));
      return result;
    } else {
      u = Transform.handleexp(u, false);
      if (Transform.containsTrig(u, true, false) || Transform.containsLog(u)) {
        var split = context.splitEquation(context.oneVarNormalise(u, x));
        var simp = false;
        var lhs = Types.isFunction(split.lhs) ? split.lhs :
            Simplify.factor_out(
                Simplify.automatic_simplify(Transform.contractspecial(
                    Simplify.automatic_simplify(Transform.expandspecial(split.lhs, true)))));
        u = Solve.equate(lhs, split.rhs);
      }

      var t = context.splitEquation(context.normaliseEquation(u, [x], true)).lhs;
      var t1 = context.splitEquation(context.normaliseEquation(u, [x], false));

      t = Rational.rationalise_expression(t);
      var n = Rational.numerator(t);
      var d = Rational.denominator(t);
      if (!Expression.free_of(d, x))
        soln = context.solve_rational(n, d, x);
      else
        t = n;

      if (soln && !Types.isUndefined(soln))
        return soln;

      if (Types.isOpOfType(t, Types.ProdOp)) {
        var unsolved = Types.ONE;
        var solved = [];
        t.children.forEach(f => {
// 					var s = null;
// 					if (Polynomial.polynomial_gpe(f, x))
// 						s = context.solve_polynomial(context.equate(f, Types.ZERO), x, numerical, false);
          var s = context.solve(context.equate(f, Types.ZERO), x, numerical);
          if (s && s.solutions) {
            if (s.solutions.length) {
              solved = solved.concat(s.solutions);
              if (s.unsolved && !Types.isOne(s.unsolved))
                unsolved = Expression.prod(unsolved, s.unsolved);
            }
          } else
            unsolved = Expression.prod(unsolved, f);
        });
        soln = {solutions: solved, unsolved: unsolved, numeric: false};
      } else {
        if (Types.isOpOfType(t1.lhs, Types.PowOp)) {
          var base = Expression.operand(t1.lhs, 1);
          var exp = Simplify.automatic_simplify(Expression.operand(t1.lhs, 2));
          if (Types.isZero(t1.rhs)) {
            if (Types.isNegativeRationalValue(exp))
              soln = {solutions: [], unsolved: null};
            else
              soln = context.solve(context.equate(base, Types.ZERO), x);
          } else if (Types.isRationalValue(exp) && !Types.isInteger(exp)) {
            var expfrac = Types.toFrac(exp);
            var rhs = Expression.pow(t1.rhs, Types.asFrac(expfrac.d, expfrac.n));
            var neweqn = context.equate(base, rhs);
            soln = context.solve(neweqn, x);
          } else if (Types.isNegativeIntegerValue(exp)) {
            var rhs = Expression.pow(t1.rhs, Types.MINUSONE);
            var neweqn = context.equate(Expression.pow(t1.lhs, Types.MINUSONE), rhs);
            soln = context.solve(neweqn, x);
          } else if (Expression.free_of(t1.rhs, x) && !Types.isOpOfType(t1.rhs, Types.PowOp)
              && !Types.reducesToNumber(t1.rhs)) {
            var rhs = Expression.pow(t1.rhs, Expression.inv(exp));
            var neweqn = context.equate(base, rhs);
            soln = context.solve(neweqn, x);
          } else {
            var t = Expand.algebraic_expand(t);
            if (Polynomial.polynomial_gpe(t, x))
              soln = context.solve_polynomial(t, x, numerical);
          }
        } else {
          var t = Types.isZero(t1.rhs) ? t : Expand.algebraic_expand(t);
          if (Polynomial.polynomial_gpe(t, x))
            soln = context.solve_polynomial(t, x, numerical);
        }
      }
    }

    if (!soln) {
      soln = context.rearrange(u, x, null);
      if (!Expression.equal_expressions(u, soln))
        return soln.solutions ? soln : {solutions: Array.isArray(soln) ? soln : [soln]};
      var t = context.splitEquation(context.normaliseEquation(u, [x], true)).lhs;
      soln = context.newton(t, x);
    }

    // soln.solutions && soln.unsolved is empty/null
    // if single variable only then get numeric value for each solution
    // and then work out +ve or -ve in between

    return soln;
  }
})(Solve);


var testbairstow = function(a) {
  var order = a.length - 1;
  var n = order;
  var b = [1.0];
  var c = [1.0];
  var d = [1.0];

  var tmp = a[0];
  a[0] = 1.0;

  for (var i = 1; i <= n; i++) {
    a[i] /= tmp;
    d[i] = a[i];
  }

  while (n > 2) {
    Solve.find_poly_roots(a, b, c, d, n);
    n -= 2;
  }
  console.log("The quadratic factors are:\n");

  for (i = order; i >= 2; i -= 2) /* print quadratics */
    console.log("t^2 + " + a[i - 1] + "t + " + a[i]);
  if ((n % 2) == 1)
    console.log("The linear term is: t + " + a[1]);
}


var Transform = {};

(function(context) {
  context.getArgument = function(f, i) {
    if (Types.isFunction(f) && i > 0 && i <= f.children.length) {
      return Expression.operand(f, i);
    }
    return Types.UNDEFINED;
  }

  context.islogfunction = function(f) {
    if (!Types.isFunction(f))
      return false;

    switch (f.value) {
      case Types.fnLOG:
      case Types.fnEXP:
        return true;
      default:
        return false;
    }
  }

  context.istrigfunction = function(f) {
    if (!Types.isFunction(f))
      return false;

    switch (f.value) {
      case Types.fnSIN:
      case Types.fnCOS:
      case Types.fnTAN:
      case Types.fnCSC:
      case Types.fnSEC:
      case Types.fnCOT:
        return true;
      default:
        return false;
    }
  }

  context.ishfunction = function(f) {
    if (!Types.isFunction(f))
      return false;

    switch (f.value) {
      case Types.fnSINH:
      case Types.fnCOSH:
      case Types.fnTANH:
      case Types.fnCSCH:
      case Types.fnSECH:
      case Types.fnCOTH:
        return true;
      default:
        return false;
    }
  }

  context.containsTrig = function(e, std, hyp) {
    var istrig = context.istrigfunction(e);
    var ish = context.ishfunction(e);

    if (std && istrig || hyp && ish)
      return true;
    else if (e.children) {
      for (var i = 0; i < e.children.length; ++i) {
        if (context.containsTrig(e.children[i], std, hyp))
          return true;
      }
    }
    return false;
  }

  context.containsCosOrSin = function(e, std, hyp) {
    if (Types.isFunction(e)) {
      if (std && (e.value == Types.fnSIN || e.value == Types.fnCOS))
        return true;
      if (hyp && (e.value == Types.fnSINH || e.value == Types.fnCOSH))
        return true;
    }
    if (e.children) {
      for (var i = 0; i < e.children.length; ++i) {
        if (context.containsCosOrSin(e.children[i], std, hyp))
          return true;
      }
    }
    return false;
  }

  context.containsLog = function(e) {
    if (context.islogfunction(e))
      return true;
    else if (e.children) {
      for (var i = 0; i < e.children.length; ++i) {
        if (context.containsLog(e.children[i]))
          return true;
      }
    }
    return false;
  }

  context.checkMixedTrig_r = function(e, foundtan, foundothertrig, foundtanh, foundothertrigh) {
    for (var i = 0; i < e.children.length; ++i) {
      var child = e.children[i];

      var havetan = foundtan || Types.isFunctionOfType(child, Types.fnTAN)
          || Types.isFunctionOfType(child, Types.fnCOT);
      var havetanh = foundtanh || Types.isFunctionOfType(child, Types.fnTANH)
          || Types.isFunctionOfType(child, Types.fnCOTH);
      var haveother = foundothertrig || Types.isFunctionOfType(child, Types.fnSIN)
          || Types.isFunctionOfType(child, Types.fnCOS)
          || Types.isFunctionOfType(child, Types.fnCSC)
          || Types.isFunctionOfType(child, Types.fnSEC);
      var haveotherh = foundothertrigh || Types.isFunctionOfType(child, Types.fnSINH)
          || Types.isFunctionOfType(child, Types.fnCOSH)
          || Types.isFunctionOfType(child, Types.fnCSCH)
          || Types.isFunctionOfType(child, Types.fnSECH);

      if (foundtan && haveother)
        return true;
      if (foundtanh && haveotherh)
        return true;
      if (!foundtan)
        foundtan = havetan;
      if (!foundothertrig)
        foundothertrig = haveother;
      if (!foundtanh)
        foundtanh = havetanh;
      if (!foundothertrigh)
        foundtanh = haveotherh;

      if (context.checkMixedTrig_r(child, foundtan, foundothertrig, foundtanh, foundothertrigh))
        return false;
    }
    return false;
  }

  // if tan but no sin/cos, or tanh and no sinh/cosh, then keep in tan form...
  context.checkMixedTrig = function(e) {
    var havetan = Types.isFunctionOfType(e, Types.fnTAN) || Types.isFunctionOfType(e, Types.fnCOT);
    var havetanh = Types.isFunctionOfType(e, Types.fnTANH) || Types.isFunctionOfType(e, Types.fnCOTH);
    var haveother = Types.isFunctionOfType(e, Types.fnSIN) || Types.isFunctionOfType(e, Types.fnCOS) ||
        Types.isFunctionOfType(e, Types.fnCSC) || Types.isFunctionOfType(e, Types.fnSEC);
    var haveotherh = Types.isFunctionOfType(e, Types.fnSINH) || Types.isFunctionOfType(e, Types.fnCOSH) ||
        Types.isFunctionOfType(e, Types.fnCSCH) || Types.isFunctionOfType(e, Types.fnSECH);
    return context.checkMixedTrig_r(e, havetan, haveother, havetanh, haveotherh);
  }

  context.transformoddeven = function(v, f, odd) {
    if (lasterror)
      return Types.UNDEFINED;
    if (Types.isFunctionOfType(v, f)) {
      var args = Expression.operand(v, 1);
      if (Types.isNegativeRealValue(Expression.getfirstterm(args))) {
        args = Simplify.automatic_simplify(
            Expression.construct(Types.ProdOp, null, [Types.MINUSONE, args]));
        v = Expression.construct(Types.fn, f, [args]);
        if (odd)
          v = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, v]);
      }
    }

    return v;
  }

  context.trigoddeven = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isRealValue(e) || Types.isSymbol(e))
      return e;

    var v = Expression.map(context.trigoddeven, e);

    v = context.transformoddeven(v, Types.fnSIN, true);
    v = context.transformoddeven(v, Types.fnSINH, true);
    v = context.transformoddeven(v, Types.fnCOS, false);
    v = context.transformoddeven(v, Types.fnCOSH, false);

    //	v = context.transformoddeven(v, Types.fnTAN, true);
    //	v = context.transformoddeven(v, Types.fnTANH, true);
    //	v = context.transformoddeven(v, Types.fnCOT, true);
    //	v = context.transformoddeven(v, Types.fnCOTH, true);
    //	v = context.transformoddeven(v, Types.fnCSC, true);
    //	v = context.transformoddeven(v, Types.fnCSCH, true);
    //	v = context.transformoddeven(v, Types.fnSEC, false);
    //	v = context.transformoddeven(v, Types.fnSECH, false);

    return v;
  }

  context.trigsubstituteF = function(e) {
    return context.trigsubstitute(e, false);
  }
  context.trigsubstituteT = function(e) {
    return context.trigsubstitute(e, true);
  }

  context.trigsubstitute = function(e, subtans) {
    var v, args, result = null;

    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isRealValue(e) || Types.isSymbol(e))
      return e;

    v = Expression.map(subtans ? context.trigsubstituteT : context.trigsubstituteF, e);
    args = Expression.operand(v, 1);

    if (subtans && Types.isFunctionOfType(v, Types.fnTAN)) {
      result = Expression.construct(Types.QuotOp, null,
          [Expression.construct(Types.fn, Types.fnSIN, [args]),
            Expression.construct(Types.fn, Types.fnCOS, [args])]);
    } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
      if (subtans) {
        result = Expression.construct(Types.QuotOp, null,
            [Expression.construct(Types.fn, Types.fnCOS, [args]),
              Expression.construct(Types.fn, Types.fnSIN, [args])]);
      } else {
        result = Expression.construct(Types.QuotOp, null,
            [Types.ONE, Expression.construct(Types.fn, Types.fnTAN, [args])]);
      }
    } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnSIN, [args]), Types.MINUSONE]);
    } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCOS, [args]), Types.MINUSONE]);
    } else if (subtans && Types.isFunctionOfType(v, Types.fnTANH)) {
      result = Expression.construct(Types.QuotOp, null,
          [Expression.construct(Types.fn, Types.fnSINH, [args]),
            Expression.construct(Types.fn, Types.fnCOSH, [args])]);
    } else if (Types.isFunctionOfType(v, Types.fnCOTH)) {
      if (subtans) {
        result = Expression.construct(Types.QuotOp, null,
            [Expression.construct(Types.fn, Types.fnCOSH, [args]),
              Expression.construct(Types.fn, Types.fnSINH, [args])]);
      } else {
        result = Expression.construct(Types.QuotOp, null,
            [Types.ONE, Expression.construct(Types.fn, Types.fnTANH, [args])]);
      }
    } else if (Types.isFunctionOfType(v, Types.fnCSCH)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnSINH, [args]), Types.MINUSONE]);
    } else if (Types.isFunctionOfType(v, Types.fnSECH)) {
      result = Expression.construct(Types.PowOp, null,
          [Expression.construct(Types.fn, Types.fnCOSH, [args]), Types.MINUSONE]);
    } else
      result = v;

    return context.trigoddeven(result);
  }

  /*
	 * exp(u + v) = exp(u) * exp(v)
	 * exp(n * u) = exp(u) ^ n
	 */

  context.expandexprules = function(a) {
    var f, rest, result = null;

    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isOpOfType(a, Types.SumOp)) {
      f = Expression.operand(a, 1);
      rest = Expression.dropfirstterm(a);
      result = Expression.construct(Types.ProdOp, null,
          [context.expandexprules(f), context.expandexprules(rest)]);
    } else if (Types.isOpOfType(a, Types.ProdOp)) {
      f = Expression.operand(a, 1);
      if (Types.isInteger(f)) {
        rest = Expression.dropfirstterm(a);
        result = Expression.construct(Types.PowOp, null, [context.expandexprules(rest), f]);
      }
    }
    if (!result)
      result = Expression.construct(Types.fn, Types.fnEXP, [a]);
    return result;
  }

  context.expandexp = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    var expanded = Expand.algebraic_expand(e);

    var d = Rational.denominator(expanded);
    if (!Types.isOne(d))
      d = Expand.algebraic_expand(context.expandexp(d));
    if (Types.isZero(d))
      return Types.UNDEFINED;

    if (!Types.isOne(d)) {
      var n = Rational.numerator(expanded);
      expanded = Expand.algebraic_expand(
          Expression.construct(Types.ProdOp, null,
              [n, Expression.construct(Types.PowOp, null, [d, Types.MINUSONE])]));
      if (lasterror)
        return Types.UNDEFINED;
    }

    if (Types.isRealValue(expanded) || Types.isSymbol(expanded))
      return expanded;

    var v = Expression.map(context.expandexp, expanded);
    if (Types.isFunctionOfType(v, Types.fnEXP)) {
      var result = context.expandexprules(Expression.operand(v, 1));
      return lasterror ? Types.UNDEFINED : result;
    } else {
      return v;
    }
  }

  /*
	 * ln(u * v) = ln(u) + ln(v)
	 * ln(u ^ n) = n * ln(u)
	 */

  context.expandlogrules = function(a) {
    var f, rest, result = null;

    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isFraction(a)) {
      var n = Rational.numerator(a);
      var d = Rational.denominator(a);
      result = Expression.diff(Expression.construct(Types.fn, Types.fnLOG, [n]),
          Expression.construct(Types.fn, Types.fnLOG, [d]));
    } else if (Types.isOpOfType(a, Types.ProdOp)) {
      f = Expression.operand(a, 1);
      if (Config.supportComplex || !Types.isNegativeRealValue(f)) {
        rest = Expression.dropfirstterm(a);
        result = Expression.construct(Types.SumOp, null,
            [context.expandlogrules(f), context.expandlogrules(rest)]);
      }
    } else if (Types.isOpOfType(a, Types.PowOp)) {
      f = Expression.operand(a, 2);
      if (Types.isInteger(f) || (Config.naiveLog && Types.isRationalValue(f))) {
        rest = Expression.operand(a, 1);
        result = Expression.construct(Types.ProdOp, null, [f, context.expandlogrules(rest)]);
      }
    }
    if (!result)
      result = Expression.construct(Types.fn, Types.fnLOG, [a]);
    return result;
  }

  context.expandlog = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    if (Types.isRealValue(e) || Types.isSymbol(e))
      return e;
    var v = Expression.map(context.expandlog, Expand.algebraic_expand(e));
    if (Types.isFunctionOfType(v, Types.fnLOG)) {
      var result = context.expandlogrules(Expression.operand(v, 1));
      return result;
    } else {
      return v;
    }
  }

  context.multipleangletan = function(k, a, fun) {
    var f, n = null, d = null, u, result;
    var t;
    var j;
    var sign;

    if (fun != Types.fnTAN && fun != Types.fnTANH)
      return a;
    var ishyp = fun == Types.fnTANH;

    if (k < 0) {
      sign = -1;
      k = -k;
    } else {
      sign = 1;
    }

    if (Types.isOpOfType(a, Types.SumOp)) {
      f = context.expandtanrules(a, ishyp);
    } else {
      f = Expression.construct(Types.fn, ishyp ? Types.fnTANH : Types.fnTAN, [a]);
    }

    for (j = 0; j <= k; ++j) {
      var even = j % 2 == 0;
      var check = even ? j / 2 : (j - 1) / 2;
      var factor = ishyp ? 1 : check % 2 ? -1 : 1;
      factor *= KBI.bico(k, j);
      if (j == 0)
        u = Types.ONE;
      else if (j == 1)
        u = f;
      else
        u = Expression.construct(Types.PowOp, null, [f, Types.asInteger(j)]);
      if (factor != 1)
        u = Expression.construct(Types.ProdOp, null, [Types.asInteger(factor), u]);
      if (even) {
        if (d)
          d = Expression.construct(Types.SumOp, null, [d, u]);
        else
          d = u;
      } else {
        if (n)
          n = Expression.construct(Types.SumOp, null, [n, u]);
        else
          n = u;
      }
      if (lasterror)
        return Types.UNDEFINED;
    }

    d = Expression.construct(Types.PowOp, null, [d, Types.MINUSONE]);
    result = Expand.algebraic_expand(Expression.construct(Types.ProdOp, null, [n, d]));

    if (sign < 0) {
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    }

    return Expand.algebraic_expand(result);
  }

  context.multipleangle = function(n, a, fun) {
    var u, v, s, c, result;
    var f;
    var t;
    var j;
    var sign;

    var issin = fun == Types.fnSIN || fun == Types.fnSINH;
    var iscos = fun == Types.fnCOS || fun == Types.fnCOSH;
    if (!issin && !iscos)
      return a;
    var ishyp = fun == Types.fnSINH || fun == Types.fnCOSH;

    if (n < 0) {
      sign = issin ? -1 : 1;
      n = -n;
    } else {
      sign = 1;
    }

    if (Types.isOpOfType(a, Types.SumOp)) {
      f = context.expandtrigrules(a, ishyp);
      s = f.sinterm;
      c = f.costerm;
    } else {
      s = Expression.construct(Types.fn, ishyp ? Types.fnSINH : Types.fnSIN, [a]);
      c = Expression.construct(Types.fn, ishyp ? Types.fnCOSH : Types.fnCOS, [a]);
    }

    var start = iscos ? 0 : 1;
    for (j = start; j <= n; j += 2) {
      var check = issin ? (j - 1) / 2 : j / 2;
      var factor = ishyp ? 1 : check % 2 ? -1 : 1;
      factor *= KBI.bico(n, j);
      if (n - j == 1)
        u = c;
      else
        u = Expression.construct(Types.PowOp, null, [c, Types.asInteger(n - j)]);
      if (j == 1)
        v = s;
      else
        v = Expression.construct(Types.PowOp, null, [s, Types.asInteger(j)]);
      if (j == 0)
        v = u;
      else if (n != j)
        v = Expression.construct(Types.ProdOp, null, [u, v]);
      if (factor != 1)
        v = Expression.construct(Types.ProdOp, null, [Types.asInteger(factor), v]);
      result = j == start ? v : Expression.construct(Types.SumOp, null, [result, v]);
      if (lasterror)
        return Types.UNDEFINED;
    }

    if (fun != Types.fnCOSH && sign < 0) {
      result = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]);
    }

    return Expand.algebraic_expand(result);
  }

  /*
	 * sin(a + b) = sin(a) cos(b) + cos(a) sin(b),
	 * cos(a + b) = cos(a) cos(b) - sin(a) sin(b).
	 */

  context.expandtrigrules = function(a, ishyp) {
    var f, r, result = {sinterm: Types.UNDEFINED, costerm: Types.UNDEFINED};
    var u, v;

    if (lasterror)
      return result;

    if (Types.isOpOfType(a, Types.SumOp)) {
      f = context.expandtrigrules(Expression.operand(a, 1), ishyp);
      r = context.expandtrigrules(Expression.dropfirstterm(a), ishyp);
      u = Expression.construct(Types.ProdOp, null, [f.sinterm, r.costerm]);
      v = Expression.construct(Types.ProdOp, null, [f.costerm, r.sinterm]);
      result.sinterm = Expression.construct(Types.SumOp, null, [u, v]);
      u = Expression.construct(Types.ProdOp, null, [f.costerm, r.costerm]);
      v = Expression.construct(Types.ProdOp, null, [f.sinterm, r.sinterm]);
      if (!ishyp)
        v = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, v]);
      result.costerm = Expand.algebraic_expand(Expression.construct(Types.SumOp, null, [u, v]));
      return result;
    } else if (Types.isOpOfType(a, Types.ProdOp)) {
      u = Expression.operand(a, 1);
      if (Types.isInteger(u)) {
        var n = u.value;
        v = Expression.dropfirstterm(a);
        result.sinterm = Expand.algebraic_expand(context.multipleangle(n, v, ishyp ? Types.fnSINH : Types.fnSIN));
        result.costerm = Expand.algebraic_expand(context.multipleangle(n, v, ishyp ? Types.fnCOSH : Types.fnCOS));
        return result;
      }
    }
    result.sinterm = context.trigoddeven(
        Expression.construct(Types.fn, ishyp ? Types.fnSINH : Types.fnSIN, [a]));
    result.costerm = context.trigoddeven(
        Expression.construct(Types.fn, ishyp ? Types.fnCOSH : Types.fnCOS, [a]));
    return result;
  }

  /*
	 * tan(a + b) = (tan(a) + tan(b)) / (1 - tan(a) * tan(b))
	 * tanh(a + b) = (tanh(a) + tanh(b)) / (1 + tanh(a) * tanh(b))
	 */
// TODO this fails when a or b = n*pi/2 (n odd)
// should replace tan(a + n*pi/2) = -cot(a)
  context.expandtanrules = function(a, ishyp) {
    var f, r, result = Types.UNDEFINED;
    var u, v;

    if (lasterror)
      return result;

    if (Types.isOpOfType(a, Types.SumOp)) {
      f = context.expandtanrules(Expression.operand(a, 1), ishyp);
      r = context.expandtanrules(Expression.dropfirstterm(a), ishyp);
      u = Expression.construct(Types.SumOp, null, [f, r]);
      v = Expression.construct(Types.ProdOp, null, [f, r]);
      if (!ishyp)
        v = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, v]);
      v = Expression.construct(Types.SumOp, null, [Types.ONE, v]);
      v = Expression.construct(Types.PowOp, null, [v, Types.MINUSONE]);
      result = Expand.algebraic_expand(Expression.construct(Types.ProdOp, null, [u, v]));
      return result;
    } else if (Types.isOpOfType(a, Types.ProdOp)) {
      u = Expression.operand(a, 1);
      if (Types.isInteger(u)) {
        var n = u.value;
        v = Expression.dropfirstterm(a);
        result = Expand.algebraic_expand(
            context.multipleangletan(n, v, ishyp ? Types.fnTANH : Types.fnTAN));
        return result;
      }
    }
    result = Expression.construct(Types.fn, ishyp ? Types.fnTANH : Types.fnTAN, [a]);
    return result;
  }

  context.expandtrig = function(e) {
    var v, result;

    if (lasterror)
      return Types.UNDEFINED;

    var expanded = Expand.algebraic_expand(e);
    var d = Rational.denominator(expanded);
    if (!Types.isOne(d))
      d = Expand.algebraic_expand(context.expandtrig(d));
    if (Types.isZero(d))
      return Types.UNDEFINED;

    if (Types.isBasicRealValue(e) || Types.isSymbol(e))
      return e;

    v = Expression.map(context.expandtrig, expanded);
    if (Types.isFunctionOfType(v, Types.fnSIN)) {
      result = context.expandtrigrules(Expression.operand(v, 1), 0).sinterm;
      return Expand.algebraic_expand(result);
    } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
      result = context.expandtrigrules(Expression.operand(v, 1), 0).costerm;
      return Expand.algebraic_expand(result);
    } else if (Types.isFunctionOfType(v, Types.fnSINH)) {
      result = context.expandtrigrules(Expression.operand(v, 1), 1).sinterm;
      return Expand.algebraic_expand(result);
    } else if (Types.isFunctionOfType(v, Types.fnCOSH)) {
      result = context.expandtrigrules(Expression.operand(v, 1), 1).costerm;
      return Expand.algebraic_expand(result);
    } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
      var arg = Expression.operand(v, 1);
      if (Types.isOpOfType(arg, Types.SumOp))
        v = context.convertTrigPlusMinus(v, arg);
      if (Types.isFunctionOfType(v, Types.fnTAN))
        v = context.expandtanrules(Expression.operand(v, 1), 0);
      return Expand.algebraic_expand(v);
    } else if (Types.isFunctionOfType(v, Types.fnTANH)) {
      result = context.expandtanrules(Expression.operand(v, 1), 1);
      return Expand.algebraic_expand(result);
    } else {
      return v;
    }
  }

  context.expandfunctions = function(e, inctans) {
    return context.trigsubstitute(e, inctans);
    //	return context.expandtrig(context.trigsubstitute(e, inctans));
    //	return context.expandtrig(context.trigsubstitute(context.expandexp(context.expandlog(e)), inctans));
  }

  /*
	 * exp(u) * exp(v) = exp(u + v)
	 * exp(u) ^ n = exp(n * u)
	 */

  context.contractexprules = function(e) {
    var v, b, s, p, y, result = null;
    var i;

    if (lasterror)
      return Types.UNDEFINED;

    v = Expand.expandmainop(e);
    if (Types.isOpOfType(v, Types.PowOp)) {
      b = Expression.operand(v, 1);
      s = Expression.operand(v, 2);
      if (Types.isFunctionOfType(b, Types.fnEXP)) {
        p = Expression.construct(Types.ProdOp, null, [Expression.operand(b, 1), s]);
        if (Types.isOpOfType(p, Types.PowOp) || Types.isOpOfType(p, Types.ProdOp))
          p = context.contractexprules(p);
        result = Expression.construct(Types.fn, Types.fnEXP, [p]);
      } else
        result = v;
    } else if (Types.isOpOfType(v, Types.ProdOp)) {
      p = Types.ONE;
      s = Types.ZERO;
      for (i = 1; i <= Expression.num_operands(v); ++i) {
        y = Expression.operand(v, i);
        if (Types.isFunctionOfType(y, Types.fnEXP))
          s = Expression.construct(Types.SumOp, null, [s, Expression.operand(y, 1)]);
        else
          p = Expression.construct(Types.ProdOp, null, [p, y]);
      }
      result = Expression.construct(Types.ProdOp, null,
          [Expression.construct(Types.fn, Types.fnEXP, [s]), p]);
    } else if (Types.isOpOfType(v, Types.SumOp)) {
      s = Types.ZERO;
      for (i = 1; i <= Expression.num_operands(v); ++i) {
        y = Expression.operand(v, i);
        if (Types.isOpOfType(y, Types.PowOp) || Types.isOpOfType(y, Types.ProdOp))
          s = Expression.construct(Types.SumOp, null, [s, context.contractexprules(y)]);
        else
          s = Expression.construct(Types.ProdOp, null, [s, y]);
      }
      result = s;
    } else
      result = v;
    return Simplify.automatic_simplify(result);
  }

  context.contractexp = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    var expanded = Expand.algebraic_expand(e);

    var d = Rational.denominator(expanded);
    if (!Types.isOne(d))
      d = Expand.algebraic_expand(context.contractexp(d));
    if (Types.isZero(d))
      return Types.UNDEFINED;

    if (Types.isRealValue(expanded) || Types.isSymbol(expanded))
      return expanded;

    var v = Expression.map(context.contractexp, expanded);
    if (Types.isOpOfType(v, Types.PowOp) || Types.isOpOfType(v, Types.ProdOp)) {
      var result = context.contractexprules(v);
      return lasterror ? Types.UNDEFINED : result;
    } else {
      return v;
    }
  }

  /*
	 * log(a) + log(b) = log(a * b)
	 * n * log(u) = log(u ^ n)
	 */

  context.contractlogrules = function(e) {
    var v, b, s, p, y, result = null;
    var i;

    if (lasterror)
      return Types.UNDEFINED;
    v = Expand.expandmainop(e);
    if (Types.isOpOfType(v, Types.ProdOp)) {
      b = Expression.operand(v, 1);	// n
      s = Expression.operand(v, 2);	// log(u)
      if (Types.isFunctionOfType(s, Types.fnLOG)) {
        var arg = Expression.operand(s, 1);	// log(u)
        if (Expression.free_of(b, arg)) {
          p = Expression.construct(Types.PowOp, null, [Expression.operand(s, 1), b]);
          if (Types.isOpOfType(p, Types.SumOp) || Types.isOpOfType(p, Types.ProdOp))
            p = context.contractlogrules(p);
          result = Expression.construct(Types.fn, Types.fnLOG, [p]);
        } else
          result = v;
      } else
        result = v;
    } else if (Types.isOpOfType(v, Types.SumOp)) {
      p = Types.ONE;
      s = Types.ZERO;
      for (i = 1; i <= Expression.num_operands(v); ++i) {
        y = Expression.operand(v, i);
        if (Types.isFunctionOfType(y, Types.fnLOG))
          p = Expression.construct(Types.ProdOp, null, [p, Expression.operand(y, 1)]);
        else
          s = Expression.construct(Types.SumOp, null, [s, y]);
      }
      result = Expression.construct(Types.SumOp, null,
          [Expression.construct(Types.fn, Types.fnLOG, [p]), s]);
    } else
      result = v;
    return Simplify.automatic_simplify(result);
  }

  context.contractlog = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    var expanded = Expand.algebraic_expand(e);

    var d = Rational.denominator(expanded);
    if (!Types.isOne(d))
      d = Expand.algebraic_expand(context.contractlog(d));
    if (Types.isZero(d))
      return Types.UNDEFINED;

    if (Types.isRealValue(expanded) || Types.isSymbol(expanded))
      return expanded;

    var v = Expression.map(context.contractlog, expanded);
    if (Types.isOpOfType(v, Types.SumOp) || Types.isOpOfType(v, Types.ProdOp)) {
      var result = context.contractlogrules(v);
      return lasterror ? Types.UNDEFINED : result;
    } else {
      return v;
    }
  }

  context.istrig = function(e, inchyp, inctan, incinv) {
    if (Types.isOpOfType(e, Types.PowOp)) {
      return context.istrig(Expression.operand(e, 1), inchyp, inctan, incinv) &&
          Types.isPositiveIntegerValue(Expression.operand(e, 2));
    }

    if (Types.isFunctionOfType(e, Types.fnSIN) || Types.isFunctionOfType(e, Types.fnCOS))
      return true;
    if (inctan && Types.isFunctionOfType(e, Types.fnTAN))
      return true;
    if (incinv && (Types.isFunctionOfType(e, Types.fnSEC) || Types.isFunctionOfType(e, Types.fnCSC)))
      return true;
    if (inchyp) {
      if (Types.isFunctionOfType(e, Types.fnSINH) || Types.isFunctionOfType(e, Types.fnCOSH))
        return true;
      if (inctan && Types.isFunctionOfType(e, Types.fnTANH))
        return true;
      if (incinv && (Types.isFunctionOfType(e, Types.fnCSCH) || Types.isFunctionOfType(e, Types.fnSECH)))
        return true;
    }

    return false;
  }

  context.separatesincos = function(e, hyp) {
    var result = {sincosterms: Types.UNDEFINED, otherterms: Types.UNDEFINED};
    var r, s, u;
    var i;

    if (lasterror)
      return result;

    r = Types.ONE;
    s = Types.ONE;
    if (Types.isOpOfType(e, Types.ProdOp)) {
      for (i = 1; i <= Expression.num_operands(e); ++i) {
        u = Expression.operand(e, i);
        if (context.istrig(u, hyp, 0, 0))
          s = Types.isOne(s) ? u : Expression.construct(Types.ProdOp, null, [s, u]);
        else
          r = Types.isOne(r) ? u : Expression.construct(Types.ProdOp, null, [r, u]);
      }
    } else if (context.istrig(e, hyp, 0, 0)) {
      s = e;
    } else {
      r = e;
    }

    result.sincosterms = Simplify.automatic_simplify(s);
    result.otherterms = Simplify.automatic_simplify(r);
    return result;
  }

  context.contract_trig_power = function(e, hyp) {
    var f, p, a, s, u, result = e;
    var n;
    var j;
    var t;

    if (lasterror)
      return Types.UNDEFINED;

    var sinf = hyp ? Types.fnSINH : Types.fnSIN;
    var cosf = hyp ? Types.fnCOSH : Types.fnCOS;

    f = Expression.operand(e, 1);
    p = Expression.operand(e, 2);
    if (context.containsTrig(f, !hyp, hyp) && Types.isPositiveIntegerValue(p)) {
      n = p.value;
      var n_even = n % 2 == 0;
      a = Expression.operand(f, 1);
      if (Types.isFunctionOfType(f, cosf)) {

        var offset;
        var limit, div = Eval.power(2, n - 1);
        if (n_even)	// n even
        {
          offset = Types.asFrac(KBI.bico(n, n / 2), (2 * div));
          limit = n / 2 - 1;
        } else	// n odd
        {
          limit = Math.floor(n / 2);
        }
        s = Types.ZERO;
        for (j = 0; j <= limit; ++j) {
          var t1 = KBI.bico(n, j);
          var t2 = n - 2 * j;
          t = Types.asInteger(t2);
          u = Expression.construct(Types.ProdOp, null, [t, a]);
          u = Expression.construct(Types.fn, cosf, [u]);
          t = Types.asInteger(t1);
          u = Expression.construct(Types.ProdOp, null, [t, u]);
          s = Expression.construct(Types.SumOp, null, [s, u]);
        }
        t = Types.asInteger(div);
        u = Expression.construct(Types.QuotOp, null, [s, t]);
        if (n_even)
          result = Expression.construct(Types.SumOp, null, [offset, u]);
        else
          result = u;
        return context.contracttrigrules(result, hyp);
      } else if (Types.isFunctionOfType(f, sinf)) {
        var offset;
        var limit, factor, div = Eval.power(2, n - 1);
        var fn;
        if (n_even)	// n even
        {
          limit = n / 2 - 1;
          factor = (n / 2) % 2 == 0 ? 1 : -1;
          offset = Types.asFrac(KBI.bico(n, n / 2), (2 * div));
          fn = cosf;
        } else	// n odd
        {
          limit = Math.floor(n / 2);
          factor = ((n - 1) / 2) % 2 == 0 ? 1 : -1;
          fn = sinf;
        }
        if (hyp && (n % 4 > 1)) {
          factor *= -1;
          if (n_even)
            offset = Types.asFrac(-1 * KBI.bico(n, n / 2), (2 * div));
        }
        s = Types.ZERO;
        for (j = 0; j <= limit; ++j) {
          var t1 = KBI.bico(n, j);
          var t2 = n - 2 * j;
          t = Types.asInteger(t2);
          u = Expression.construct(Types.ProdOp, null, [t, a]);
          u = Expression.construct(Types.fn, fn, [u]);
          t = Types.asInteger(t1);
          u = Expression.construct(Types.ProdOp, null, [t, u]);
          if (j % 2 == 1)
            u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, u]);
          s = Expression.construct(Types.SumOp, null, [s, u]);
        }
        t = Types.asInteger(factor * div);
        u = Expression.construct(Types.QuotOp, null, [s, t]);
        if (n_even)
          result = Expression.construct(Types.SumOp, null, [offset, u]);
        else
          result = u;
        return context.contracttrigrules(result, hyp);
      } else
        return e;
    } else
      return result;
  }

  context.contract_trig_product = function(e, hyp) {
    var a, b, u, v, th, ph, result;
    var t;

    if (lasterror)
      return Types.UNDEFINED;

    if (!context.containsTrig(e, !hyp, hyp))
      return e;

    if (Expression.num_operands(e) == 2) {
      a = Expression.operand(e, 1);
      b = Expression.operand(e, 2);
      if (Types.isOpOfType(a, Types.PowOp)) {
        a = context.contract_trig_power(a, hyp);
        result = context.contracttrigrules(Expression.construct(Types.ProdOp, null, [a, b]), hyp);
      } else if (Types.isOpOfType(b, Types.PowOp)) {
        b = context.contract_trig_power(b, hyp);
        result = context.contracttrigrules(Expression.construct(Types.ProdOp, null, [a, b]), hyp);
      } else {
        th = Expression.operand(a, 1);
        ph = Expression.operand(b, 1);
        var sum = Expression.construct(Types.SumOp, null, [th, ph]);	// th + ph
        u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, ph]);
        var diff = Expression.construct(Types.SumOp, null, [th, u]);	// th - ph
        u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, th]);
        var diff2 = Expression.construct(Types.SumOp, null, [ph, u]);	// ph - th

        var sinf = hyp ? Types.fnSINH : Types.fnSIN;
        var cosf = hyp ? Types.fnCOSH : Types.fnCOS;

        if (Types.isFunctionOfType(a, sinf) && Types.isFunctionOfType(b, sinf)) {
          // sin(th)  * sin(ph)  =   cos(th - ph)/2 - cos(th + ph)/2
          // sinh(th) * sinh(ph) = -cosh(th - ph)/2 + cosh(th + ph)/2
          u = Expression.construct(Types.fn, cosf, [diff]);
          u = Expression.construct(Types.QuotOp, null, [u, Types.TWO]);

          v = Expression.construct(Types.fn, cosf, [sum]);
          v = Expression.construct(Types.QuotOp, null, [v, Types.TWO]);
          if (hyp)
            u = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, u]);
          else
            v = Expression.construct(Types.ProdOp, null, [Types.MINUSONE, v]);

          result = Simplify.automatic_simplify(Expression.construct(Types.SumOp, null, [u, v]));
        } else if (Types.isFunctionOfType(a, cosf) && Types.isFunctionOfType(b, cosf)) {
          // cos(th) * cos(ph) = cos(th + ph)/2 + cos(th - ph)/2
          // cos(th) * cos(ph) = cosh(th + ph)/2 + cosh(th - ph)/2
          u = Expression.construct(Types.fn, cosf, [diff]);
          u = Expression.construct(Types.QuotOp, null, [u, Types.TWO]);

          v = Expression.construct(Types.fn, cosf, [sum]);
          v = Expression.construct(Types.QuotOp, null, [v, Types.TWO]);

          result = Simplify.automatic_simplify(Expression.construct(Types.SumOp, null, [u, v]));
        } else if (Types.isFunctionOfType(a, sinf) && Types.isFunctionOfType(b, cosf)) {
          // sin(th) * cos(ph) = sin(th + ph)/2 + sin(th - ph)/2
          // sinh(th) * cosh(ph) = sin(th + ph)/2 + sin(th - ph)/2
          u = Expression.construct(Types.fn, sinf, [diff]);
          u = Expression.construct(Types.QuotOp, null, [u, Types.TWO]);

          v = Expression.construct(Types.fn, sinf, [sum]);
          v = Expression.construct(Types.QuotOp, null, [v, Types.TWO]);

          result = Simplify.automatic_simplify(Expression.construct(Types.SumOp, null, [u, v]));
        } else if (Types.isFunctionOfType(a, cosf) && Types.isFunctionOfType(b, sinf)) {
          // cos(th) * sin(ph) = sin(th + ph)/2 - sin(th - ph)/2
          // cos(th) * sin(ph) = sin(th + ph)/2 + sin(ph - th)/2	is tidier
          // cosh(th) * sinh(ph) = sinh(th + ph)/2 + sinh(ph - th)/2
          u = Expression.construct(Types.fn, sinf, [sum]);
          u = Expression.construct(Types.QuotOp, null, [u, Types.TWO]);

          v = Expression.construct(Types.fn, sinf, [diff2]);
          v = Expression.construct(Types.QuotOp, null, [v, Types.TWO]);

          result = Simplify.automatic_simplify(Expression.construct(Types.SumOp, null, [u, v]));
        } else
          result = null;
      }
      return result ? context.contracttrigrules(result, hyp) : e;
    } else {
      a = Expression.operand(e, 1);
      b = context.contract_trig_product(Expression.dropfirstterm(e), hyp);
      return context.contracttrigrules(Expression.construct(Types.ProdOp, null, [a, b]), hyp);
    }
  }

  context.contracttrigrules = function(e, hyp) {
    var v, s, c, d, y;
    var sr;
    var i;

    if (lasterror)
      return Types.UNDEFINED;

    // TODO not sure why I need a full expand here...
    //	v = Expand.expandmainop(e);
    v = Expand.algebraic_expand(e);
    if (Types.isOpOfType(v, Types.PowOp))
      return context.contract_trig_power(v, hyp);
    else if (Types.isOpOfType(v, Types.ProdOp)) {
      sr = context.separatesincos(v, hyp);
      c = sr.otherterms;
      d = sr.sincosterms;
      if (Types.isOne(d))
        return v;
      else if (Types.isFunctionOfType(d, hyp ? Types.fnSINH : Types.fnSIN) ||
          Types.isFunctionOfType(d, hyp ? Types.fnCOSH : Types.fnCOS))
        return v;
      else if (Types.isOpOfType(d, Types.PowOp))
        return Expand.expandmainop(Expression.construct(Types.ProdOp, null,
            [c, context.contract_trig_power(d, hyp)]));
      else
        return Expand.expandmainop(Expression.construct(Types.ProdOp, null,
            [c, context.contract_trig_product(d, hyp)]));
    } else if (Types.isOpOfType(v, Types.SumOp)) {
      s = Types.ZERO;
      for (i = 1; i <= Expression.num_operands(v); ++i) {
        y = Expression.operand(v, i);
        if (Types.isOpOfType(y, Types.PowOp) || Types.isOpOfType(y, Types.ProdOp))
          s = Expression.construct(Types.SumOp, null, [s, context.contracttrigrules(y, hyp)]);
        else
          s = Expression.construct(Types.SumOp, null, [s, y]);
      }
      return s;
    } else
      return v;
  }

  context.contracttrig = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    var expanded = Expand.algebraic_expand(e);

    var d = Rational.denominator(expanded);
    if (!Types.isOne(d))
      d = Expand.algebraic_expand(context.contracttrig(d));
    if (Types.isZero(d))
      return Types.UNDEFINED;

    if (Types.isNumber(expanded) || Types.isSymbol(expanded))
      return expanded;

    var v = Expression.map(context.contracttrig, expanded);
    if (Types.isOpOfType(v, Types.PowOp) || Types.isOpOfType(v, Types.ProdOp)) {
      var result = context.contracttrigrules(v, 0);
      result = context.contracttrigrules(result, 1);
      return lasterror ? Types.UNDEFINED : Simplify.automatic_simplify(result);
    } else {
      return Simplify.automatic_simplify(context.trigoddeven(v));
    }
  }

  context.checkexactvalues = function(v) {
    if (!Types.isFunction(v))
      return null;

    if (Expression.num_operands(v) != 1)
      return null;

    var arg = context.getArgument(v, 1);

    if (Types.isFunctionOfType(v, Types.fnNTOR))
      return Rational.numerator(Rational.rationalise_expression(arg));
    else if (Types.isFunctionOfType(v, Types.fnDTOR))
      return Rational.denominator(Rational.rationalise_expression(arg));

    var ratlcomp = Types.reducesToComplex(arg) && Types.isRationalValue(Complex.re(arg)) &&
        Types.isRationalValue(Complex.im(arg));
    if (Types.isFunctionOfType(v, Types.fnABS)) {
      if (ratlcomp) {
        return Complex.abs(arg);
      } else if (Types.isPositiveRationalValue(arg))
        return arg;
      else if (Types.isNegativeRationalValue(arg))
        return Eval.neg(arg);
    } else if (Types.isFunctionOfType(v, Types.fnARG)) {
      // 		arg = atan(y/x) 			if x > 0
      // 				= atan(y/x) + pi	if x < 0 && y >= 0
      // 				= atan(y/x) - pi	if x < 0 && y < 0
      // 				= pi / 2					if x = 0 & y > 0
      // 				= -pi / 2					if x = 0 & y < 0
      // 				= undefined				if x = 0 & y = 0
      var re = Complex.re(arg);
      var im = Complex.im(arg);
      if (Types.isZero(re)) {
        if (Types.isZero(im))
          return Types.UNDEFINED;
        else if (Types.isPositiveRationalValue(im))
          return Expression.prod(Types.HALF, Types.PI);
        else // negative
          return Expression.prod(Types.MINUSONE, Expression.prod(Types.HALF, Types.PI));
      } else if (Types.isZero(im)) {
        if (Types.isPositiveRationalValue(re))
          return Types.ZERO;
        else // negative
          return Types.PI;
      } else {
        var ratio = Rational.rational_div(im, re);
        var f = Expression.construct(Types.fn, Types.fnATAN, [ratio]);
        var exact = context.checkexactvalues(f);
        if (exact)
          return exact;
        else
          return Simplify.automatic_simplify(Complex.arg(arg));
      }
    } else if (Types.isFunctionOfType(v, Types.fnLOG) && Complex.supportComplex) {
      // exact values for log:  log(z) = log(r) + i*th
      if (Types.isNegativeRealValue(arg)) {
        var r = Eval.abs(arg);
        var th = Types.PI;
        var logr = Expression.construct(Types.fn, Types.fnLOG, [r]);
        return Expression.sum(logr, Expression.prod(Types.I, th));
      } else if (Types.isComplex(arg)) {
        var r = Complex.abs(arg);
        var th = Complex.arg(arg);
        var exactth = Types.reducesToNumber(th, true) ? th : context.checkexactvalues(th);
        if (exactth) {
          var logr = Expression.construct(Types.fn, Types.fnLOG, [r]);
          return Expression.sum(logr, Expression.prod(Types.I, exactth));
        }
      }
    }

    // E - use e^(a+ib) = e^a (cos b + i sin b)
    if (Types.reducesToComplex(arg) && Types.isFunctionOfType(v, Types.fnEXP)) {
      var re = Complex.re(arg);
      var im = Complex.im(arg);
      var cosb = context.checkexactvalues(Expression.construct(Types.fn, Types.fnCOS, [im]));
      if (cosb) {
        var sinb = context.checkexactvalues(Expression.construct(Types.fn, Types.fnSIN, [im]));
        var exact = Types.asComplex(cosb, sinb);
        if (!Types.isZero(re))
          exact = Expression.prod(Expression.pow(Types.E, re), exact);
        return exact;
      }
    }

    if (!Types.isRealValue(arg))
      return null;
    var darg = Types.toRealValue(Expression.numerical_evaluate(Expression.copy(arg)));
    if (!isFinite(darg))
      return null;
    var negative = darg < 0;
    darg = Math.abs(darg);

    // look for exact inverse trig
    if (Types.isFunctionOfType(v, Types.fnASIN) || Types.isFunctionOfType(v, Types.fnACOS)) {
      // 0 => 0, 1/2 => pi/6, 1/sqrt(2) => pi/4, sqrt(3)/2 => pi/3, 1 => pi/2
      // use 4 * square darg & use tolerance
      // 0 => 0, 1 => pi/6, 2 => pi/4, 3 => pi/3, 4 => pi/2
      // negative => -1 *
      // acos = pi/2 - asin
      darg = 4 * darg * darg;
      if (Math.abs(darg - Math.round(darg)) > Config.tolerance)	// integer only
        return null;
      else
        darg = Math.round(darg);
      var exact = null;
      switch (darg) {
        case 0:
          exact = Types.ZERO;
          break;
        case 1:
          exact = Expression.div(Types.PI, Types.asInteger(6));
          break;
        case 2:
          exact = Expression.div(Types.PI, Types.asInteger(4));
          break;
        case 3:
          exact = Expression.div(Types.PI, Types.asInteger(3));
          break;
        case 4:
          exact = Expression.div(Types.PI, Types.TWO);
          break;
        default:
          return null;
      }
      if (negative)
        exact = Expression.prod(Types.MINUSONE, exact);
      if (Types.isFunctionOfType(v, Types.fnACOS))
        exact = Expression.diff(Expression.div(Types.PI, Types.TWO), exact);
      return exact;
    } else if (Types.isFunctionOfType(v, Types.fnATAN)) {
      // 0 => 0, 1/sqrt(3) => pi/6, 1 => pi/4, sqrt(3) => pi/3, infty => pi/2
      // use 3 * square darg & use tolerance
      // 0 => 0, 1 => pi/6, 3 => pi/4, 9 => pi/3, infty => pi/2
      // negative => -1 *
      if (Types.isInfinity(arg)) {
        return arg.value === Infinity ? Expression.div(Types.PI, Types.TWO) :
            Expression.prod(Types.MINUSONE, Expression.div(Types.PI, Types.TWO));
      }
      darg = Types.isInfinity(arg) ? -1 : 3 * darg * darg;
      if (Math.abs(darg - Math.round(darg)) > Config.tolerance)	// integer only
        return null;
      else
        darg = Math.round(darg);
      var exact = null;
      switch (darg) {
        case 0:
          exact = Types.ZERO;
          break;
        case 1:
          exact = Expression.div(Types.PI, Types.asInteger(6));
          break;
        case 3:
          exact = Expression.div(Types.PI, Types.asInteger(4));
          break;
        case 9:
          exact = Expression.div(Types.PI, Types.asInteger(3));
          break;
        default:
          return null;
      }
      if (negative)
        exact = Expression.prod(Types.MINUSONE, exact);
      return exact;
    }

    if (Types.isFunctionOfType(v, Types.fnLOG)) {
      if (arg < 0)
        return Types.UNDEFINED;
      else if (Types.isOne(arg))
        return Types.ZERO;
      else if (Types.isE(arg))
        return Types.ONE;
      else if (Types.isOpOfType(arg, Types.PowOp)) {
        var base = arg.children[0];
        var exp = arg.children[1];
        if (Types.isE(base))
          return exp;
      }
    } else if (Types.isFunctionOfType(v, Types.fnSINH)) {
      if (Types.isZero(arg))
        return Types.ZERO;
    } else if (Types.isFunctionOfType(v, Types.fnCOSH)) {
      if (Types.isZero(arg))
        return Types.ONE;
    } else if (Types.isFunctionOfType(v, Types.fnTANH)) {
      if (Types.isZero(arg))
        return Types.ZERO;
    } else if (Types.isFunctionOfType(v, Types.fnCSCH)) {
      if (Types.isZero(arg))
        return Types.UNDEFINED;
    } else if (Types.isFunctionOfType(v, Types.fnSECH)) {
      if (Types.isZero(arg))
        return Types.ONE;
    } else if (Types.isFunctionOfType(v, Types.fnCOTH)) {
      if (Types.isZero(arg))
        return Types.UNDEFINED;
    } else if (Types.isFunctionOfType(v, Types.fnEXP)) {
      if (Types.isZero(arg))
        return Types.ONE;
    }

    var angle = (darg * 180 / Math.PI);
    if (Math.abs(angle - Math.round(angle)) > Config.tolerance)	// integer degrees
      return null;
    var deg = Math.round(angle) % 360;
    var quad = Math.floor(deg / 90) + 1;
    var acute;
    switch (quad) {
      case 2:
        acute = 180 - deg;
        break;
      case 3:
        acute = deg - 180;
        break;
      case 4:
        acute = 360 - deg;
        break;
      default:
        acute = deg;
    }

    var dosin = function(acute, quad, negate) {
      switch (acute) {
        case 0:
          return Types.ZERO;
        case 30:
          return Types.asFrac(negate ? -1 : 1, 2);
        case 45:
          return Rational.rational_div(negate ? Types.MINUSONE : Types.ONE,
              Expression.construct(Types.PowOp, null, [Types.TWO, Types.HALF]));
        case 60:
          return Rational.rational_div(
              Expression.construct(Types.PowOp, null, [Types.asInteger(3), Types.HALF]),
              negate ? Types.asInteger(-2) : Types.TWO);
        case 90:
          return negate ? Types.MINUSONE : Types.ONE;
      }
      return null;
    }

    var result;
    if (Types.isFunctionOfType(v, Types.fnSIN)) {
      var negate = quad > 2;
      if (negative)
        negate = !negate;
      result = dosin(acute, quad, negate);
    } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
      var negate = quad == 2 || quad == 3;
      if (negative)
        negate = !negate;
      result = dosin(90 - acute, quad, negate);
    } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
      var negate = quad > 2;
      if (negative)
        negate = !negate;
      var s = dosin(acute, quad, negate);
      if (s) {
        negate = quad == 2 || quad == 3;
        var c = dosin(90 - acute, quad, negate);
        if (Types.isZero(c))
          result = Types.UNDEFINED;
        else
          result = Rational.rational_div(s, c);
      }
    } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
      var negate = quad > 2;
      if (negative)
        negate = !negate;
      result = Rational.rational_div(Types.ONE, dosin(acute, quad, negate));
    } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
      var negate = quad == 2 || quad == 3;
      if (negative)
        negate = !negate;
      result = Rational.rational_div(Types.ONE, dosin(90 - acute, quad, negate));
    } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
      var negate = quad == 2 || quad == 3;
      if (negative)
        negate = !negate;
      var c = dosin(90 - acute, quad, negate);
      if (c) {
        negate = quad > 2;
        var s = dosin(acute, quad, negate);
        if (Types.isZero(s))
          result = Types.UNDEFINED;
        else
          result = Rational.rational_div(c, s);
      }
    }

    return result;
  }

  context.convertTrigOddEven = function(v, posarg) {
    var result = null;

    if (Types.isFunctionOfType(v, Types.fnSIN)) {
      result = Expression.construct(Types.ProdOp, null,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnSIN, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
      result = Expression.construct(Types.fn, Types.fnCOS, [posarg]);
    } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnTAN, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnCSC, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
      result = Expression.construct(Types.fn, Types.fnSEC, [posarg]);
    } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnCOT, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnSINH)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnSINH, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnCOSH)) {
      result = Expression.construct(Types.fn, Types.fnCOSH, [posarg]);
    } else if (Types.isFunctionOfType(v, Types.fnTANH)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnTANH, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnCSCH)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnCSCH, [posarg])]);
    } else if (Types.isFunctionOfType(v, Types.fnSECH)) {
      result = Expression.construct(Types.fn, Types.fnSECH, [posarg]);
    } else if (Types.isFunctionOfType(v, Types.fnCOTH)) {
      result = Expression.construct(Types.fn, Types.ProdOp,
          [Types.MINUSONE, Expression.construct(Types.fn, Types.fnCOTH, [posarg])]);
    }

    return result;
  }

  /*
	 * for sin/cos look at n + x:  If n > 2Pi, then reduce % 2Pi, then specifically look at n = Pi/2, Pi, 3Pi/2, 2Pi
	 * (I have already made the constant positive)
	 *
	 * sin(360n + x) = sin(x)
	 * cos(360n + x) = cos(x)
	 * tan(180n + x) = tan(x)
	 * cot(180n + x) = cot(x)
	 *
	 * sin/csc(90 +/- x) = cos/sec(x)
	 * sin/csc(180 +/- x) = -/+sin/csc(x)
	 * sin/csc(270 +/- x) = -cos/sec(x)
	 * sin/csc(360 +/- x) = +/-sin/csc(x)
	 *
	 * cos/sec(90 +/- x) = -/+sin/csc(x)
	 * cos/sec(180 +/- x) = -cos/sec(x)
	 * cos/sec(270 +/- x) = +/-sin/csc(x)
	 * cos/sec(360 +/- x) = cos/sec(x)
	 *
	 * tan/cot(90 +/- x) = -/+cot/tan(x)
	 * tan/cot(180 +/- x) = +/-tan/cot(x)
	 * tan/cot(270 +/- x) = -/+cot/tan(x)
	 * tan/cot(360 +/- x) = +/-tan/cot(x)
	 */
  context.convertTrigPlusMinus = function(v, arg) {
    var result = v;

    var a = Expression.operand(arg, 1);
    if (Types.isRealValue(a)) {
      var f = 0;
      var reverse = false;
      var keep = false;
      var forceplus = false;
      var forceminus = false;
      var da = Types.toRealValue(Expression.numerical_evaluate(a));
      var angle = (da * 180 / Math.PI);
      if (Math.abs(angle - Math.round(angle)) < 1e-14)	// integer degrees
      {
        var deg = Math.round(angle) % 360;
        if (deg == 0)
          deg = 360;
        if (deg == 90) {
          if (Types.isFunctionOfType(v, Types.fnSIN)) {
            f = Types.fnCOS;
            forceplus = true;
          } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
            f = Types.fnSEC;
            forceplus = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
            f = Types.fnSIN;
            reverse = true;
          } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
            f = Types.fnCSC;
            reverse = true;
          } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
            f = Types.fnCOT;
            reverse = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
            f = Types.fnTAN;
            reverse = true;
          }
        } else if (deg == 180) {
          if (Types.isFunctionOfType(v, Types.fnSIN)) {
            f = Types.fnSIN;
            reverse = true;
          } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
            f = Types.fnCSC;
            reverse = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
            f = Types.fnCOS;
            forceminus = true;
          } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
            f = Types.fnSEC;
            forceminus = true;
          } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
            f = Types.fnTAN;
            keep = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
            f = Types.fnCOT;
            keep = true;
          }
        } else if (deg == 270) {
          if (Types.isFunctionOfType(v, Types.fnSIN)) {
            f = Types.fnCOS;
            forceminus = true;
          } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
            f = Types.fnSEC;
            forceminus = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
            f = Types.fnSIN;
            keep = true;
          } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
            f = Types.fnCSC;
            keep = true;
          } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
            f = Types.fnCOT;
            reverse = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
            f = Types.fnTAN;
            reverse = true;
          }
        } else if (deg == 360) {
          if (Types.isFunctionOfType(v, Types.fnSIN)) {
            f = Types.fnSIN;
            keep = true;
          } else if (Types.isFunctionOfType(v, Types.fnCSC)) {
            f = Types.fnCSC;
            keep = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOS)) {
            f = Types.fnCOS;
            forceplus = true;
          } else if (Types.isFunctionOfType(v, Types.fnSEC)) {
            f = Types.fnSEC;
            forceplus = true;
          } else if (Types.isFunctionOfType(v, Types.fnTAN)) {
            f = Types.fnTAN;
            keep = true;
          } else if (Types.isFunctionOfType(v, Types.fnCOT)) {
            f = Types.fnCOT;
            keep = true;
          }
        } else
          return result;
        var b = Expression.dropfirstterm(arg);
        // get the sign of b
        var bisneg = Types.isOpOfType(b, Types.ProdOp) ?
            Types.isNegativeRealValue(Expression.operand(b, 1)) : Types.isNegativeRealValue(b);
        // get abs b
        if (bisneg && !keep)
          b = Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null, [Types.MINUSONE, b]));
        // get f(b)
        result = Expression.construct(Types.fn, f, [b]);
        // and now get the sign
        if ((reverse && !bisneg) || forceminus) {
          result = Simplify.automatic_simplify(
              Expression.construct(Types.ProdOp, null, [Types.MINUSONE, result]));
        }
      }
    }

    return result;
  }

  context.checkinversepair = function(f1, f2, e1, e2) {
    if (!lasterror && Types.isFunctionOfType(e1, f1) && Types.isFunctionOfType(e2, f2))
      return context.getArgument(e2, 1);
    else
      return null;
  }

  context.checkinverses = function(e) {
    var e2 = null, result = null;

    if (!Types.isFunction(e) || Expression.num_operands(e) != 1)
      return e;

    // look for inverses
    e2 = context.getArgument(e, 1);
    if (Types.isFunction(e2) && Expression.num_operands(e2) == 1) {
      var functions =
          [Types.fnEXP, Types.fnSIN, Types.fnCOS, Types.fnTAN, Types.fnSINH, Types.fnCOSH, Types.fnTANH];
      var inverses =
          [Types.fnLOG, Types.fnASIN, Types.fnACOS, Types.fnATAN, Types.fnASINH, Types.fnACOSH, Types.fnATANH];

      for (var i = 0; !lasterror && i < functions.length; ++i) {
        result = context.checkinversepair(functions[i], inverses[i], e, e2);
        if (result)
          return result;
        if (Config.naiveLog || i > 0) {
          result = context.checkinversepair(inverses[i], functions[i], e, e2);
          if (result)
            return result;
        }
      }
    }
    return e;
  }

  /*
	 * replace sin/cos => tan, cos/sin => cot, 1/cos => sec, 1/sin => csc
	 * replace sinh/cosh => tanh, cosh/sinh => coth, 1/cosh => sech, 1/sinh => csch
	 */
  context.trigtransform = function(e) {
    var n = Simplify.automatic_simplify(context.trigoddeven(Rational.numerator(e)));
    var d = Simplify.automatic_simplify(context.trigoddeven(Rational.denominator(e)));
    /*
		 * better algorithm
		if dhascos
		walk through d and search for matching in n
		check same arg and exp with base same arg
		*/

    var temp;
    // remove the cos from the Rational.denominator
    while (temp = context.removeTrigWithArg(Types.fnCOS, d)) {
      // if matching sin in the Rational.numerator, change it to tan
      // else add sec to the Rational.numerator
      d = temp.rest;
      n = context.replaceTrigWithArg(Types.fnSIN, Types.fnTAN, Types.fnSEC,
          context.getArgument(temp.trig, 1), n);
    }
    ;

    // remove the sin from the Rational.denominator
    while (temp = context.removeTrigWithArg(Types.fnSIN, d)) {
      // if matching cos in the Rational.numerator, change it to cot
      // else add csc to the Rational.numerator
      d = temp.rest;
      n = context.replaceTrigWithArg(Types.fnCOS, Types.fnCOT, Types.fnCSC,
          context.getArgument(temp.trig, 1), n);
    }
    ;

    // remove the cosh from the Rational.denominator
    while (temp = context.removeTrigWithArg(Types.fnCOSH, d)) {
      // if matching sin in the Rational.numerator, change it to tan
      // else add sec to the Rational.numerator
      d = temp.rest;
      n = context.replaceTrigWithArg(Types.fnSINH, Types.fnTANH, Types.fnSECH,
          context.getArgument(temp.trig, 1), n);
    }
    ;

    // remove the sin from the Rational.denominator
    while (temp = context.removeTrigWithArg(Types.fnSINH, d)) {
      // if matching cos in the Rational.numerator, change it to cot
      // else add csc to the Rational.numerator
      d = temp.rest;
      n = context.replaceTrigWithArg(Types.fnCOSH, Types.fnCOTH, Types.fnCSCH,
          context.getArgument(temp.trig, 1), n);
    }
    ;

    if (Types.isOne(d))
      return Simplify.automatic_simplify(n);
    else
      return Simplify.automatic_simplify(Expression.construct(Types.QuotOp, null, [n, d]));
  }

  /*
	 * Manage trig products
	 */
  // return the trig argument, modify the expression in place
  context.removeTrigWithArg = function(f, e) {
    var result = null;

    if (Types.isFunctionOfType(e, f)) {
      result = {trig: e, rest: Types.ONE};
    } else if (Types.isOpOfType(e, Types.ProdOp)) {
      for (var i = 1; i <= Expression.num_operands(e); ++i) {
        var term = Expression.operand(e, i);
        if (Types.isFunctionOfType(term, f)) {
          e = Expression.dropnthterm(e, i);
          result = {trig: term, rest: e};  // this is our function with its argument
          break;
        }
      }
    }
    return result;
  }

  // if f0(args), then replace with f1(args)
  // else multiply by f2(args)
  context.replaceTrigWithArg = function(f0, f1, f2, args, e) {
    if (Types.isFunctionOfType(e, f0)) {
      if (Expression.equal_expressions(context.getArgument(e, 1), args))
        return Simplify.automatic_simplify(Expression.construct(Types.fn, f1, [args]));
      else
        return e;
    } else if (Types.isOpOfType(e, Types.ProdOp)) {
      for (var i = 1; i <= Expression.num_operands(e); ++i) {
        var term = Expression.operand(e, i);
        if (Types.isFunctionOfType(term, f0) && Expression.equal_expressions(
            context.getArgument(term, 1), args)) {
          e.children[i - 1] = Simplify.automatic_simplify(Expression.construct(Types.fn, f1, [args]));
          return e;
        }
      }
    }

    var f = Expression.construct(Types.fn, f2, [args]);
    return Simplify.automatic_simplify(Expression.construct(Types.ProdOp, null, [f, e]));
  }

  // replace any e^expr with exp(expr)
  context.replaceewithexp = function(e) {
    if (Expression.equal_expressions(e, Types.E))
      return Expression.construct(Types.fn, Types.fnEXP, [Types.ONE]);
    if (Types.isOpOfType(e, Types.PowOp)) {
      var base = Expression.operand(e, 1);
      if (Types.isE(base)) {
        // change in place
        var exponent = Expression.operand(e, 2);
        e.type = Types.fn;
        e.value = Types.fnEXP;
        e.children = [exponent];
      }
    }
    return e;
  }

  // replace any exp(expr) with e^expr
  context.replaceexpwithe = function(e) {
    if (Types.isFunctionOfType(e, Types.fnEXP)) {
      var arg = Expression.operand(e, 1);
      // change in place
      e.type = Types.PowOp;
      e.value = null;
      e.children = [Types.E, arg];
    }
    return e;
  }

  context.handleexp = function(e, reverse) {
    var myhandle = function(e) {
      return context.handleexp(e, reverse);
    }
    e = reverse ? context.replaceexpwithe(e) : context.replaceewithexp(e);
    if (e.children)
      e.children.forEach(myhandle);
    return e;
  }

  var factors = KBIFactors();

  context.fracpowerrules = function(u) {
    if (lasterror)
      return Types.UNDEFINED;

    var result;
    if (Types.isOpOfType(u, Types.PowOp)) {
      result = convertFractionalPower(u);
      return result;
    } else if (Types.isOpOfType(u, Types.ProdOp)) {
      // turn integers into their prime factors, rationals into factorised numerator & denominator

      var num = [];
      var denom = [];
      var extra = [];
      var sn = false;
      var cs;
      var updatePowers = function(cs, pa) {
        Object.keys(cs).forEach(k => {
          if (pa[k])
            pa[k] = KBR.add(pa[k], cs[k]);
          else
            pa[k] = cs[k];
        });
      }

      u.children.map(c => {
        var result = null;
        if (isFractionalPower(c)) {
          var fpc = fractionalPowerComponents(c);
          if (fpc) {
            updatePowers(fpc.fs, num);
            updatePowers(fpc.gs, denom);
            if (fpc.sn)
              sn = !sn;
          }
        } else if (Types.isInteger(c)) {
          if (Types.isNegativeIntegerValue(c))
            sn = !sn;
          cs = getPrimePowers(c);
          if (cs)
            updatePowers(cs, num);
        } else if (Types.isRationalValue(c)) {
          if (Types.isNegativeRationalValue(c))
            sn = !sn;
          cs = getPrimePowers(Rational.numerator(c));
          if (cs)
            updatePowers(cs, num);
          cs = getPrimePowers(Rational.denominator(c));
          if (cs)
            updatePowers(cs, denom);
        } else
          extra.push(c);
      });

      var powers = combinePowersForSameBase(num, denom);
      result = powersToProduct(powers, sn);
      if (!result)
        return u;
      if (extra.length)
        result = Expression.prodAll([...extra, result]);
      return result;
    } else
      return u;
  }

  var getPrimePowers = function(c) {
    var s = Types.isNegativeIntegerValue(c);
    if (s)
      c.value = KBI.negate(c.value);
    var fs = factors.factors(c.value);
    var cs = [];
    fs.forEach(e => cs[e] ? cs[e] = cs[e] + 1 : cs[e] = 1);
    return cs;
  }

  var powersToProduct = function(cs, negate) {
    var terms = Object.keys(cs).map(p => {
      var base = Types.asInteger(Number(p));
      if (KBR.greaterThan(cs[p], KBR.fONE)) {
        var intpow = Types.asInteger(KBR.integerPart(cs[p]));
        var mul = Expression.makenode(Types.PowOp, null, [base, intpow]);
        var fracpow = Types.asFrac(KBR.fracPart(cs[p]));
        var term = Expression.makenode(Types.ProdOp, null,
            [mul, Expression.makenode(Types.PowOp, null, [base, fracpow])]);
        return term;
      } else if (KBR.lessThan(cs[p], KBR.fONE)) {
        var pow = Types.asFrac(cs[p]);
        var term = Expression.makenode(Types.PowOp, null, [base, pow]);
        return term;
      } else
        return base;
    });
    if (negate)
      terms.unshift(Types.MINUSONE);
    if (terms.length > 1)
      return Expression.makenode(Types.ProdOp, null, terms);
    else
      return terms[0];
  }

  var isFractionalPower = function(u) {
    return Types.isOpOfType(u, Types.PowOp) && Types.isRationalValue(Expression.base(u)) &&
        Types.isRationalValue(Expression.exponent(u));
  }

  var fractionalPowerComponents = function(u) {
    var base, power, root;

    if (!Types.isOpOfType(u, Types.PowOp))
      return null;

    var v = Expression.base(u);
    var w = Expression.exponent(u);

    if (!Types.isRationalValue(v) || !Types.isRationalValue(w))
      return null;

    base = Types.toFrac(v);

    if (Types.isInteger(w)) {
      power = w.value;
      root = 1;
    } else {
      power = w.value.n;
      root = w.value.d;
    }

    if (Types.isNegativeRationalValue(w)) {
      var t = base.n;
      base.n = t < 0 ? -base.d : base.d;
      base.d = t < 0 ? -t : t;
      power = -power;
    }

    // adjust the power
    var gcd = KBI.gcd(power, root);
    if (gcd > 1) {
      power = KBI.div(power, gcd);
      root = KBI.div(root, gcd);
    }

    var n = base.n;
    var neg = n < 0;
    if (neg)
      n = -n;
    var fs = makePowerMult(factors.factors(n), power, root);
    var d = base.d;
    var gs = makePowerMult(factors.factors(d), power, root);

    // sn true means negate
    return {neg: neg, fs: fs, gs: gs};
  }

  var convertFractionalPower = function(u) {
    var fpc = fractionalPowerComponents(u);
    if (!fpc) return u;

    var hs = combinePowersForSameBase(fpc.fs, fpc.gs);

    var num = fpc.neg ? Types.MINUSONE : Types.ONE;
    var invdenom = Types.ONE;

    Object.keys(hs).forEach(k => {
      k = Number(k);
      var base = Types.asInteger(k);
      var p = hs[k].n ? hs[k].n : hs[k];
      var r = hs[k].d ? hs[k].d : 1;
      var pow = Expression.div(Types.asInteger(p % r), Types.asInteger(r));
      var result = Expression.makenode(Types.PowOp, null, [base, pow]);
      if (Math.abs(p) > r)
        result = Expression.makenode(Types.ProdOp, null,
            [Expression.pow(base, Types.asInteger(Math.round(p / r))), result]);
      if (p > 0)
        num = Expression.makenode(Types.ProdOp, null, [num, result]);
      else
        invdenom = Expression.makenode(Types.ProdOp, null, [invdenom, result]);
    });

    return Simplify.automatic_simplify(Expression.makenode(Types.ProdOp, null, [num, invdenom]));
  }

  var makePowerMult = function(xs, p, r) {
    var cs = [];
    xs.forEach(e => cs[e] ? cs[e] = cs[e] + 1 : cs[e] = 1);
    Object.keys(cs).forEach(k => {
      cs[k] = KBR.toFraction(cs[k] * p, r)
    });
    return cs;
  }

  var combinePowersForSameBase = function(xs, ys) {
    if (!ys)
      return xs;
    else {
      Object.keys(ys).forEach(p => {
        if (xs[p]) {
          xs[p] = KBR.sub(xs[p], ys[p]);
          ys[p] = null;
        }
      });
      Object.keys(ys).forEach(p => {
        if (!xs[p])
          xs[p] = KBR.negate(ys[p]);
      });
    }

    return xs;
  }

  var applytransformfracpower = function(e) {
    if (Types.isZero(e))
      return Types.ZERO;
    else if (Types.isOne(e))
      return Types.ONE;

    var v = Expression.map(context.transformfracpower, e);
    if (Types.isOpOfType(v, Types.PowOp) || Types.isOpOfType(v, Types.ProdOp)) {
      var result = context.fracpowerrules(v);
      return lasterror ? Types.UNDEFINED : Simplify.automatic_simplify(result);
    } else {
      return v;// Simplify.automatic_simplify(v);
    }
  }

  context.transformfracpowersum = function(e) {
    if (Types.isOpOfType(e, Types.SumOp)) {
      e.children = e.children.map(context.transformfracpower);
      var a0 = e.children[0];
      var combine = Types.ONE;
      var apart = [];
      for (var i = 1; i < e.children.length; ++i) {
        var a1 = Transform.transformfracpower(Expression.div(e.children[i], a0));
        if (Types.isRationalValue(a1))
          combine = Expression.sum(combine, a1);
        else
          apart.push(a1);
      }
      if (!Types.isOne(combine))
        return Expression.sumAll([Expression.prod(combine, a0), ...apart]);
    }
    return e;
  }

  context.transformfracpower = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    var save = Expression.copy(e);

    if (Types.isOpOfType(e, Types.SumOp)) {
      return context.transformfracpowersum(e);
    } else if (Types.isFunction(e)) {
      e.children = e.children.map(context.transformfracpower);
      return e;
    } else {
      e = Rational.rationalise_expression(e);
      e = Rational.rational_expand(e);
      var n = applytransformfracpower(Rational.numerator(e));
      var d = applytransformfracpower(Rational.denominator(e));

      if (Types.isZero(d))
        return Types.UNDEFINED;
      else if (Types.isOne(d))
        return n;

      var result = Expression.div(n, d);
      result = applytransformfracpower(result);
    }

    if (Expression.equal_expressions(result, save))
      return result;
    else
      return context.transformfracpower(result);
  }

  context.simplifyexp = function(e) {
    if (lasterror)
      return Types.UNDEFINED;

    e = context.handleexp(e);
    e = Rational.rational_expand(e);

    var n = context.contractlog(context.contractexp(Expand.algebraic_expand(Rational.numerator(e))));
    var d = context.contractlog(context.contractexp(Expand.algebraic_expand(Rational.denominator(e))));

    if (Types.isZero(d))
      return Types.UNDEFINED;
    else if (Types.isOne(d))
      return context.handleexp(n, true);
    else {
      var result = Simplify.automatic_simplify(Expression.construct(Types.QuotOp, null, [n, d]));
      return context.handleexp(result, true);
    }
  }

  context.simplifytrig = function(e) {
    var v, w, n, d;

    if (lasterror)
      return Types.UNDEFINED;

    v = context.trigsubstitute(e, true);//context.containsCosOrSin(e, true, true));
    w = Rational.rationalise_expression(v);
    //  w = context.trigoddeven(w);
    // 	w = context.trigtransform(w);
    n = context.expandtrig(Rational.numerator(w));
    n = context.contracttrig(Simplify.automatic_simplify(n));
    d = context.expandtrig(Rational.denominator(w));
    d = context.contracttrig(d);

    if (Types.isZero(d))
      return Types.UNDEFINED;
    else if (Types.isOne(d)) {
      return context.trigtransform(n);
    } else {
      v = context.trigtransform(Expression.construct(Types.QuotOp, null, [n, d]));
      return v;
    }
  }

  context.expandspecial = function(e) {
    e = context.trigsubstitute(e, true);//context.containsCosOrSin(e, true, true));
    return Transform.trigtransform(Transform.expandtrig(
        Transform.expandexp(
            Transform.expandlog(e))));
  };

  context.contractspecial = function(e) {
    return Transform.contracttrig(
        Transform.contractexp(
            Transform.contractlog(e)));
  };

  context.simplifyspecial = function(e) {
    return Transform.simplifytrig(
        Transform.simplifyexp(e));
  };

  context.simplifyall = function(e) {
    if (context.containsLog(e))
      e = context.simplifyexp(e);
    if (context.containsTrig(e, 1, 1))
      e = context.simplifytrig(e);
    e = context.transformfracpower(e);
    e = Simplify.factor_out(e);
    return e;
  }
})(Transform);


var Types = {
  integer: 100,
  fraction: 101,
  real: 102,
  complex: 103,
  symbol: 104,
  fn: 105,
  list: 106,
  string: 107,

  PowOp: '^',
  ProdOp: '*',
  CrossOp: '⨯',
  SumOp: '+',
  QuotOp: '/',
  DiffOp: '-',
  FactOp: '!',
  ModOp: '%',
  Deriv: '\'',
  Equate: '=',
  GTE: '≥',
  GT: '>',
  LTE: '≤',
  LT: '<',
  NEQ: '≠',

  Infinity: 196,
  Undefined: 197,
  UnknownOp: 198,
  UnknownType: 199,

  fnLOG: "ln",
  fnLOG10: "log",
  fnEXP: "exp",
  fnSIN: "sin",
  fnCOS: "cos",
  fnTAN: "tan",
  fnCSC: "cosec",
  fnSEC: "sec",
  fnCOT: "cot",
  fnASIN: "arcsin",
  fnACOS: "arccos",
  fnATAN: "arctan",
  fnSINH: "sinh",
  fnCOSH: "cosh",
  fnTANH: "tanh",
  fnASINH: "arcsinh",
  fnACOSH: "arccosh",
  fnATANH: "arctanh",
  fnCSCH: "cosech",
  fnSECH: "sech",
  fnCOTH: "coth",
  fnROUND: "round",
  fnFRAC: "tofrac",
  fnDEC: "decimal",
  fnRND: "random",
  fnSCI: "sci",
  fnGCD: "gcd",
  fnLCM: "lcm",
  fnCHOOSE: "choose",
  fnABS: "abs",
  fnARG: "arg",
  fnNTOR: "numerator",
  fnDTOR: "denominator",

  fnF: "F",
  fnG: "G",

  fnD: "Deriv",
  fnI: "Integral",

  pi: "pi",
  e: "e",
  i: "i",

  isUndefined: function(u) {
    return u.type == Types.Undefined || !Expression.free_of(u, Types.UNDEFINED);
  },

  isZero: function(u) {
    if (u.children)
      return false;
    switch (u.type) {
      case Types.integer:
        return u.value === 0 || KBI.isZero(u.value);
      case Types.real:
        return u.value === 0;
      case Types.fraction:
        return KBI.isZero(u.value.n) && !KBI.isZero(u.value.d);
      case Types.complex:
        return Types.isZero(u.value.r) && Types.isZero(u.value.i);
      default:
        return false;
    }
  },

  isOne: function(u) {
    if (u.children)
      return false;
    switch (u.type) {
      case Types.integer:
        return u.value === 1 || KBI.isOne(u.value);
      case Types.real:
        return u.value === 1;
      case Types.fraction:
        return KBI.equals(u.value.n, u.value.d);
      case Types.complex:
        return Types.isOne(u.value.r) && Types.isZero(u.value.i);
      default:
        return false;
    }
  },

  isMinusOne: function(u) {
    return u.type === Types.integer &&
        u.value === -1 &&
        u.children == null;
  },

  isInfinity: function(u) {
    return u.type === Types.Infinity;
  },

  isInteger: function(u) {
    return u.type === Types.integer;
  },

  isFraction: function(u) {
    return u.type === Types.fraction;
  },

  isRationalValue: function(u) {
    return u.type === Types.integer || u.type === Types.fraction;
  },

  isBasicRealValue: function(u) {
    return u.type === Types.real;
  },

  isRealValue: function(u) {
    if (Types.isNumber(u) && u.type !== Types.complex)
      return true;
    else if (Types.isPi(u) || Types.isE(u))
      return true;
    else if (Types.isFunction(u))
      return false;
    else
      return u.children && u.children.every(Types.isRealValue);
  },

  isComplex: function(u) {
    return u.type == Types.complex || Types.isI(u);
  },

  isFullyComplex: function(u) {
    return u.type == Types.complex && !Types.isZero(u.value.r) && !Types.isZero(u.value.i);
  },

  isImaginary: function(u) {
    if (Types.isComplex(u))
      return Types.isZero(u.value.r) && !Types.isZero(u.value.i);
    else if (Types.isOpOfType(u, Types.ProdOp)) {
      if (!u.children.every(Types.isGeneralisedNumber))
        return false;
      var isim = false;
      u.children.forEach(c => {
        if (Types.isImaginary(c))
          isim = !isim;
      });
      return isim;
    } else if (Types.isOpOfType(u, Types.SumOp))
      return u.children.every(Types.isImaginary);
    else
      return false;
  },

  reducesToComplex: function(u) {
    if (Types.isComplex(u))
      return true;
    else if (Types.isOperator(u))
      return u.children.every(Types.reducesToNumber) && u.children.some(Types.reducesToComplex);
    else
      return false;
  },

  isSpecialConstant: function(u) {
    return Types.isPi(u) || Types.isE(u) || Types.isI(u);
  },

  isPi: function(u) {
    return Types.isSymbol(u) && u.value === Types.pi;
  },

  isE: function(u) {
    return Types.isSymbol(u) && u.value === Types.e;
  },

  isI: function(u) {
    if (Config.supportComplex) {
      switch (u.type) {
        case Types.complex:
          return Types.isOne(u.value.i) && Types.isZero(u.value.r);
        case Types.symbol:
          return u.value === Types.i;
      }
    }
    return false;
  },

  isNumber: function(u) {
    return u && (u.type == Types.real || u.type == Types.integer ||
        u.type == Types.complex || u.type == Types.fraction);
  },

  isGeneralisedNumber: function(u) {
    return Types.isNumber(u) || Types.isSpecialConstant(u)
  },

  reducesToNumber: function(u, nofunction) {
    if (Types.isGeneralisedNumber(u))
      return true;
    else if (Types.isOperator(u))
      return u.children.every((e) => Types.reducesToNumber(e, nofunction));
    else if (Types.isFunction(u))
      return nofunction ? false : u.children.every((e) => Types.reducesToNumber(e, nofunction));
    else
      return false;
  },

  includesRealNumber: function(u) {
    if (!u)
      return false;
    else if (u.type == Types.real)
      return true;
    else if (Types.isOperator(u))
      return u.children.some(Types.includesRealNumber);
    else if (Types.isFunction(u))
      return u.children.some(Types.includesRealNumber);
    else
      return false;
  },

  isPositiveIntegerValue: function(u) {
    return u.type == Types.integer && KBI.isPositive(u.value);
  },

  isNegativeIntegerValue: function(u) {
    return u.type == Types.integer && KBI.isNegative(u.value);
  },

  isPositiveRationalValue: function(u) {
    return Types.isPositiveIntegerValue(u) || (u.type == Types.fraction && KBI.isPositive(u.value.n));
  },

  isNegativeRationalValue: function(u) {
    return Types.isNegativeIntegerValue(u) || (u.type == Types.fraction && KBI.isNegative(u.value.n));
  },

  isPositiveRealValue: function(u) {
    return u.type == Types.real && Types.toRealValue(u) > 0 || Types.isPositiveRationalValue(u);
  },

  isNegativeRealValue: function(u) {
    return u.type == Types.real && Types.toRealValue(u) < 0 || Types.isNegativeRationalValue(u);
  },

  isNegativeValue: function(u) {
    if (u.type == Types.complex) {
      if (Types.isZero(u.value.i))
        return Types.isNegativeRealValue(u.value.r);
      else if (Types.isZero(u.value.r))
        return Types.isNegativeRealValue(u.value.i);
      return false;
    } else
      return Types.isNegativeRealValue(u);
  },

  isFunction: function(u) {
    return u.type == Types.fn;
  },

  isFunctionOfType: function(u, type) {
    return u.type == Types.fn && u.value == type;
  },

  isSymbol: function(u) {
    return u.type == Types.symbol;
  },

  isOperator: function(u) {
    return typeof u.type == 'string' && u.type.length == 1;
  },

  isOpOfType: function(e, type) {
    return e && Types.isOperator(e) && e.type == type;
  },

  isValueOfType: function(e, type) {
    return e && Types.isNumber(e) && e.type == type;
  },

  setContains: function(e, S) {
    if (Array.isArray(S)) {
      for (var i = 0; i < S.length; ++i)
        if (Expression.equal_expressions(S[i], e))
          return true;
    }
    return false;
  },

  asInteger: function(n) {
    return Expression.construct(Types.integer, KBI.fromInteger(n), null);
  },

  modInteger: function(n, m) {
    var v = KBI.mod(n.value, m.value);
    if (KBI.isNegative(v))
      v = KBI.add(v, m.value);
    return Types.asInteger(KBI.mod(v, m.value));
  },

  asFrac: function(n, d) {
    if (d === 0 || n.d === 0)
      return n > 0 ? Types.INFINITY : Types.NEGATIVEINFINITY;
    else if (n === 0 || n.n === 0)
      return Types.ZERO;

    if (d === undefined) {
      if (n.n && n.d) {
        if (KBI.isNegative(n.d)) {
          n.d = -n.d;
          n.n = -n.n;
        } else if (KBI.isOne(n.d))
          return Expression.construct(Types.integer, n.n, null);
        else
          return Expression.construct(Types.fraction, n, null);
      } else if (AvantiUtils.isinteger(n)) {
        return Expression.construct(Types.integer, n, null);
      } else
        return Types.UNDEFINED;
    } else if (KBI.isZero(d))
      return Types.UNDEFINED;
    else {
      var val = KBR.toFraction(n, d);
      if (KBI.isOne(val.d))
        return Expression.construct(Types.integer, val.n, null);
      else
        return Expression.construct(Types.fraction, val, null);
    }
  },

  // complex parts need to be mpl types
  asComplex: function(r, i) {
    return Expression.construct(Types.complex, Complex.init(r, i), null);
  },

  asReal: function(x) {
    return Expression.construct(Types.real, Types.toRealValue(x), null);
  },

  asString: function(s) {
    if (s.type === Types.string)
      return s;
    return Expression.construct(Types.string, s.toString(), null);
  },

  toRealValue: function(t) {
    if (typeof t === "number")
      return t;
    switch (t.type) {
      case Types.integer:
        return KBI.toDecimal(t.value);
      case Types.real:
        return t.value;
      case Types.fraction:
        return KBR.toDecimal(t.value);
      case Types.symbol:
        if (Types.isPi(t))
          return Math.PI;
        else if (Types.isE(t))
          return Math.E;
    }
    if (Types.reducesToComplex(t))
      return undefined;
    else if (Types.reducesToNumber(t))
      return Types.toRealValue(Expression.numerical_evaluate(t));
    return undefined;
  },

  // truncates
  toInteger: function(t) {
    switch (t.type) {
      case Types.integer:
        return t.value;
      case Types.real:
        return Math.floor(t.value);
      case Types.fraction:
        return KBR.integerPart(t.value);
    }
    if (Types.reducesToComplex(t))
      return Types.isZero(Complex.im(t)) ? Types.toInteger(Complex.re(t)) : undefined;
    else if (Types.reducesToNumber(t))
      return Types.toInteger(Expression.numerical_evaluate(t));

    return undefined;
  },

  toFrac: function(t) {
    switch (t.type) {
      case Types.integer:
        return {n: t.value, d: 1};
      case Types.fraction:
        return t.value;
    }
    if (Types.reducesToComplex(t))
      return Types.isZero(Complex.im(t)) ? Types.toFrac(Complex.re(t)) : undefined;
    else if (Types.reducesToNumber(t))
      return Types.toFrac(Expression.numerical_evaluate(t));
    return undefined;
  },

  toComplex: function(t) {
    switch (t.type) {
      case Types.integer:
      case Types.fraction:
      case Types.real:
        return Complex.init(t, Types.ZERO);
      case Types.complex:
        return t.value;
    }
    if (Types.reducesToComplex(t)) {
      var parts = Polynomial.linear_form(Transform.simplifyall(t), Types.I);
      if (parts)
        return Complex.init(parts[1], parts[0]);
    } else if (Types.reducesToNumber(t))
      return Complex.init(t, Types.ZERO);

    return undefined;
  },

  numToString: function(t) {
    switch (t.type) {
      case Types.integer:
        return t.value + "";
      case Types.real:
        return ("" + parseFloat(t.value.toPrecision(Config.digits))).replace(/e/, 'E');
      case Types.fraction:	// TODO is it ok to always do brackets here?
        return "(" + t.value.n + "/" + t.value.d + ")";
      case Types.complex:
        return Complex.numToString(t);
      default:
        return "NaN";
    }
  },

  // call after the Expression object is constructed
  initConstants: function() {
    Types.UNDEFINED = Expression.construct(Types.Undefined, undefined, null);
    Types.ZERO = Types.asInteger(0);
    Types.ONE = Types.asInteger(1);
    Types.TWO = Types.asInteger(2);
    Types.MINUSONE = Types.asInteger(-1);
    Types.HALF = Types.asFrac(1, 2);
    Types.INFINITY = Expression.construct(Types.Infinity, Infinity, null);
    Types.NEGATIVEINFINITY = Expression.construct(Types.Infinity, -Infinity, null);

    Types.PI = Expression.construct(Types.symbol, '\pi', null);
    Types.E = Expression.construct(Types.symbol, 'e', null);
    if (Config.supportComplex) {
// 			Types.I = Expression.construct(Types.symbol, 'i', null);
      Types.I = Expression.construct(Types.complex, {
        r: Types.ZERO,
        i: Types.ONE
      }, null);
    }

    Types.A = Expression.construct(Types.symbol, 'A', null);
    Types.B = Expression.construct(Types.symbol, 'B', null);
    Types.C = Expression.construct(Types.symbol, 'C', null);
    Types.N = Expression.construct(Types.symbol, 'N', null);
    Types.X = Expression.construct(Types.symbol, 'x', null);
    Types.Y = Expression.construct(Types.symbol, 'y', null);
  }
}

function isExpression(expression) {
  return !!(expression.length && !expression.match("="));
}

function isEquation(expression) {
  var sides = expression.split("=");
  return sides.length == 2 && isExpression(sides[0]) && isExpression(sides[1]);
}

function isInequation(expression) {
  var sides = expression.split(/<=|>=|<|>|≤|≥|\\ge[^a-z]|\\le[^a-z]|\\lt|\\gt/);
  return sides.length == 2 && isExpression(sides[0]) && (sides[1] === "" || isExpression(sides[1]));
}

function canExpand(expression) {
  return (isExpression(expression) || isEquation(expression));// &&
}

function canSubstitute(expression) {
  var parts = expression.split(",");
  if (parts.length < 2)
    return false;
  var sub = parts.pop();
  return parts.every(e => isExpression(e) || isEquation(e)) && isEquation(sub);
}

var loaded = false;
var parser = new Parser();
var factors = KBIFactors();
var humanise = new Humanise();

var fullexpand = function(u) {
  Expand.expand_complex_powers = true;
  if (Array.isArray(u))
    return u.map(fullexpand);
  else if (Solve.isEquation(u)) {
    var split = Solve.splitEquation(u);
    var lhs = fullexpand(split.lhs);
    var rhs = fullexpand(split.rhs);
    return Solve.equate(lhs, rhs);
  } else {
    u = Transform.trigsubstitute(u, 1);
    var v = Rational.rationalise_expression(Expand.algebraic_expand(u));
    v = Rational.rational_expand(v);
    v = Rational.cancel(v);
    v = Simplify.automatic_simplify(v);
    var n = Rational.numerator(v);
    var d = Rational.denominator(v);
    var nx = Expand.algebraic_expand(Transform.expandspecial(n));
    var dx = Expand.algebraic_expand(Transform.expandspecial(d));
    return Types.isOne(dx) ? nx : Expression.construct(Types.QuotOp, null, [nx, dx]);
  }
};

var evaluate = function(u) {
  if (Array.isArray(u))
    return u.map(evaluate);
  else if (Solve.isEquation(u)) {
    var split = Solve.splitEquation(u);
    var lhs = evaluate(split.lhs);
    var rhs = evaluate(split.rhs);
    return Solve.equate(lhs, rhs);
  } else {
    var result = Expression.numerical_evaluate(u);
    if (Rational.is_rational(result)) {
      var v = Rational.rationalise_expression(u);
      var n = Rational.numerator(v);
      var d = Rational.denominator(v);
      var nf = Transform.simplifyall(n);
      var df = Transform.simplifyall(d);
      result = Types.isOne(df) ? nf : Rational.poly_div(Rational.rational_div(nf, df));
    }
    return Types.isUndefined(result) ? Types.UNDEFINED : result;
  }
};

var fullsimplify = function(u) {
  if (Array.isArray(u))
    return u.map(fullsimplify);
  Expand.expand_complex_powers = false;
  if (Solve.isEquation(u)) {
    var split = Solve.splitEquation(u);
    var lhs = fullsimplify(split.lhs);
    var rhs = fullsimplify(split.rhs);
    return Solve.equate(lhs, rhs);
  } else {
    u = Transform.trigsubstitute(u, 1);
    var result = Rational.rational_simplify(u);
    var d = Rational.denominator(u);
    if (Types.reducesToNumber(d)) {
      result = Transform.simplifyall(result);
    }
    if (Expression.equal_expressions(u, result)) {
      var alt;
      if (Rational.is_rational(result)) {
        var L = Expression.getVariables(result);
        if (L.length == 1) {
          var x = L[0];
          var n = Expand.algebraic_expand(Rational.numerator(result));
          var d = Expand.algebraic_expand(Rational.denominator(result));
          if (Polynomial.polynomial_sv(n, x) && Polynomial.polynomial_sv(d, x)) {
            alt = Rational.partial_fraction(result, x);
            if (!Expression.equal_expressions(u, alt))
              return alt;
          }
        }
      }
    }
    if (!Expression.equal_expressions(u, result)) {
      return result;
    }
    if (Types.isOpOfType(result, Types.SumOp)) {
      result = Expression.map(fullsimplify, result);
    }
    if (Expression.equal_expressions(u, result)) {
      result = Expand.algebraic_expand(result);
      return result;
    }
    return result;
  }
};

var getvariable = function(u, fn) {
  var x = parser.fromInfix("x");
  var L;
  if (Array.isArray(u))
    L = [].concat(...u.map(Expression.getVariables)).filter(
        (c, i, a) => i === a.findIndex(e => c.value === e.value));
  else
    L = Expression.getVariables(u);
  L = L.filter(v => !/[A-Z]/.test(v.value));

  if (!fn) {
    if (L.length && L.findIndex(e => Expression.equal_expressions(e, x)) < 0)
      return L[0];
    else
      return x;
  }

  if (L.length == 0) {
    fn(x);
  } else if (L.length == 1) {
    fn(L[0]);
  } else if (true)	// avoid dialog
  {
    fn(x);
  } else {
    var makeButton = function(v) {
      var text = Expression.printInfix(v);
      var html = '<button class="varbtn"><span id="' + text + '">';
      html += text;
      html += '</span></button>';
      return html;
    }
    var html = 'Choose variable: ';
    L.forEach(v => html += makeButton(v));

    var div = $('<div id="tempdialogdiv">');
    div.html(html);
    divalert(div, "Choose variable", "OK", null, function() {
      $('.varbtn').click(function() {
        v = $(this).children().first().attr("id");
        var x = parser.fromInfix(v);
        $(div).dialog('close');
        fn(x);
      });
    }, 400, function() {
    });
  }
}

// make (a*x) as variable work with factorise
var factorise = function(u, x) {
  var result;
  if (Types.isInteger(u)) {
    var n = Types.toInteger(u);
    var s = n > 0;
    if (!s)
      n = -n;
    var fs = factors.factors(n);
    var c = [];
    fs.forEach(e => c[e] ? c[e] = c[e] + 1 : c[e] = 1);
    result = {
      special: true,
      latex: (s ? "" : "-") + Object.keys(c).map(k => c[k] > 1 ? k + "^{" + c[k] + "}" : k).join("\\cdot ")
    };
    return result;
  } else if (Expression.free_of(u, x)) {
    return u;
  } else {
    u = Rational.rationalise_expression(u);
    var n = Rational.numerator(u);
    var d = Rational.denominator(u);
    var varn = x ? x : getvariable(n);
    var vard = x ? x : getvariable(d);
    return Rational.rational_factorise(u, varn, vard);
  }
}

var derivative = function(u, x) {
  if (!x) x = getvariable(u);
  return Calculus.derivative(u, x);
};

var integral = function(u, x) {
  var nextConst = function(c) {
    var next = String.fromCharCode(constant.charCodeAt(0) + 1);
    // all these constants cause difficulties somewhere... (mostly in JessieCode)
    if (next === "D" || next === "E" || next === "F" || next === "G")
      return "H";
    else if (next === "L")
      return "M";
    else if (next === "V")
      return "W";
    else if (next === "X" || next === "Y")
      return "Z";
    else
      return next;
  }

  if (!x)
    x = getvariable(u);
  var constant = 'C';
  while (!Expression.free_of(u, parser.fromInfix(constant)))
    constant = nextConst(constant);
  return Expression.construct(Types.SumOp, null,
      [Simplify.automatic_simplify(Calculus.integral(u, x)), parser.fromInfix(constant)]);
};

function substitute(expr, eqn) {
  var split = Solve.splitEquation(eqn);
  var x = split.lhs;
  var vars = [...new Set(...expr.map(Expression.getVariables))];
  if (vars.findIndex(e => Expression.equal_expressions(e, x)) < 0)
    return expr;	// unchanged
  else
    return expr.map(e => Simplify.automatic_simplify(Expression.substitute(e, x, split.rhs)));
}

function handleplot(latex) {
  latex = latex.split(",");
  var L = [];
  var math = latex.map(u => parser.inputFromInfix(latexToMath(u.replace(/\\ /g, "").trim())));

  var fs = math.map(f => {
    if (Solve.isEquation(f)) {
      var g = Solve.splitEquation(f);
      if (Expression.equal_expressions(g.lhs, Types.Y))
        f = g.rhs;
      else if (Expression.equal_expressions(g.rhs, Types.Y))
        f = g.lhs;
      else
        f = Solve.splitEquation(Solve.normaliseEquation(f, null, true)).lhs;
    }
    L = L.concat(Expression.getVariables(f));
    return Expression.printInfix(f);
  });

  L = L.filter((c, i, a) => i === a.findIndex(e => c.value === e.value)).map(Expression.printInfix);
  postMessage(["plot", fs, latex, L]);
}


function realruncommand(command, pretext, pretextpost, latex, invokecommand) {
  try {
    var output;
    lasterror = null;

// 		Config.startTimeCheck();
    latex = latex.replace(/\^{\s*}/g, "");

    if (Matrix.checkMatrixType(latex))	// any type check here
    {
      var ms = Matrix.parseMatrix(latex);
      Matrix.handlematrix(ms, parser, invokecommand);
      return;
    }

    if (command === "plot") {
      handleplot(latex);
      return;
    } else if (command === "solve") {
      handlesolve(latex, true);
      return;
    }

    var bits = AvantiUtils.splitNoParen(latex, ",");
    var n = bits.length;

    var math = bits.map(u => Simplify.automatic_simplify(
        parser.inputFromInfix(latexToMath(u.replace(/\\ /g, "").trim()))));

    var arg;
    var extra_str;
    if (n == 1) {
      arg = getvariable(math);
      extra_str = Expression.printInfix(arg);
    }
    if (!arg) {
      extra_str = bits[n - 1].replace(/\\ /g, "").trim();
      arg = parser.inputFromInfix(latexToMath(extra_str));
      arg = Simplify.automatic_simplify(arg);
    }

    if (pretext)
      pretext = pretext.replace('@', 'd' + extra_str);
    if (pretextpost)
      pretextpost = pretextpost.replace('@', 'd' + extra_str);
    switch (command) {
      case "autosimplify":
        execute(math, u => u, false, null, false, latex, output, pretext, pretextpost);
        break;
      case "calculate":
        execute(math, u => evaluate(u), false, null, true, latex, output, pretext, pretextpost);
        break;
      case "expand":
        if (n > 1)
          throw "Invalid format";
        execute(math[0], u => fullexpand(u), false, null, true, latex, output, pretext, pretextpost);
        break;
      case "transform":
        if (n > 1)
          throw "Invalid format";
        execute(math[0], u => fullsimplify(u), false, null, false, latex, output, pretext, pretextpost);
        break;
      case "factor":
        if (n > 2)
          throw "Invalid format";
        execute(math[0], (u, x) => factorise(u, x), true, arg, false, latex, output, pretext, pretextpost);
        break;
      case "integrate":
        if (n > 2)
          throw "Invalid format";
        execute(math[0], (u, x) => integral(u, x), true, arg, false, latex, output, pretext, pretextpost);
        break;
      case "differentiate":
        if (n > 2)
          throw "Invalid format";
        execute(math[0], (u, x) => derivative(u, x), true, arg, true, latex, output, pretext, pretextpost);
        break;
      case "substitute":
        math.pop();	// drop the substitution equation
        execute(math, (u, x) => substitute(u, x), true, arg, true, latex, output, pretext, pretextpost);
        break;
      case "invoke":
        execute(math, u => handleinvoke(u[0], latex, invokecommand), false, null, false,
            latex, output, pretext, pretextpost);
        break;
      default:
        throw "unknown command";
    }
  } catch (e) {
    console.log(e);
    if (command === "invoke")
      postMessage(["error", "Unable to execute " + invokecommand]);
    else
      postMessage(["error", "Unable to " + command]);
  }
}

function handleinvoke(u, latex, invokecommand) {
  if (invokecommand === "numerator")
    return Eval.functions[Types.fnNTOR].eval(Rational.rationalise_expression(u));
  else if (invokecommand === "denominator")
    return Eval.functions[Types.fnDTOR].eval(Rational.rationalise_expression(u));
  throw "unknown invoke command: " + invokecommand;
}

function dosimplify(u) {
  u = Array.isArray(u) ? u : [u];
  return u.map(e => e.latex ? e : Simplify.automatic_simplify(e));
}

function execute(math, fn, getvar, variable, autosimplify, latex, output, pretext, pretextpost) {
  lasterror = null;
  if (getvar) {
    if (!variable) {
      getvariable(math, x => {
        var output = fn(math, x);
        if (autosimplify)
          output = dosimplify(output);
        displayOutput(latex, output, pretext, pretextpost);
      });
    } else {
      var output = fn(math, variable);
      if (autosimplify)
        output = dosimplify(output);
      displayOutput(latex, output, pretext, pretextpost);
    }
  } else {
    var output = fn(math);
    if (autosimplify)
      output = dosimplify(output);
    displayOutput(latex, output, pretext, pretextpost);
  }
  lasterror = null;
}

function manageControls(latex, surpresserror) {
  try {
    var split = latex.split(",");
    var us = split.map((s) => parser.fromInfix(latexToMath(s)));
    var L = [].concat(...us.map(Expression.getVariables)).filter(
        (c, i, a) => i === a.findIndex(e => c.value === e.value));
    var lastissym;
    try {
      lastissym = split.length == 1 || Types.isSymbol(us[us.length - 1]);
    } catch (e) {
      lastissym = false;
    }

    var result = {
      splitlength: split.length,
      lastissym: lastissym,
      isexp: isExpression(latex),
      isfnx: L.length && L.findIndex(e => Expression.equal_expressions(e, Types.X)) >= 0,
      iseqn: isEquation(latex),
      includeseqn: split.some(l => isEquation(l)),
      alleqn: split.every(l => isEquation(l)),
      allbuteqn: (split.length > 1) && split.slice(0, -1).every(l => isEquation(l)),
      isineq: isInequation(latex),
      canexp: canExpand(latex),
      cansub: canSubstitute(latex),
      hasreal: us.some(Types.includesRealNumber),
      variables: L.map(e => e.value)
    };

    postMessage(["manage", result]);
  } catch (e) {
    if (!surpresserror)
      console.log(e);
    postMessage(["manage", null]);
  }
}


var Matrix = {};

(function(context) {

  var classifier = new Classifier();
  classifier.setupEval();
  var parser = new Parser();
  var humanise = new Humanise();

  context.checkMatrixType = function(latex) {
    var i = latex.indexOf("matrix");
    return i ? latex.charAt(i - 1) : false;
  }

  // type is p for (), v for || and b for []
  context.parseMatrix = function(mathquill) {
    var matrices = {};
    var mat;
    var start = 0;
    var m = 1;

    var reduced = mathquill;
    while (mat = findNextMatrix(reduced, 0)) {
      // substitute each matrix with a symbol Mn
      var matv = 'M' + m++;
      matrices[matv] = {matrix: mat.matrix, dim: mat.dim};
      reduced = mat.rest.replace("@M@", matv);
    }

    return {matrixmap: matrices, expr: reduced, raw: mathquill};
  }

  var findNextMatrix = function(string, start) {
    // type is p for (), v for || and b for []
    var type = context.checkMatrixType(string);
    if (!type)
      return null;
    // format is \begin(pmatrix)1&2&3\\4&5&6\\7&8&9\end(pmatrix)
    var matstart = string.indexOf("\\begin{" + type + "matrix}", start);
    var matend = string.indexOf("\\end{" + type + "matrix}", start);
    if (matstart < 0 || matend < 0)
      return null;
    var matrixstring = string.substring(matstart + ("\\begin{" + type + "matrix}").length, matend);
    var rows = matrixstring.split("\\\\");
    var m = rows.length;
    var matrix = [];
    rows.forEach(r => matrix.push(r.split("&").map(
        e => Simplify.automatic_simplify(parser.fromInfix(latexToMath(e))))));
    var rest = string.substring(0, matstart) + "@M@" +
        string.substring(matend + ("\\end{" + type + "matrix}").length);
    var n = matrix[0].length;
    // validate
    if (!matrix.every(r => r.length == n))
      return null;
    var dim = [m, n];
    return {matrix, dim, rest};
  }

  // type is p for (), v for || and b for []
  context.tomathquillmatrix = function(mat, type) {
    var m = [];
    var textm = [];
    for (var i = 0; i < mat.dim[0]; ++i) {
      var row = [];
      var textrow = [];
      for (var j = 0; j < mat.dim[1]; ++j) {
        var s = mat.matrix[i][j];
        s = humanise.apply([Simplify.automatic_simplify(s)]);
        s = Expression.printInfix(s[0]);
        textrow.push(s);
        s = parser.parse(s);
        s = parser.splitLists(s);
        s = parser.toLaTeX(s);
        row.push(s);
      }
      m.push(row.join(" & "));
      textm.push(textrow.join(", "));
    }
    var mqstring = "\\begin{" + type + "matrix}" + m.join("\\\\") + "\\end{" + type + "matrix}";
    var textstring = textm.length > 1 ? "[[" + textm.join("], [") + "]]" : "[" + textm.join("], [") + "]";

    return {mqstring, textstring};
  }

  context.handlematrix = function(ms, parser, invokecommand) {
    var result;
    try {
      // ms.expr is the expression in terms of M1, M2 etc
      // ms.matrix has the map connecting the actual matrices to the M1, M2 placeholders
      // 2. parse to postfix

      var bits = ms.expr.split(",");
      if (bits.length > 2)
        throw "Error in matrix command format";
      if (bits.length == 2) {
        var mat = ms.matrixmap.M1;	// operate on a single matrix only
        var ops = bits[1].replace(/\\ /g, "").replace(/R_(\d+)/g, "R$1").replace(/C_(\d+)/g, "C$1");
        if (ops.match(/[RC]\d+\s*\\leftrightarrow\s*[RC]\d+/))
          result = exchange(mat, ops);
        else {
          var e = parser.fromInfix(latexToMath(ops));
          if (Types.isUndefined(e) || !mat)
            throw "Unable to interpret matrix command";
          result = rowcolop(mat, e);
        }
      } else {
        var postfix = parser.parse(latexToMath(ms.expr, true));
        if (invokecommand) {
          var mat = ms.matrixmap.M1;	// operate on a single matrix only
          if (postfix.length != 1 || !mat)
            throw "Error: " + invokecommand + " requires a single matrix argument";
          if (invokecommand === "determinant") {
            ms.raw = ms.raw.replace(/pmatrix/g, "vmatrix");
            result = Simplify.automatic_simplify(context.deteriminant(mat));
          } else if (invokecommand === "norm") {
            if (isVector(mat)) {
              ms.raw = ms.raw.replace(/\\begin{pmatrix}/, "\\left\\lVert\\begin{pmatrix}")
                  .replace(/\\end{pmatrix}/, "\\end{pmatrix}\\right\\rVert");
              result = Simplify.automatic_simplify(context.norm(mat));
            } else
              throw "Argument is not a vector";
          } else if (invokecommand === "transpose") {
            ms.raw = "transpose " + ms.raw;
            result = context.transpose(mat);
          } else
            throw "Invalid matrix operation";
        } else {
          // 3. evaluate, substituting back the matrix for the placeholders
          result = simpleEval(postfix, ms.matrixmap, parser);
        }
      }
      // 4. create the output
      var outlatex, outtext;
      if (result.matrix) {
        var converted = context.tomathquillmatrix(result, "p");
        outlatex = {latex: converted.mqstring};
        outtext = converted.textstring;
      } else {
        outtext = Expression.printInfix(result);
        var math = parser.parse(outtext);
        outlatex = {write: parser.toLaTeX(parser.splitLists(math))};
      }
      postMessage([ms.raw, [outlatex], outtext, null, null]);
    } catch (e) {
      console.log(e);
      lasterror = "Invalid matrix operation";
      postMessage(["error", e]);
    }
  }

  // only support +,-,*,^ for matrices
  // TODO other ops are determinant and row/col ops which I will need to get from the input prior to this
  function simpleEval(postfix, mmap, parser) {
    var result = null;
    var stack = [];
    var i = 0;
    while (i < postfix.length) {
      var e = postfix[i];
      if (classifier.isOperator(e.value.key)) {
        if (e.value.arity == 1) {
          var x = stack.pop();
          stack.push(context.operate(e, [x], mmap));
        } else {
          var a = stack.pop();
          var b = stack.pop();
          stack.push(context.operate(e, [b, a], mmap));
        }
      } else if (classifier.isSpecialIdentifier(e.value)) {
        stack.push(e);
      } else if (classifier.isNumber(e.value) || classifier.isIdentifier(e.value)) {
        stack.push(parser.fromInfix("" + e.value));
      } else {
        lasterror = "Invalid matrix operation";
        throw lasterror;
      }
      i++;
    }

    if (stack.length != 1)
      throw "Error in expression";
    result = stack[0];
    return result.value && classifier.isSpecialIdentifier(result.value) ? mmap[result.value] : result;
  }

  context.operate = function(op, args, mmap) {
    /*
 * Supported operators:
 *  +, -, _ (?), *, ^ (for integer exponents only)
 */
    var type = parser.getTypeForASTtoken(op.value);
    var a, b;
    if (args[0].value && classifier.isSpecialIdentifier(args[0].value))
      a = mmap[args[0].value];
    else
      a = args[0];
    if (op.value.arity == 2) {
      if (args[1].value && classifier.isSpecialIdentifier(args[1].value))
        b = mmap[args[1].value];
      else
        b = args[1];
    }
    if (type == Types.SumOp || type == Types.DiffOp) {
      if (!b && (type == Types.DiffOp))	// unary minus
      {
        if (a.matrix)
          return context.mul(Types.MINUSONE, a);
        else
          return Expression.neg(a);
      } else if (a.matrix && b.matrix)
        return context.addorsub(a, b, type == Types.SumOp ? Expression.sum : Expression.diff);
      else if (a.matrix || b.matrix)
        throw "Incompatible matrices";
      else
        return (type == Types.SumOp ? Expression.sum : Expression.diff)(a, b);
    } else if (type == Types.ProdOp) {
      if (a.matrix && b.matrix) {
        if (isVector(a) && isVector(b))
          return context.dot(a, b);
        else
          return context.mmul(a, b);
      } else if (!a.matrix && b.matrix)
        return context.mul(a, b);
      else if (a.matrix && !b.matrix)
        throw "Incompatible matrices";
      else
        return Expression.prod(a, b);
    } else if (type == Types.PowOp) {
      if (a.matrix && (a.dim[0] == a.dim[1]) && Types.isInteger(b))
        return context.pow(a, b);
      else if (a.matrix || b.matrix)
        throw "Unsupported matrix operation";
      else
        return Expression.pow(a, b);
    } else if (type == Types.CrossOp) {
      if (isThreeVector(a) && isThreeVector(b))
        return context.cross(a, b);
      else
        throw "Cross product requires two 3-vectors";
    }

    if (a.matrix || b.matrix)
      throw "Unsupported matrix operation";
    else // this should not be possible
      return Simplify.automatic_simplify(Expression.construct(type, null, [a, b]));
  }

  var validrow = function(mat, rcinfo) {
    return rcinfo.row && rcinfo.row > 0 && rcinfo.row <= mat.dim[0];
  };
  var validcol = function(mat, rcinfo) {
    return rcinfo.col && rcinfo.col > 0 && rcinfo.col <= mat.dim[1];
  };

  function exchange(mat, ops) {
    try {
      var bits = ops.split("\\leftrightarrow");
      var t1rcinfo = checkrowcolop(bits[0].trim());
      var t2rcinfo = checkrowcolop(bits[1].trim());
      var i;
      if (validrow(mat, t1rcinfo) && validrow(mat, t2rcinfo)) {
        for (i = 0; i < mat.dim[1]; ++i) {
          var t = mat.matrix[t1rcinfo.row - 1][i];
          mat.matrix[t1rcinfo.row - 1][i] = mat.matrix[t2rcinfo.row - 1][i];
          mat.matrix[t2rcinfo.row - 1][i] = t;
        }
        return mat;
      }
      if (validcol(mat, t1rcinfo) && validcol(mat, t2rcinfo)) {
        for (i = 0; i < mat.dim[0]; ++i) {
          var t = mat.matrix[i][t1rcinfo.col - 1];
          mat.matrix[i][t1rcinfo.col - 1] = mat.matrix[i][t2rcinfo.col - 1];
          mat.matrix[i][t2rcinfo.col - 1] = t;
        }
        return mat;
      }
    } catch (e) {
      console.log(e);
    }
    throw "Error in row/col operation expression";
  }

  function rowcolop(mat, e) {
    var getfactor = function(u) {
      if (Types.isOpOfType(u, Types.ProdOp)) {
        // must be factor * Rn/Cn
        var f, rc;
        switch (Expression.num_operands(u)) {
          case 2:
            f = Expression.operand(u, 1);
            rc = Expression.operand(u, 2);
            break;
          case 0:
          case 1:
            break;	// invalid
          default:
            rc = u.children.pop();
            f = u;
            break;
        }
        return {rc, f};
      } else if (classifier.isSpecialIdentifier(u.value)) {
        return {rc: u, f: Types.ONE};
      }
      return null;
    }

    try {
      var frc;
      e = Simplify.automatic_simplify(e);
      if (Types.isOpOfType(e, Types.ProdOp)) {
        // must be factor * Rn/Cn
        frc = getfactor(e);
        if (frc) {
          var rcinfo = checkrowcolop(frc.rc.value);
          if (validrow(mat, rcinfo))
            return rowop(mat, rcinfo.row, frc.f, null);
          else if (validcol(mat, rcinfo))
            return colop(mat, rcinfo.col, frc.f, null);
        }
      } else if (Types.isOpOfType(e, Types.SumOp)) {
        // must be Rn/Cn + factor * Rm/Cm or just Rn/Cn + Rm/Cm
        if (Expression.num_operands(e) == 2) {
          var t1 = Expression.operand(e, 1);
          var t2 = Expression.operand(e, 2);
          if (Types.isOperator(t1) && !Types.isOperator(t2)) {
            // auto simplify has reversed the terms
            var temp = t1;
            t1 = t2;
            t2 = temp;
          }
          var t1rcinfo = checkrowcolop(t1.value);
          frc = getfactor(t2);
          if (frc) {
            var t2rcinfo = checkrowcolop(frc.rc.value);
            if (validrow(mat, t1rcinfo) && validrow(mat, t2rcinfo))
              return rowop(mat, t1rcinfo.row, frc.f, t2rcinfo.row);
            if (validcol(mat, t1rcinfo) && validcol(mat, t2rcinfo))
              return colop(mat, t1rcinfo.col, frc.f, t2rcinfo.col);
          }
        }
      }
    } catch (e) {
      console.log(e);
    }
    throw "Error in row/col operation expression";
  }

  function rowop(mat, r1, f, r2) {
    var i;
    if (r2) {
      // r1 -> r1 + f.r2
      for (i = 0; i < mat.dim[1]; ++i) {
        mat.matrix[r1 - 1][i] = Expression.sum(mat.matrix[r1 - 1][i], Expression.prod(mat.matrix[r2 - 1][i], f));
      }
    } else {
      // r1 -> f.r1
      for (i = 0; i < mat.dim[1]; ++i) {
        mat.matrix[r1 - 1][i] = Expression.prod(mat.matrix[r1 - 1][i], f);
      }
    }
    return mat;
  }

  function colop(mat, c1, f, c2) {
    var i;
    if (c2) {
      // c1 -> c1 + f.c2
      for (i = 0; i < mat.dim[0]; ++i) {
        mat.matrix[i][c1 - 1] = Expression.sum(mat.matrix[i][c1 - 1], Expression.prod(mat.matrix[i][c2 - 1], f));
      }
    } else {
      // c1 -> f.c1
      for (i = 0; i < mat.dim[0]; ++i) {
        mat.matrix[i][c1 - 1] = Expression.prod(mat.matrix[i][c1 - 1], f);
      }
    }
    return mat;
  }

  function checkrowcolop(arg) {
    if (typeof arg === "string") {
      if (arg.charAt(0) == "R")
        return {row: parseInt(arg.substring(1))};
      else if (arg.charAt(0) == "C")
        return {col: parseInt(arg.substring(1))};
    }
    throw "Error in row/col operation expression";
  }

  function isVector(v) {
    return v.matrix && v.dim[0] == 1;
  }

  function isThreeVector(v)	// only support 3 vector
  {
    return isVector(v) && v.dim[1] == 3;
  }

  context.identity = function(n) {
    var matrix = [];
    for (var i = 0; i < n; ++i) {
      var r = [];
      for (var j = 0; j < n; ++j) {
        r.push(i == j ? Types.ONE : Types.ZERO);
      }
      matrix.push(r);
    }
    return {matrix: matrix, dim: [n, n]};
  }

  context.deteriminant = function(m) {
    if (m.dim[0] != m.dim[1])
      throw "Non-square matrix";
    return internaldet([].concat(...m.matrix));
  }

  var internaldet = function(m) {
    var size = Math.sqrt(m.length);
    if (size % 1 !== 0) {
      return null;
    }
    if (size === 2) {
      return Expression.diff(Expression.prod(m[0], m[3]), Expression.prod(m[1], m[2]));
    }
    return m.slice(0, size).reduce(function(t, v, i) {
      var sub = [];
      for (var r = size; r < m.length; r += size) {
        sub = sub.concat(
            m.slice(r, r + i),
            m.slice(r + i + 1, r + size)
        );
      }
      if (i % 2)
        v = Expression.neg(v);
      return Expression.sum(t, Expression.prod(v, internaldet(sub)));
    }, Types.ZERO);
  }

  context.copy = function(mat) {
    var matrix = [];
    var dim = mat.dim;
    for (var i = 0; i < dim[0]; ++i) {
      var r = [];
      for (var j = 0; j < dim[1]; ++j) {
        r.push(Expression.copy(mat.matrix[i][j]));
      }
      matrix.push(r);
    }
    return {matrix, dim};
  }

  context.transpose = function(mat) {
    var matrix = mat.matrix[0].map((col, i) => mat.matrix.map(row => row[i]));
    return {matrix: matrix, dim: mat.dim.reverse()};
  }

  context.norm = function(a) {
    if (!isVector(a))
      throw "Input is not a vector";
    var r = Types.ZERO;
    for (var j = 0; j < a.dim[1]; ++j) {
      r = Expression.sum(r, Expression.prod(a.matrix[0][j], a.matrix[0][j]));
    }
    return Expression.pow(r, Types.HALF);
  }

  context.dot = function(a, b) {
    if (!isVector(a) || !isVector(b))
      throw "Dot product requires two vectors";
    else if (a.dim[0] != 1 || b.dim[0] != 1 || a.dim[1] != b.dim[1])
      throw "Dot product requires vectors of equal-dimension";
    var r = Types.ZERO;
    for (var j = 0; j < a.dim[1]; ++j) {
      r = Expression.sum(r, Expression.prod(a.matrix[0][j], b.matrix[0][j]));
    }
    return r;
  }

  context.cross = function(u, v) {
    if (!isThreeVector(u) || !isThreeVector(v))
      throw "Cross product requires two 3-vectors";

    var prod = [];
    var dim = [1, 3];

    var x, y;

    x = Expression.prod(u.matrix[0][1], v.matrix[0][2]);
    y = Expression.prod(u.matrix[0][2], v.matrix[0][1]);
    prod.push(Expression.diff(x, y));
    x = Expression.prod(u.matrix[0][2], v.matrix[0][0]);
    y = Expression.prod(u.matrix[0][0], v.matrix[0][2]);
    prod.push(Expression.diff(x, y));
    x = Expression.prod(u.matrix[0][0], v.matrix[0][1]);
    y = Expression.prod(u.matrix[0][1], v.matrix[0][0]);
    prod.push(Expression.diff(x, y));

    return {matrix: [prod], dim: dim};
  }

  context.toRightTriangular = function(mat) {
    if (mat.length == 0)
      return mat;
    var M = context.copy(mat);
    var els;
    var n = mat.dim[0], i, j, np = mat.dim[1], p;
    for (i = 0; i < n; i++) {
      if (Types.isZero(M.matrix[i][i])) {
        for (j = i + 1; j < n; j++) {
          if (!Types.isZero(M.matrix[j][i])) {
            els = [];
            for (p = 0; p < np; p++) {
              els.push(Expression.sum(M.matrix[i][p], M.matrix[j][p]));
            }
            M.matrix[i] = els;
            break;
          }
        }
      }
      if (M.matrix[i][i] !== 0) {
        for (j = i + 1; j < n; j++) {
          var multiplier = Expression.div(M.matrix[j][i], M.matrix[i][i]);
          els = [];
          for (p = 0; p < np; p++) {
            els.push(p <= i ? Types.ZERO :
                Expression.diff(M.matrix[j][p], Expression.prod(M.matrix[i][p], multiplier)));
          }
          M.matrix[j] = els;
        }
      }
    }
    return M;
  }

  context.augment = function(mat1, mat2) {
    if (mat1.dim[0] != mat2.dim[0])
      throw "Incompatible matrices";

    var matrix = context.copy(mat1);
    var dim = mat2.dim;

    for (var i = 0; i < dim[0]; ++i) {
      matrix.matrix[i].push(...mat2.matrix[i]);
    }
    dim[1] += mat1.dim[1];

    return {matrix: matrix.matrix, dim: dim};
  }

  context.inverse = function(mat) {
    if (mat.dim[0] != mat.dim[1])
      throw "No inverse";
    if (Types.isZero(context.deteriminant(mat)))
      throw "No inverse";

    var n = mat.dim[0], i = n, j;
    var M = context.toRightTriangular(context.augment(mat, context.identity(n)));
    var np = M.matrix[0].length, p, els, divisor;
    var inverse_elements = [], new_element;
    while (i--) {
      // First, normalise diagonal elements to 1
      els = [];
      inverse_elements[i] = [];
      divisor = M.matrix[i][i];
      for (p = 0; p < np; p++) {
        new_element = Expression.div(M.matrix[i][p], divisor);
        els.push(new_element);
        // Shuffle off the current row of the right hand side into the results
        // array as it will not be modified by later runs through this loop
        if (p >= n) {
          inverse_elements[i].push(new_element);
        }
      }
      M.matrix[i] = els;
      // Then, subtract this row from those above it to give the identity matrix
      // on the left hand side
      j = i;
      while (j--) {
        els = [];
        for (p = 0; p < np; p++) {
          els.push(Expression.diff(M.matrix[j][p], Expression.prod(M.matrix[i][p], M.matrix[j][i])));
        }
        M.matrix[j] = els;
      }
    }
    return {
      matrix: inverse_elements.map(e => fullsimplify(fullexpand(e))),
      dim: mat.dim
    };
  },

      context.pow = function(m, p) {
        if (Expression.equal_expressions(p, Types.ONE))
          return m;
        else if (Expression.equal_expressions(p, Types.MINUSONE))
          return context.inverse(m);
        if (m.dim[0] != m.dim[1])
          throw "Matrix is not square";
        var result = context.identity(m.dim[0]);
        var n = Types.toInteger(p);
        if (n == 0)
          return result;
        if (n < 0) {
          m = context.inverse(m);
          n = -n;
        }
        while (n) {
          if (n & 1)
            result = context.mmul(result, m);
          m = context.mmul(m, m);
          n >>= 1;
        }
        return result;
      }

  context.addorsub = function(mat1, mat2, f) {
    var n1 = mat1.dim[0];
    var n2 = mat2.dim[0];
    var m1 = mat1.dim[1];
    var m2 = mat2.dim[1];
    if ((n1 != n2) || (m1 != m2))
      throw "Incompatible matrices";
    var result = [];
    for (var i = 0; i < n1; ++i) {
      var t = [];
      for (var j = 0; j < m1; ++j) {
        t.push(f(mat1.matrix[i][j], mat2.matrix[i][j]));
      }
      result.push(t);
    }
    return {matrix: result, dim: [n1, m1]};
  }

  context.mul = function(l, mat2) {
    var n2 = mat2.dim[0];
    var m2 = mat2.dim[1];
    var result = [];
    for (var i = 0; i < n2; ++i) {
      var t = [];
      for (var j = 0; j < m2; ++j) {
        t.push(Expression.prod(l, mat2.matrix[i][j]));
      }
      result.push(t);
    }
    return {matrix: result, dim: [n2, m2]};
  }

  // m x n * n x p = m * p
  context.mmul = function(mat1, mat2, f) {
    var n1 = mat1.dim[0];
    var n2 = mat2.dim[0];
    var m1 = mat1.dim[1];
    var m2 = mat2.dim[1];
    if (m1 != n2)
      throw "Incompatible matrices";

    var result = [];
    for (var i = 0; i < n1; i++) {
      result[i] = [];
      for (var j = 0; j < m2; j++) {
        var sum = Types.ZERO;
        for (var k = 0; k < m1; k++) {
          sum = Expression.sum(sum, Expression.prod(mat1.matrix[i][k], mat2.matrix[k][j]));
        }
        result[i][j] = sum;
      }
    }
    return {matrix: result, dim: [n1, m2]};
  }
})(Matrix);


var AvantiUtils = {};

(function(context) {
  context.isinteger = function(n) {
    return (typeof n === 'number') && ((n % 1) === 0);
  }

  context.randKISS = function() {
    return (function(args) {
      // George Marsaglia, 2007-06-23
      //http://groups.google.com/group/comp.lang.fortran/msg/6edb8ad6ec5421a5
      var x = 123456789;
      var y = 362436069;
      var z = 21288629;
      var w = 14921776;
      var c = 0;

      if (args.length == 0) {
        args = [+new Date];
      }

      var mash = Mash();
      for (var i = 0; i < args.length; i++) {
        x ^= mash(args[i]) * 0x100000000; // 2^32
        y ^= mash(args[i]) * 0x100000000;
        z ^= mash(args[i]) * 0x100000000;
        w ^= mash(args[i]) * 0x100000000;
      }
      if (y === 0) {
        y = 1;
      }
      c ^= z >>> 31;
      z &= 0x7fffffff;
      if ((z % 7559) === 0) {
        z++;
      }
      w &= 0x7fffffff;
      if ((w % 7559) === 0) {
        w++;
      }
      mash = null;

      var uint32 = function() {
        var t;

        x += 545925293;
        x >>>= 0;

        y ^= y << 13;
        y ^= y >>> 17;
        y ^= y << 5;

        t = z + w + c;
        z = w;
        c = t >>> 31;
        w = t & 0x7fffffff;

        return x + y + w >>> 0;
      };

      function Mash() {
        var n = 0xefc8249d;
        var mash = function(data) {
          data = data.toString();
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000; // 2^32
          }
          return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };

        mash.version = 'Mash 0.9';
        return mash;
      };

      var random = function() {
        return uint32() * 2.3283064365386963e-10; // 2^-32
      };
      random.random = random;
      random.uint32 = uint32;
      random.fract53 = function() {
        return random() +
            (uint32() & 0x1fffff) * 1.1102230246251565e-16; // 2^-53
      };
      random.urand = function(max) {
        return 1 + uint32() % max;
      };

      random.fromTo = function(from, to) {
        return Math.floor(random() * (to - from + 1) + from);
      };

      /* choose a random element */
      random.choose = function(array) {
        return array[random.urand(array.count()) - 1];
      };

      /* n samples from 0 to size - with or without replacement */
      random.sample = function(n, min, max, replace) {
        var i, j;
        var samples = [];
        var size = max - min + 1;
        if (replace) {
          for (i = 0; i < n; ++i)
            samples[i] = min + random.urand(size) - 1;
        } else {
          for (i = 0; i < size; ++i)
            samples[i] = i;
          for (i = 0; i < n; ++i) {
            j = random.urand(size) - 1;
            if (j != i) {
              swap = samples[i];
              samples[i] = samples[j];
              samples[j] = swap;
            }
          }
          for (i = 0; i < size; ++i)
            samples[i] += min;
        }
        return samples.slice(0, n).sort(function(a, b) {
          return a - b;
        });
      };

      random.shuffle = function(values, n) {
        var i, j;
        var size = n ? n : values.count();
        for (i = size - 1; i > 0; --i) {
          j = random.urand(i + 1) - 1;
          swap = values[j];
          values[j] = values[i];
          values[i] = swap;
        }
        return values;
      };

      random.args = args;
      random.version = 'KISS07 0.9';

      return random;
    }(Array.prototype.slice.call(arguments)));
  };

  /*
	 ** find rational approximation to given real number
	 ** David Eppstein / UC Irvine / 8 Aug 1993
	 **
	 ** With corrections from Arno Formella, May 2008
	 **
	 ** usage: a.out r d
	 **   r is real number to approx
	 **   d is the maximum denominator allowed
	 **
	 ** based on the theory of continued fractions
	 ** if x = a1 + 1/(a2 + 1/(a3 + 1/(a4 + ...)))
	 ** then best approximation is found by truncating this series
	 ** (with some adjustments in the last term).
	 **
	 ** Note the fraction can be recovered as the first column of the matrix
	 **  ( a1 1 ) ( a2 1 ) ( a3 1 ) ...
	 **  ( 1  0 ) ( 1  0 ) ( 1  0 )
	 ** Instead of keeping the sequence of continued fraction terms,
	 ** we just keep the last partial product of these matrices.
	 */
  var convert = function(startx, maxden) {
    var m = [
      [1, 0], [0, 1]
    ];
    var x = startx,
        err1, err2;
    var ai;
    var result = {
      numerator: 0,
      denominator: 1
    };
    var neg = x < 0;

    if (neg) x = -x;
    /* loop finding terms until denom gets too big */
    while (m[1][0] * (ai = Math.floor(x)) + m[1][1] <= maxden) {
      var t = m[0][0] * ai + m[0][1];
      m[0][1] = m[0][0];
      m[0][0] = t;
      t = m[1][0] * ai + m[1][1];
      m[1][1] = m[1][0];
      m[1][0] = t;
      if (x == ai) break; // AF: division by zero
      x = 1 / (x - ai);
      //	    if (x > (double) 0x7FFFFFFF) break; // AF: representation failure
    }

    /* now remaining x is between 0 and 1/ai */
    /* approx as either 0 or 1/m where m is max that will fit in maxden */
    /* first try zero */
    err1 = startx - m[0][0] / m[1][0];

    result.numerator = m[0][0];
    result.denominator = m[1][0];

    /* now try other possibility */
    ai = (maxden - m[1][1]) / m[1][0];
    m[0][0] = m[0][0] * ai + m[0][1];
    m[1][0] = m[1][0] * ai + m[1][1];
    err2 = startx - m[0][0] / m[1][0];

    if (Math.abs(err2) < Math.abs(err1)) {
      result.numerator = m[0][0];
      result.denominator = m[1][0];
    }

    if (neg)
      result.numerator = -result.numerator;

    return result;
  }

  context.decimalToFraction = function(d, maxdenom) {
    if (isNaN(d))
      return {numerator: d, denominator: 1};
    var result = {
      numerator: 0,
      denominator: 1
    };
    var s = d > 0 ? 1 : -1;
    d = Math.abs(d);
    if (d == Math.floor(d)) {
      result.numerator = s * d;
      result.denominator = 1;
    } else if (d <= Number.MIN_VALUE) {
      result.numerator = 0;
      result.denominator = maxdenom;
    } else if (d < 5 / (10 * maxdenom)) {
      result.numerator = 0;
      result.denominator = maxdenom;
    } else {
      result = convert(d, maxdenom);
      if (s == -1) result.numerator *= s;
      //    double scratch, z = d;
      //    double prevd = 0;
      //    result.numerator = 0;
      //    result.denominator = 1;
      //    long zi = (long)z;
      //
      //    do
      //    {
      //      if (z == zi)
      //        break;
      //      z = 1.0 / (z - zi);
      //      zi = (long)z;
      //      scratch = result.denominator;
      //      result.denominator = result.denominator * zi + prevd;
      //      prevd = scratch;
      //      result.numerator = (long)(d * result.denominator + 0.5);
      //    } while (fabs(d - fractionToDecimal(result)) > DBL_EPSILON);
      //
      //    result.numerator *= s;
    }
    result.numerator = Math.floor(result.numerator);
    result.denominator = Math.floor(result.denominator);
    return result;
  }

  context.splitNoParen = function(s, sep, left, right) {
    var results = [];
    var str = '';
    var c = 0;
    if (!left)
      left = "(";
    if (!right)
      right = ")";

    for (var i = 0; i < s.length; i++) {
      if (s[i] == left)
        c++;
      else if (s[i] == right)
        c--;
      else if (s[i] == sep) {
        if (!c) {
          results.push(str);
          str = '';
          continue;
        }
      }
      str += s[i];
    }

    if (str.length)
      results.push(str);
    return results;
  }
})(AvantiUtils);

var Factors = {};

(function(context) {
  var isinteger = AvantiUtils.isinteger;

  context.factors = function(n) {
    function getPrimeFactorization(input) {
      var primeFactors = [];

      // The algorithm
      (function factorNumber(input) {
        if (input == 1)
          return;
        else if (kensutils.isPrime(input)) {
          primeFactors.push(input);
          return;
        }
        var divisor = rho(input, x => x * x - 1);
        factorNumber(divisor);
        factorNumber(input / divisor);
      })(input);

      primeFactors.sort(function(a, b) {
        return a - b;
      });
      return primeFactors;
    }

    function rho(input, func) {
      var num1 = 2, num2 = 2, divisor;
      if (input % 2 == 0)
        return 2;
      do {
        num1 = func(num1) % input;
        num2 = func(func(num2)) % input;
        divisor = context.gcd(Math.abs(num1 - num2), input);
      } while (divisor == 1);

      if (divisor == input) {
        return rho(input, x => x * x + 1);
      }
      return divisor;
    }

    if (!context.smallprimes) {
      context.smallprimes = context.sieve(1000);
    }

    var factors = [];
    if (isinteger(n) && n && n < 4294967296) {
      if (n < 0)
        factors.push(-1);

      /* first get the little factors */
      for (var i = 0; i < context.smallprimes.length; ++i) {
        while (n % context.smallprimes[i] == 0) {
          factors.push(context.smallprimes[i]);
          n /= context.smallprimes[i];
        }
        if (Math.abs(n) == 1)
          break;
      }

      if (n != 1 && n != -1) {
        factors.push.apply(factors, getPrimeFactorization(n));
      }
    } else
      factors = [n];

    return factors;
  }

  context.divisors = function(n) {
    var divisors = [];
    if (n && isinteger(n)) {
      if (n < 0)
        n = -n;
      if (n == 1)
        return [1];

      var small = [1];
      var large = [n];
      var max = Math.sqrt(n);
      var i = 1;
      while (++i < max) {
        if (n % i == 0) {
          small.push(i);
          large.push(n / i);
        }
      }
      if (i * i == n)
        small.push(i);
      return small.concat(large.reverse());
    }
    return [];
  }
})(Factors);

var NumericalPolynomial = {};

(function(context) {
  var phi;

  context.init = function() {
    phi = [
      [],
      [1, -1],								// x-1
      [1, 1],									// x+1
      [1, 1, 1],							// x^2+x+1
      [1, 0, 1],							// x^2+1
      [1, 1, 1, 1, 1],				// x^4+x^3+x^2+x+1
      [1, -1, 1],							// x^2-x+1
      [1, 1, 1, 1, 1, 1, 1],	// x^6+x^5+x^4+x^3+x^2+x+1
      [1, 0, 0, 0, 1],				// x^4+1
      [1, 0, 0, 1, 0, 0, 1],	// x^6+x^3+1
      [1, 1, 1, 1, 1],				// x^4-x^3+x^2-x+1
    ]
  }

  function denom(n) {
    var p = [1];
    for (var d = 1; d < n; ++d) {
      if (n % d == 0) {
        p = context.mul(p, context.cyclotomic(d));
      }
    }
    return p;
  }

  function trim(p) {
    var zeroes = 0;
    for (var i = 0; i < p.length - 1; ++i) {
      if (p[i] != 0)
        break;
      zeroes++;
    }
    if (zeroes)
      p.splice(p.length - zeroes, zeroes);
    return p;
  }

  context.cyclotomic = function(n) {
    if (!phi)
      context.init();
    if (phi[n])
      return phi[n];
    var xnm1 = new Array(n + 1).fill(0);
    xnm1[0] = 1;
    xnm1[n] = -1;
    var p = context.div(xnm1, denom(n));
    phi[n] = p.q;

    if (p.r.length != 1 || p.r[0])
      throw "Error";
    return phi[n];
  }

  context.print = function(p, x) {
    var empty = true;
    var s = '';
    var i = 0;
    p = trim(p);
    var n = p.length - 1;
    if (!x)
      x = 'x';
    while (i <= n) {
      var c = p[i];
      if (c || (empty && !i)) {
        if (!empty || c < 0)
          s += c > 0 ? '+' : '-';
        if (Math.abs(c) != 1 || i == n)
          s += Math.abs(c);
        if (i < n) {
          s += x;
        }
        if (i < n - 1)
          s += "^" + (n - i);
        empty = false;
      }
      i++;
    }
    return s;
  }

  context.mul = function(p, q) {
    var np = p.length - 1;
    var nq = q.length - 1;
    var result = new Array(np + nq + 1).fill(0);

    for (var i = 0; i <= np; ++i) {
      for (var j = 0; j <= nq; ++j) {
        result[i + j] += p[i] * q[j];
      }
    }

    return trim(result);
  }

  context.div = function(n, d) {
    var nq, q, nr, r;

    var i, qi = 0;

    var nn = n.length - 1;
    var nd = d.length - 1;

    if (nn >= nd) {
      /* setup the quotient polynomial */
      nq = nn - nd;
      q = new Array(nq + 1).fill(0);
      var ntemp = nn;
      var temp = new Array(ntemp + 1).fill(0);
      while (nn >= nd) {
        /* multiply d by fx^(n-d) - corresponds to shifting d and multiplying by scalar f */
        var f = n[qi] / d[0];
        for (i = 0; i <= ntemp; ++i)
          temp[i] = i >= qi && i <= nd + qi ? f * d[i - qi] : 0;
        q[qi++] = f;
        for (i = 0; i <= ntemp; ++i)
          n[i] = n[i] - temp[i];
        nn--;
      }
    } else {
      q = null;
    }
    nr = nn;
    r = new Array(nr + 1);
    for (i = 0; i <= nr; ++i) {
      r[i] = n[qi + i];
    }

    return {q: trim(q), r: trim(r)};
  }
})(NumericalPolynomial);
